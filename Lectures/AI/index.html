<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit 1: AI Overview & Search Techniques - Theoretical Coursework | Artificial Intelligence</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #1e3a5f 0%, #0d1b2a 100%);
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 25px 80px rgba(0,0,0,0.4);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #1e3a5f 0%, #3d5a80 50%, #98c1d9 100%);
            color: white;
            padding: 50px 40px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: pulse 4s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 0.3; }
        }

        header h1 {
            font-size: 2.8em;
            margin-bottom: 10px;
            position: relative;
            z-index: 1;
        }

        header h1 i {
            margin-right: 15px;
        }

        header p {
            font-size: 1.3em;
            opacity: 0.95;
            position: relative;
            z-index: 1;
        }

        .course-info {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
            position: relative;
            z-index: 1;
        }

        .course-badge {
            background: rgba(255,255,255,0.2);
            padding: 8px 20px;
            border-radius: 25px;
            font-size: 0.95em;
            backdrop-filter: blur(5px);
        }

        .content {
            padding: 50px;
        }

        /* Course Outcome Box */
        .co-box {
            background: linear-gradient(135deg, #e8f4f8 0%, #d1e8f0 100%);
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 40px;
            border-left: 6px solid #1e3a5f;
            box-shadow: 0 4px 15px rgba(30,58,95,0.15);
        }

        .co-box h2 {
            color: #1e3a5f;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .co-box h2 i {
            margin-right: 10px;
        }

        .co-box p {
            font-size: 1.1em;
            color: #2c3e50;
        }

        .co-box .outcome-tag {
            display: inline-block;
            background: #1e3a5f;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        /* Navigation Tabs */
        .nav-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            background: #1e3a5f;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 40px;
        }

        .nav-tab {
            padding: 12px 20px;
            background: rgba(255,255,255,0.1);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.95em;
            border: none;
            text-decoration: none;
        }

        .nav-tab:hover, .nav-tab.active {
            background: #98c1d9;
            color: #1e3a5f;
            transform: translateY(-2px);
        }

        .nav-tab i {
            margin-right: 8px;
        }

        /* Section Styling */
        section {
            margin-bottom: 60px;
            scroll-margin-top: 20px;
        }

        h2 {
            color: #1e3a5f;
            font-size: 2.2em;
            margin-bottom: 25px;
            padding-bottom: 12px;
            border-bottom: 4px solid #3d5a80;
            display: flex;
            align-items: center;
        }

        h2 i {
            margin-right: 15px;
            color: #3d5a80;
        }

        h3 {
            color: #3d5a80;
            font-size: 1.6em;
            margin-top: 35px;
            margin-bottom: 20px;
        }

        h3 i {
            margin-right: 10px;
        }

        h4 {
            color: #4a6fa5;
            font-size: 1.3em;
            margin-top: 25px;
            margin-bottom: 15px;
        }

        h4 i {
            margin-right: 8px;
        }

        h5 {
            color: #2c5282;
            font-size: 1.15em;
            margin-top: 20px;
            margin-bottom: 12px;
        }

        /* Definition Box */
        .definition {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 5px solid #1976d2;
            position: relative;
        }

        .definition::before {
            content: 'DEFINITION';
            position: absolute;
            top: -12px;
            left: 20px;
            background: #1976d2;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 0.75em;
            font-weight: bold;
        }

        .definition strong {
            color: #0d47a1;
        }

        .definition i {
            margin-right: 10px;
            color: #1976d2;
        }

        /* Formal Definition Box */
        .formal-definition {
            background: linear-gradient(135deg, #f3e5f5 0%, #e1bee7 100%);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 5px solid #7b1fa2;
            position: relative;
        }

        .formal-definition::before {
            content: 'FORMAL DEFINITION';
            position: absolute;
            top: -12px;
            left: 20px;
            background: #7b1fa2;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 0.75em;
            font-weight: bold;
        }

        /* What Why When How Box */
        .wwwh-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .wwwh-item {
            padding: 25px;
            border-radius: 12px;
            transition: transform 0.3s ease;
        }

        .wwwh-item:hover {
            transform: translateY(-5px);
        }

        .wwwh-item.what {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border-left: 5px solid #4caf50;
        }

        .wwwh-item.why {
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
            border-left: 5px solid #ff9800;
        }

        .wwwh-item.when {
            background: linear-gradient(135deg, #fce4ec 0%, #f8bbd9 100%);
            border-left: 5px solid #e91e63;
        }

        .wwwh-item.how {
            background: linear-gradient(135deg, #e1f5fe 0%, #b3e5fc 100%);
            border-left: 5px solid #03a9f4;
        }

        .wwwh-item h4 {
            color: #333;
            margin-top: 0;
            margin-bottom: 10px;
        }

        /* Example Boxes */
        .example-box {
            background: linear-gradient(135deg, #fff8e1 0%, #ffecb3 100%);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 5px solid #ff8f00;
        }

        .example-box.student {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border-left: 5px solid #4caf50;
        }

        .example-box.realworld {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            border-left: 5px solid #2196f3;
        }

        .example-box.industry {
            background: linear-gradient(135deg, #f3e5f5 0%, #e1bee7 100%);
            border-left: 5px solid #9c27b0;
        }

        .example-title {
            font-weight: bold;
            font-size: 1.15em;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .example-title i {
            margin-right: 10px;
        }

        .example-level {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.75em;
            font-weight: bold;
        }

        .example-level.student { background: #c8e6c9; color: #2e7d32; }
        .example-level.realworld { background: #bbdefb; color: #1565c0; }
        .example-level.industry { background: #e1bee7; color: #7b1fa2; }

        /* Pros Cons Box */
        .pros-cons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }

        .pros-box {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            padding: 25px;
            border-radius: 12px;
            border-left: 5px solid #4caf50;
        }

        .cons-box {
            background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
            padding: 25px;
            border-radius: 12px;
            border-left: 5px solid #f44336;
        }

        .pros-box h4, .cons-box h4 {
            margin-top: 0;
            margin-bottom: 15px;
        }

        .pros-box h4 { color: #2e7d32; }
        .cons-box h4 { color: #c62828; }

        .pros-box ul, .cons-box ul {
            margin-left: 20px;
        }

        .pros-box li, .cons-box li {
            margin: 10px 0;
        }

        /* Algorithm Box */
        .algorithm-box {
            background: linear-gradient(135deg, #f3e5f5 0%, #e1bee7 100%);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 5px solid #9c27b0;
        }

        .algorithm-title {
            color: #6a1b9a;
            font-weight: bold;
            font-size: 1.2em;
            margin-bottom: 15px;
        }

        .algorithm-title i {
            margin-right: 10px;
        }

        .algorithm-steps {
            counter-reset: step-counter;
            list-style: none;
            padding-left: 0;
        }

        .algorithm-steps li {
            counter-increment: step-counter;
            margin: 15px 0;
            padding-left: 50px;
            position: relative;
        }

        .algorithm-steps li::before {
            content: counter(step-counter);
            position: absolute;
            left: 0;
            top: 0;
            background: #9c27b0;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9em;
        }

        /* Complexity Box */
        .complexity-box {
            background: linear-gradient(135deg, #e0f2f1 0%, #b2dfdb 100%);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .complexity-item {
            text-align: center;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        .complexity-item .label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
        }

        .complexity-item .value {
            font-size: 1.4em;
            font-weight: bold;
            color: #00695c;
            font-family: 'Fira Code', monospace;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border-radius: 12px;
            overflow: hidden;
        }

        th {
            background: linear-gradient(135deg, #1e3a5f 0%, #3d5a80 100%);
            color: white;
            padding: 18px 15px;
            text-align: left;
            font-weight: 600;
        }

        td {
            padding: 15px;
            border-bottom: 1px solid #e5e7eb;
        }

        tr:nth-child(even) {
            background: #f8fafc;
        }

        tr:hover {
            background: #e8f4f8;
        }

        /* Case Study Box */
        .case-study {
            background: linear-gradient(135deg, #fce4ec 0%, #f8bbd9 100%);
            padding: 30px;
            border-radius: 15px;
            margin: 30px 0;
            border-left: 6px solid #c2185b;
        }

        .case-study-title {
            color: #880e4f;
            font-weight: bold;
            font-size: 1.3em;
            margin-bottom: 15px;
        }

        .case-study-title i {
            margin-right: 10px;
        }

        /* Key Points */
        .key-points {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
        }

        .key-points h4 {
            color: #1565c0;
            margin-top: 0;
        }

        .key-points ul {
            margin-left: 25px;
        }

        .key-points li {
            margin: 12px 0;
        }

        .key-points li::marker {
            color: #1976d2;
        }

        /* Tip Box */
        .tip-box {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            border-left: 5px solid #10b981;
        }

        .tip-box strong {
            color: #047857;
        }

        .tip-box i {
            margin-right: 10px;
            color: #10b981;
        }

        /* Warning Box */
        .warning-box {
            background: linear-gradient(135deg, #fef2f2 0%, #fecaca 100%);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            border-left: 5px solid #ef4444;
        }

        .warning-box i {
            margin-right: 10px;
            color: #ef4444;
        }

        /* Exam Question Box */
        .exam-box {
            background: linear-gradient(135deg, #ede9fe 0%, #ddd6fe 100%);
            padding: 30px;
            border-radius: 15px;
            margin: 30px 0;
            border-left: 6px solid #7c3aed;
        }

        .exam-title {
            color: #5b21b6;
            font-weight: bold;
            font-size: 1.3em;
            margin-bottom: 15px;
        }

        .exam-title i {
            margin-right: 10px;
        }

        .marks-badge {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .marks-badge.four { background: #fef3c7; color: #b45309; }
        .marks-badge.eight { background: #fee2e2; color: #dc2626; }

        /* Comparison Grid */
        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .comparison-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border-top: 5px solid #3d5a80;
            transition: transform 0.3s ease;
        }

        .comparison-card:hover {
            transform: translateY(-5px);
        }

        .comparison-card h4 {
            margin-top: 0;
            color: #1e3a5f;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 2px solid #e5e7eb;
        }

        /* Highlight */
        .highlight {
            background: linear-gradient(135deg, #fef08a 0%, #fde047 100%);
            padding: 2px 8px;
            border-radius: 4px;
        }

        /* Simple Explanation Box */
        .simple-explanation {
            background: linear-gradient(135deg, #fffde7 0%, #fff9c4 100%);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 5px solid #fbc02d;
        }

        .simple-explanation-title {
            color: #f57f17;
            font-weight: bold;
            font-size: 1.2em;
            margin-bottom: 12px;
        }

        .simple-explanation-title i {
            margin-right: 10px;
        }

        /* Real-World Analogy Box */
        .analogy-box {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            padding: 30px;
            border-radius: 16px;
            margin: 30px 0;
            border-left: 6px solid #f59e0b;
            box-shadow: 0 4px 20px rgba(245, 158, 11, 0.2);
        }

        .analogy-box .analogy-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            color: #92400e;
            font-size: 1.4em;
            font-weight: bold;
        }

        .analogy-box .analogy-header i {
            font-size: 1.5em;
        }

        .analogy-box .analogy-scenario {
            background: rgba(255,255,255,0.8);
            padding: 20px;
            border-radius: 12px;
            margin: 15px 0;
        }

        .analogy-box .analogy-scenario h5 {
            color: #b45309;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        /* Mechanism Box */
        .mechanism-box {
            background: linear-gradient(135deg, #e0f7fa 0%, #b2ebf2 100%);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 5px solid #00acc1;
        }

        .mechanism-box h4 {
            color: #006064;
            margin-top: 0;
        }

        /* Characteristics Box */
        .characteristics-box {
            background: linear-gradient(135deg, #fce4ec 0%, #f8bbd0 100%);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 5px solid #ec407a;
        }

        /* Mathematical Formulation */
        .math-box {
            background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 5px solid #616161;
            font-family: 'Times New Roman', serif;
        }

        .math-box .formula {
            background: white;
            padding: 15px 25px;
            border-radius: 8px;
            text-align: center;
            font-size: 1.2em;
            margin: 10px 0;
            font-style: italic;
        }

        /* Footer */
        footer {
            background: linear-gradient(135deg, #1e3a5f 0%, #0d1b2a 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        footer p {
            opacity: 0.9;
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .container {
                box-shadow: none;
            }

            .nav-tabs {
                display: none;
            }

            section {
                page-break-inside: avoid;
            }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .content {
                padding: 25px;
            }

            h2 {
                font-size: 1.6em;
            }

            .wwwh-grid {
                grid-template-columns: 1fr;
            }

            .comparison-grid {
                grid-template-columns: 1fr;
            }

            .nav-tabs {
                flex-direction: column;
            }
        }

        /* Visual Diagram Styles */
        .diagram-container {
            background: #f8fafc;
            padding: 30px;
            border-radius: 12px;
            margin: 25px 0;
            text-align: center;
            overflow-x: auto;
        }

        .tree-node {
            display: inline-block;
            padding: 10px 20px;
            background: #3d5a80;
            color: white;
            border-radius: 25px;
            margin: 5px;
            font-weight: bold;
        }

        .tree-node.start { background: #10b981; }
        .tree-node.goal { background: #f59e0b; }
        .tree-node.visited { background: #6b7280; }

        /* Summary Box */
        .summary-box {
            background: linear-gradient(135deg, #1e3a5f 0%, #2d4a6f 100%);
            color: white;
            padding: 30px;
            border-radius: 15px;
            margin: 30px 0;
        }

        .summary-box h4 {
            color: #98c1d9;
            margin-top: 0;
        }

        .summary-box ul {
            margin-left: 20px;
        }

        .summary-box li {
            margin: 10px 0;
        }

        /* Walkthrough Box */
        .walkthrough-box {
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
            padding: 30px;
            border-radius: 16px;
            margin: 30px 0;
            border: 2px solid #22c55e;
        }

        .walkthrough-box .walkthrough-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            color: #15803d;
            font-size: 1.3em;
            font-weight: bold;
        }

        .walkthrough-box .step {
            background: white;
            padding: 20px;
            border-radius: 12px;
            margin: 15px 0;
            border-left: 5px solid #22c55e;
            position: relative;
        }

        .walkthrough-box .step-number {
            position: absolute;
            left: -25px;
            top: 20px;
            background: #22c55e;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.1em;
        }

        .walkthrough-box .step h5 {
            color: #166534;
            margin-bottom: 10px;
            padding-left: 25px;
        }

        .walkthrough-box .step p {
            padding-left: 25px;
        }

        /* Application Domains */
        .domain-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .domain-item {
            background: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            transition: transform 0.3s ease;
        }

        .domain-item:hover {
            transform: translateY(-5px);
        }

        .domain-item i {
            font-size: 2em;
            color: #3d5a80;
            margin-bottom: 10px;
        }

        .domain-item h5 {
            color: #1e3a5f;
            margin: 10px 0 5px 0;
        }

        .domain-item p {
            font-size: 0.9em;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-brain"></i>Artificial Intelligence</h1>
            <p style="font-size: 1.1em; margin-bottom: 5px; opacity: 0.9; position: relative; z-index: 1;"><i class="fas fa-user-tie"></i> by <strong>Dr. Ankush Rai</strong></p>
            <p>Unit 1: Overview & Search Techniques - Comprehensive Theoretical Coursework</p>
            <div class="course-info">
                <span class="course-badge"><i class="fas fa-book"></i> CO1: Problem Representation & AI Search</span>
                <span class="course-badge"><i class="fas fa-graduation-cap"></i> Theory Focus</span>
                <span class="course-badge"><i class="fas fa-file-alt"></i> Exam Preparation</span>
            </div>
        </header>

        <div class="content">
            <!-- Course Outcome Box -->
            <div class="co-box">
                <span class="outcome-tag"><i class="fas fa-bullseye"></i> Course Outcome 1 (CO1)</span>
                <h2><i class="fas fa-target"></i>Learning Objective</h2>
                <p><strong>CO1:</strong> Represent any well-defined problem and can apply AI Searching techniques to solve a problem.</p>
                <div style="margin-top: 15px; display: flex; flex-wrap: wrap; gap: 10px;">
                    <span style="background: #3d5a80; color: white; padding: 5px 12px; border-radius: 15px; font-size: 0.85em;">Problem Formulation</span>
                    <span style="background: #3d5a80; color: white; padding: 5px 12px; border-radius: 15px; font-size: 0.85em;">State Space Representation</span>
                    <span style="background: #3d5a80; color: white; padding: 5px 12px; border-radius: 15px; font-size: 0.85em;">Uninformed Search</span>
                    <span style="background: #3d5a80; color: white; padding: 5px 12px; border-radius: 15px; font-size: 0.85em;">Informed Search</span>
                    <span style="background: #3d5a80; color: white; padding: 5px 12px; border-radius: 15px; font-size: 0.85em;">Game Playing</span>
                </div>
            </div>

            <!-- Navigation Tabs -->
            <div class="nav-tabs">
                <a class="nav-tab active" href="#intro"><i class="fas fa-rocket"></i>Introduction to AI</a>
                <a class="nav-tab" href="#problem"><i class="fas fa-puzzle-piece"></i>Problem Representation</a>
                <a class="nav-tab" href="#statespace"><i class="fas fa-project-diagram"></i>State Space</a>
                <a class="nav-tab" href="#blind"><i class="fas fa-eye-slash"></i>Blind Search</a>
                <a class="nav-tab" href="#informed"><i class="fas fa-lightbulb"></i>Informed Search</a>
                <a class="nav-tab" href="#astar"><i class="fas fa-star"></i>A* & AO*</a>
                <a class="nav-tab" href="#game"><i class="fas fa-gamepad"></i>Game Trees</a>
                <a class="nav-tab" href="#minimax"><i class="fas fa-chess"></i>Mini-Max</a>
                <a class="nav-tab" href="#alphabeta"><i class="fas fa-cut"></i>Alpha-Beta</a>
            </div>

            <!-- ==================== SECTION 1: INTRODUCTION TO AI ==================== -->
            <section id="intro">
                <h2><i class="fas fa-robot"></i>1. Introduction to Artificial Intelligence</h2>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>Artificial Intelligence (AI)</strong> is the branch of computer science that deals with the simulation of intelligent behavior in computers. It is the capability of a machine to imitate intelligent human behavior including learning, reasoning, problem-solving, perception, and language understanding.</p>
                </div>

                <div class="formal-definition">
                    <p><strong>According to John McCarthy (Father of AI, 1956):</strong> "Artificial Intelligence is the science and engineering of making intelligent machines, especially intelligent computer programs. It is related to the similar task of using computers to understand human intelligence."</p>
                    <p style="margin-top: 15px;"><strong>According to Russell & Norvig:</strong> "AI is the study of agents that receive percepts from the environment and perform actions."</p>
                </div>

                <div class="wwwh-grid">
                    <div class="wwwh-item what">
                        <h4><i class="fas fa-question-circle"></i>WHAT is AI?</h4>
                        <p>AI is the capability of machines to perform tasks that typically require human intelligence. This includes:</p>
                        <ul style="margin-top: 10px; margin-left: 20px;">
                            <li>Learning from experience</li>
                            <li>Understanding natural language</li>
                            <li>Recognizing patterns</li>
                            <li>Making decisions</li>
                            <li>Solving complex problems</li>
                        </ul>
                    </div>
                    <div class="wwwh-item why">
                        <h4><i class="fas fa-lightbulb"></i>WHY is AI Important?</h4>
                        <ul style="margin-left: 20px;">
                            <li><strong>Automation:</strong> Automates repetitive and complex tasks</li>
                            <li><strong>Accuracy:</strong> Reduces human errors</li>
                            <li><strong>Speed:</strong> Processes data faster than humans</li>
                            <li><strong>Availability:</strong> Works 24/7 without fatigue</li>
                            <li><strong>Scalability:</strong> Handles massive datasets</li>
                        </ul>
                    </div>
                    <div class="wwwh-item when">
                        <h4><i class="fas fa-clock"></i>WHEN to Use AI?</h4>
                        <ul style="margin-left: 20px;">
                            <li>When dealing with large-scale data analysis</li>
                            <li>Pattern recognition tasks</li>
                            <li>Optimization and planning problems</li>
                            <li>Autonomous decision-making</li>
                            <li>Tasks requiring human-like reasoning at scale</li>
                            <li>Real-time processing requirements</li>
                        </ul>
                    </div>
                    <div class="wwwh-item how">
                        <h4><i class="fas fa-cogs"></i>HOW Does AI Work?</h4>
                        <ul style="margin-left: 20px;">
                            <li><strong>Search:</strong> Exploring solution spaces systematically</li>
                            <li><strong>Knowledge Representation:</strong> Storing and organizing information</li>
                            <li><strong>Learning:</strong> Improving through experience (ML)</li>
                            <li><strong>Reasoning:</strong> Drawing conclusions from knowledge</li>
                            <li><strong>Planning:</strong> Creating action sequences</li>
                        </ul>
                    </div>
                </div>

                <h3><i class="fas fa-layer-group"></i>Goals of Artificial Intelligence</h3>

                <div class="key-points">
                    <h4><i class="fas fa-bullseye"></i> Primary Goals of AI</h4>
                    <ul>
                        <li><strong>Systems that think like humans:</strong> Cognitive modeling - understanding human thought processes and replicating them</li>
                        <li><strong>Systems that act like humans:</strong> Turing Test approach - machines that behave indistinguishably from humans</li>
                        <li><strong>Systems that think rationally:</strong> Laws of thought approach - using logic to achieve goals</li>
                        <li><strong>Systems that act rationally:</strong> Rational agent approach - taking best possible action to achieve objectives</li>
                    </ul>
                </div>

                <h3><i class="fas fa-sitemap"></i>Types of Artificial Intelligence</h3>

                <h4>A. Based on Capabilities</h4>
                <table>
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Description</th>
                            <th>Characteristics</th>
                            <th>Examples</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Narrow AI (Weak AI)</strong></td>
                            <td>AI designed for a specific task</td>
                            <td>Limited to predefined functions, cannot generalize</td>
                            <td>Siri, Alexa, Chess engines, Spam filters</td>
                        </tr>
                        <tr>
                            <td><strong>General AI (Strong AI)</strong></td>
                            <td>AI with human-like intelligence</td>
                            <td>Can learn any intellectual task, self-aware</td>
                            <td>Hypothetical - not yet achieved</td>
                        </tr>
                        <tr>
                            <td><strong>Super AI</strong></td>
                            <td>AI surpassing human intelligence</td>
                            <td>Superior in all aspects including creativity, wisdom</td>
                            <td>Theoretical concept</td>
                        </tr>
                    </tbody>
                </table>

                <h4>B. Based on Functionality</h4>
                <table>
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Description</th>
                            <th>Memory</th>
                            <th>Examples</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Reactive Machines</strong></td>
                            <td>Responds to current input only, no memory</td>
                            <td>None</td>
                            <td>IBM Deep Blue, Simple game AI</td>
                        </tr>
                        <tr>
                            <td><strong>Limited Memory</strong></td>
                            <td>Uses past experiences for decisions</td>
                            <td>Short-term, task-specific</td>
                            <td>Self-driving cars, Chatbots</td>
                        </tr>
                        <tr>
                            <td><strong>Theory of Mind</strong></td>
                            <td>Understands emotions, beliefs, intentions</td>
                            <td>Complex social memory</td>
                            <td>Advanced social robots (research)</td>
                        </tr>
                        <tr>
                            <td><strong>Self-Aware AI</strong></td>
                            <td>Has consciousness and self-awareness</td>
                            <td>Complete autobiographical memory</td>
                            <td>Fictional - not achieved</td>
                        </tr>
                    </tbody>
                </table>

                <h3><i class="fas fa-code-branch"></i>Branches/Subfields of AI</h3>

                <div class="domain-grid">
                    <div class="domain-item">
                        <i class="fas fa-brain"></i>
                        <h5>Machine Learning</h5>
                        <p>Learning from data without explicit programming</p>
                    </div>
                    <div class="domain-item">
                        <i class="fas fa-comments"></i>
                        <h5>Natural Language Processing</h5>
                        <p>Understanding and generating human language</p>
                    </div>
                    <div class="domain-item">
                        <i class="fas fa-eye"></i>
                        <h5>Computer Vision</h5>
                        <p>Interpreting visual information from images/videos</p>
                    </div>
                    <div class="domain-item">
                        <i class="fas fa-robot"></i>
                        <h5>Robotics</h5>
                        <p>Building intelligent physical agents</p>
                    </div>
                    <div class="domain-item">
                        <i class="fas fa-user-graduate"></i>
                        <h5>Expert Systems</h5>
                        <p>Mimicking human expert decision-making</p>
                    </div>
                    <div class="domain-item">
                        <i class="fas fa-network-wired"></i>
                        <h5>Neural Networks</h5>
                        <p>Brain-inspired computing models</p>
                    </div>
                </div>

                <h3><i class="fas fa-industry"></i>Applications of AI</h3>

                <div class="example-box student">
                    <div class="example-title">
                        <i class="fas fa-user-graduate"></i>Student-Friendly Examples
                        <span class="example-level student">STUDENT</span>
                    </div>
                    <ul>
                        <li><strong>Virtual Assistants:</strong> Siri, Google Assistant helping with queries</li>
                        <li><strong>Recommendation Systems:</strong> YouTube suggesting videos, Spotify recommending songs</li>
                        <li><strong>Social Media:</strong> Face recognition in photos, content filtering</li>
                        <li><strong>Gaming:</strong> NPCs in video games, AI opponents in chess apps</li>
                        <li><strong>Education:</strong> Adaptive learning platforms, grammar checkers like Grammarly</li>
                    </ul>
                </div>

                <div class="example-box realworld">
                    <div class="example-title">
                        <i class="fas fa-globe"></i>Real-World Examples
                        <span class="example-level realworld">REAL-WORLD</span>
                    </div>
                    <ul>
                        <li><strong>Healthcare:</strong> Disease diagnosis, drug discovery, medical image analysis</li>
                        <li><strong>Transportation:</strong> GPS navigation, traffic prediction, autonomous vehicles</li>
                        <li><strong>Finance:</strong> Fraud detection, algorithmic trading, credit scoring</li>
                        <li><strong>Retail:</strong> Personalized shopping, inventory management, chatbots</li>
                        <li><strong>Agriculture:</strong> Crop monitoring, yield prediction, pest detection</li>
                    </ul>
                </div>

                <div class="example-box industry">
                    <div class="example-title">
                        <i class="fas fa-building"></i>Industry-Level Applications
                        <span class="example-level industry">INDUSTRY</span>
                    </div>
                    <ul>
                        <li><strong>Manufacturing:</strong> Predictive maintenance, quality control, robotic assembly (Tesla, BMW)</li>
                        <li><strong>Banking:</strong> Anti-money laundering, risk assessment, customer service (JPMorgan, HSBC)</li>
                        <li><strong>Telecommunications:</strong> Network optimization, customer churn prediction (Vodafone, AT&T)</li>
                        <li><strong>Oil & Gas:</strong> Exploration data analysis, equipment failure prediction (Shell, BP)</li>
                        <li><strong>Aerospace:</strong> Flight optimization, maintenance scheduling (Boeing, Airbus)</li>
                    </ul>
                </div>

                <div class="pros-cons">
                    <div class="pros-box">
                        <h4><i class="fas fa-check-circle"></i> Advantages of AI</h4>
                        <ul>
                            <li><strong>Efficiency:</strong> Faster processing and execution</li>
                            <li><strong>Accuracy:</strong> Reduced human errors</li>
                            <li><strong>Availability:</strong> 24/7 operation without breaks</li>
                            <li><strong>Handling Big Data:</strong> Process enormous datasets</li>
                            <li><strong>Dangerous Tasks:</strong> Can work in hazardous environments</li>
                            <li><strong>Consistency:</strong> Uniform performance without mood variations</li>
                        </ul>
                    </div>
                    <div class="cons-box">
                        <h4><i class="fas fa-times-circle"></i> Disadvantages of AI</h4>
                        <ul>
                            <li><strong>High Cost:</strong> Expensive to develop and maintain</li>
                            <li><strong>Job Displacement:</strong> May replace human workers</li>
                            <li><strong>Lack of Creativity:</strong> Cannot think outside trained patterns</li>
                            <li><strong>No Emotions:</strong> Cannot understand human feelings deeply</li>
                            <li><strong>Dependency:</strong> Over-reliance on technology</li>
                            <li><strong>Ethical Concerns:</strong> Privacy, bias, misuse risks</li>
                        </ul>
                    </div>
                </div>

                <!-- Exam Questions for Introduction -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-pen"></i> Important Exam Questions - Introduction to AI</div>

                    <div style="margin-bottom: 30px;">
                        <span class="marks-badge four">4 MARKS</span>
                        <p><strong>Q1. Define Artificial Intelligence. List any four goals of AI.</strong></p>
                        <div style="background: #f0fdf4; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #22c55e;">
                            <h5 style="color: #166534; margin-bottom: 15px;"><i class="fas fa-check-circle"></i> Model Answer:</h5>

                            <p><strong>Definition of Artificial Intelligence:</strong></p>
                            <p style="margin: 10px 0 15px 15px;">Artificial Intelligence (AI) is the branch of computer science that deals with creating intelligent machines capable of performing tasks that typically require human intelligence, such as learning, reasoning, problem-solving, perception, and language understanding. According to John McCarthy (1956), "AI is the science and engineering of making intelligent machines."</p>

                            <p><strong>Four Goals of Artificial Intelligence:</strong></p>
                            <ol style="margin-left: 25px;">
                                <li style="margin: 8px 0;"><strong>Systems that Think Humanly (Cognitive Modeling):</strong> Creating machines that think and reason like humans by understanding human thought processes through psychological experiments and brain imaging.</li>
                                <li style="margin: 8px 0;"><strong>Systems that Act Humanly (Turing Test):</strong> Building machines that behave indistinguishably from humans, passing the Turing Test through natural language processing, knowledge representation, and learning.</li>
                                <li style="margin: 8px 0;"><strong>Systems that Think Rationally (Laws of Thought):</strong> Developing systems that use formal logic and mathematical reasoning to derive conclusions and solve problems systematically.</li>
                                <li style="margin: 8px 0;"><strong>Systems that Act Rationally (Rational Agent):</strong> Creating agents that take the best possible actions to achieve their goals based on available information, even under uncertainty.</li>
                            </ol>
                        </div>
                    </div>

                    <div style="margin-bottom: 30px;">
                        <span class="marks-badge four">4 MARKS</span>
                        <p><strong>Q2. Differentiate between Narrow AI and General AI with examples.</strong></p>
                        <div style="background: #f0fdf4; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #22c55e;">
                            <h5 style="color: #166534; margin-bottom: 15px;"><i class="fas fa-check-circle"></i> Model Answer:</h5>

                            <table style="width: 100%; margin: 10px 0; font-size: 0.95em;">
                                <tr style="background: #1e3a5f; color: white;">
                                    <th style="padding: 10px;">Aspect</th>
                                    <th style="padding: 10px;">Narrow AI (Weak AI)</th>
                                    <th style="padding: 10px;">General AI (Strong AI)</th>
                                </tr>
                                <tr>
                                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Definition</strong></td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">AI designed for a specific task or narrow range of tasks</td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">AI with human-like intelligence that can perform any intellectual task</td>
                                </tr>
                                <tr style="background: #f8f8f8;">
                                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Capability</strong></td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">Limited to predefined functions; cannot generalize</td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">Can learn and apply knowledge across different domains</td>
                                </tr>
                                <tr>
                                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Current Status</strong></td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">Exists and widely deployed</td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">Hypothetical; not yet achieved</td>
                                </tr>
                                <tr style="background: #f8f8f8;">
                                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Examples</strong></td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">Siri, Alexa, Chess engines, Spam filters, Face recognition</td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">No real examples; depicted in Sci-Fi (HAL 9000, JARVIS)</td>
                                </tr>
                            </table>
                            <p style="margin-top: 10px;"><strong>Key Difference:</strong> Narrow AI excels at specific tasks but cannot adapt beyond its training, while General AI would possess human-like flexibility across all domains.</p>
                        </div>
                    </div>

                    <div style="margin-bottom: 30px;">
                        <span class="marks-badge eight">8 MARKS</span>
                        <p><strong>Q3. Explain the different types of AI based on functionality with suitable examples.</strong></p>
                        <div style="background: #f0fdf4; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #22c55e;">
                            <h5 style="color: #166534; margin-bottom: 15px;"><i class="fas fa-check-circle"></i> Model Answer:</h5>

                            <p><strong>Introduction:</strong> Based on functionality, AI systems are classified into four types according to their capabilities and level of intelligence:</p>

                            <p style="margin-top: 15px;"><strong>1. Reactive Machines:</strong></p>
                            <ul style="margin-left: 25px;">
                                <li><strong>Definition:</strong> The most basic AI that reacts to current situations without memory of past experiences.</li>
                                <li><strong>Characteristics:</strong> No memory, cannot learn from past, responds only to current input, highly specialized.</li>
                                <li><strong>Example:</strong> IBM Deep Blue (Chess computer) - analyzed board positions but couldn't learn from previous games.</li>
                            </ul>

                            <p style="margin-top: 15px;"><strong>2. Limited Memory AI:</strong></p>
                            <ul style="margin-left: 25px;">
                                <li><strong>Definition:</strong> AI that can store past experiences temporarily and use them for decisions.</li>
                                <li><strong>Characteristics:</strong> Learns from historical data, temporary task-specific memory, most current AI falls here.</li>
                                <li><strong>Examples:</strong> Self-driving cars (observe traffic), Chatbots (remember conversation context), Virtual assistants.</li>
                            </ul>

                            <p style="margin-top: 15px;"><strong>3. Theory of Mind AI:</strong></p>
                            <ul style="margin-left: 25px;">
                                <li><strong>Definition:</strong> AI that can understand emotions, beliefs, and intentions of others.</li>
                                <li><strong>Characteristics:</strong> Understands mental states, predicts behavior, capable of social interaction, currently in research.</li>
                                <li><strong>Example:</strong> Advanced social robots like Sophia (partial); fully functional version doesn't exist yet.</li>
                            </ul>

                            <p style="margin-top: 15px;"><strong>4. Self-Aware AI:</strong></p>
                            <ul style="margin-left: 25px;">
                                <li><strong>Definition:</strong> Hypothetical AI with consciousness, self-awareness, and sentience like humans.</li>
                                <li><strong>Characteristics:</strong> Has consciousness, understands own existence, can form emotions, completely theoretical.</li>
                                <li><strong>Example:</strong> No real examples; Science fiction: HAL 9000 (2001), Skynet (Terminator), JARVIS (Marvel).</li>
                            </ul>

                            <p style="margin-top: 15px; padding: 10px; background: #dbeafe; border-radius: 5px;"><strong>Conclusion:</strong> Currently, most AI systems are Reactive or Limited Memory types. Theory of Mind is under research, while Self-Aware AI remains theoretical.</p>
                        </div>
                    </div>

                    <div style="margin-bottom: 30px;">
                        <span class="marks-badge eight">8 MARKS</span>
                        <p><strong>Q4. Discuss the various applications of AI in different domains. Also mention the advantages and limitations of AI.</strong></p>
                        <div style="background: #f0fdf4; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #22c55e;">
                            <h5 style="color: #166534; margin-bottom: 15px;"><i class="fas fa-check-circle"></i> Model Answer:</h5>

                            <p><strong>Applications of AI in Different Domains:</strong></p>
                            <table style="width: 100%; margin: 10px 0; font-size: 0.9em;">
                                <tr style="background: #1e3a5f; color: white;">
                                    <th style="padding: 8px;">Domain</th>
                                    <th style="padding: 8px;">Applications</th>
                                </tr>
                                <tr><td style="padding: 8px; border: 1px solid #ddd;"><strong>Healthcare</strong></td><td style="padding: 8px; border: 1px solid #ddd;">Disease diagnosis, Medical imaging, Drug discovery, Robotic surgery</td></tr>
                                <tr style="background: #f8f8f8;"><td style="padding: 8px; border: 1px solid #ddd;"><strong>Finance</strong></td><td style="padding: 8px; border: 1px solid #ddd;">Fraud detection, Algorithmic trading, Credit scoring, Chatbots</td></tr>
                                <tr><td style="padding: 8px; border: 1px solid #ddd;"><strong>Transportation</strong></td><td style="padding: 8px; border: 1px solid #ddd;">Self-driving cars, Traffic prediction, Route optimization (GPS)</td></tr>
                                <tr style="background: #f8f8f8;"><td style="padding: 8px; border: 1px solid #ddd;"><strong>E-commerce</strong></td><td style="padding: 8px; border: 1px solid #ddd;">Product recommendations, Inventory management, Customer service bots</td></tr>
                                <tr><td style="padding: 8px; border: 1px solid #ddd;"><strong>Education</strong></td><td style="padding: 8px; border: 1px solid #ddd;">Adaptive learning, Automated grading, Intelligent tutoring systems</td></tr>
                            </table>

                            <p style="margin-top: 15px;"><strong>Advantages of AI:</strong></p>
                            <ol style="margin-left: 25px;">
                                <li><strong>Increased Efficiency:</strong> Processes data faster than humans</li>
                                <li><strong>Reduced Human Error:</strong> Consistent and accurate results</li>
                                <li><strong>24/7 Availability:</strong> Works continuously without breaks</li>
                                <li><strong>Handling Big Data:</strong> Analyzes massive datasets efficiently</li>
                                <li><strong>Dangerous Tasks:</strong> Works in hazardous environments</li>
                            </ol>

                            <p style="margin-top: 15px;"><strong>Limitations of AI:</strong></p>
                            <ol style="margin-left: 25px;">
                                <li><strong>High Development Cost:</strong> Expensive to create and maintain</li>
                                <li><strong>Job Displacement:</strong> May replace human workers</li>
                                <li><strong>Lack of Creativity:</strong> Cannot think outside training data</li>
                                <li><strong>No Emotional Intelligence:</strong> Cannot truly understand emotions</li>
                                <li><strong>Ethical Concerns:</strong> Privacy, bias, and misuse risks</li>
                            </ol>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ==================== SECTION 2: WELL-DEFINED PROBLEM REPRESENTATION ==================== -->
            <section id="problem">
                <h2><i class="fas fa-puzzle-piece"></i>2. Well-Defined Problem Representation & Solving</h2>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>Problem Representation</strong> in AI refers to the formal way of describing a problem so that it can be solved by AI techniques. A well-defined problem has clearly specified initial state, goal state, possible actions, and constraints.</p>
                </div>

                <h3><i class="fas fa-clipboard-list"></i>Components of a Well-Defined Problem</h3>

                <div class="mechanism-box">
                    <h4><i class="fas fa-cogs"></i> Five Essential Components</h4>
                    <ol style="margin-left: 20px;">
                        <li style="margin: 15px 0;"><strong>Initial State:</strong> The starting condition or configuration from which the problem-solving begins. It describes "where we are now."</li>
                        <li style="margin: 15px 0;"><strong>Goal State (Goal Test):</strong> The desired end condition that defines "where we want to be." It can be a single state or a set of states that satisfy certain criteria.</li>
                        <li style="margin: 15px 0;"><strong>Actions/Operators:</strong> The set of possible moves or operations that can transform one state to another. These define "what we can do."</li>
                        <li style="margin: 15px 0;"><strong>Path Cost Function:</strong> A function that assigns a numeric cost to each path. It helps in evaluating "how good is this solution."</li>
                        <li style="margin: 15px 0;"><strong>State Space:</strong> The set of all possible states reachable from the initial state by any sequence of actions.</li>
                    </ol>
                </div>

                <div class="wwwh-grid">
                    <div class="wwwh-item what">
                        <h4><i class="fas fa-question-circle"></i>WHAT is Problem Formulation?</h4>
                        <p>Problem formulation is the process of converting a real-world problem into a formal representation that can be processed by AI algorithms. It involves identifying states, actions, and goals in a structured manner.</p>
                    </div>
                    <div class="wwwh-item why">
                        <h4><i class="fas fa-lightbulb"></i>WHY is it Important?</h4>
                        <ul style="margin-left: 15px; font-size: 0.95em;">
                            <li>Enables systematic problem-solving</li>
                            <li>Makes problems computationally tractable</li>
                            <li>Allows application of search algorithms</li>
                            <li>Facilitates comparison of different solutions</li>
                        </ul>
                    </div>
                    <div class="wwwh-item when">
                        <h4><i class="fas fa-clock"></i>WHEN is a Problem Well-Defined?</h4>
                        <p>A problem is well-defined when:</p>
                        <ul style="margin-left: 15px; font-size: 0.95em;">
                            <li>Initial state is clearly specified</li>
                            <li>Goal is unambiguous</li>
                            <li>All possible actions are known</li>
                            <li>Cost function is determinable</li>
                        </ul>
                    </div>
                    <div class="wwwh-item how">
                        <h4><i class="fas fa-cogs"></i>HOW to Formulate a Problem?</h4>
                        <ol style="margin-left: 15px; font-size: 0.95em;">
                            <li>Identify the initial state</li>
                            <li>Define the goal state</li>
                            <li>Enumerate possible actions</li>
                            <li>Define transition model</li>
                            <li>Assign path costs</li>
                        </ol>
                    </div>
                </div>

                <h3><i class="fas fa-shapes"></i>Types of Problems</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Problem Type</th>
                            <th>Description</th>
                            <th>Characteristics</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Single-State Problem</strong></td>
                            <td>Agent knows exactly which state it will be in</td>
                            <td>Deterministic, fully observable</td>
                            <td>8-puzzle with visible tiles</td>
                        </tr>
                        <tr>
                            <td><strong>Multiple-State Problem</strong></td>
                            <td>Agent knows possible states but not exact state</td>
                            <td>Deterministic, partially observable</td>
                            <td>Vacuum cleaner without sensors</td>
                        </tr>
                        <tr>
                            <td><strong>Contingency Problem</strong></td>
                            <td>Outcomes of actions are uncertain</td>
                            <td>Non-deterministic, requires sensing</td>
                            <td>Navigation with uncertain terrain</td>
                        </tr>
                        <tr>
                            <td><strong>Exploration Problem</strong></td>
                            <td>State space is unknown initially</td>
                            <td>Unknown environment</td>
                            <td>Robot in unexplored territory</td>
                        </tr>
                    </tbody>
                </table>

                <h3><i class="fas fa-project-diagram"></i>Classic Problem Examples</h3>

                <!-- 8-Puzzle Problem -->
                <div class="case-study">
                    <div class="case-study-title"><i class="fas fa-th"></i> Case Study 1: 8-Puzzle Problem</div>

                    <p><strong>Problem Description:</strong> A 33 board with 8 numbered tiles and one blank space. The goal is to arrange tiles in a specific order by sliding them.</p>

                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0;">
                        <div style="background: white; padding: 15px; border-radius: 8px;">
                            <h5 style="color: #c2185b;">Initial State</h5>
                            <p>Any arrangement of tiles on the board</p>
                            <div style="font-family: monospace; background: #f0f0f0; padding: 10px; margin-top: 10px; text-align: center;">
                                | 2 | 8 | 3 |<br>
                                | 1 | 6 | 4 |<br>
                                | 7 | _ | 5 |
                            </div>
                        </div>
                        <div style="background: white; padding: 15px; border-radius: 8px;">
                            <h5 style="color: #c2185b;">Goal State</h5>
                            <p>Tiles arranged in order 1-8</p>
                            <div style="font-family: monospace; background: #f0f0f0; padding: 10px; margin-top: 10px; text-align: center;">
                                | 1 | 2 | 3 |<br>
                                | 8 | _ | 4 |<br>
                                | 7 | 6 | 5 |
                            </div>
                        </div>
                        <div style="background: white; padding: 15px; border-radius: 8px;">
                            <h5 style="color: #c2185b;">Actions</h5>
                            <ul style="margin-left: 15px;">
                                <li>Move blank UP</li>
                                <li>Move blank DOWN</li>
                                <li>Move blank LEFT</li>
                                <li>Move blank RIGHT</li>
                            </ul>
                        </div>
                        <div style="background: white; padding: 15px; border-radius: 8px;">
                            <h5 style="color: #c2185b;">Path Cost</h5>
                            <p>Each move costs 1</p>
                            <p>Total cost = Number of moves</p>
                            <p><strong>State Space:</strong> 9!/2 = 181,440 states</p>
                        </div>
                    </div>
                </div>

                <!-- Water Jug Problem -->
                <div class="case-study" style="background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%); border-left-color: #4caf50;">
                    <div class="case-study-title" style="color: #2e7d32;"><i class="fas fa-tint"></i> Case Study 2: Water Jug Problem</div>

                    <p><strong>Problem Description:</strong> Given two jugs of capacity 4 liters and 3 liters, measure exactly 2 liters of water.</p>

                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0;">
                        <div style="background: white; padding: 15px; border-radius: 8px;">
                            <h5 style="color: #2e7d32;">Initial State</h5>
                            <p>(0, 0) - Both jugs empty</p>
                        </div>
                        <div style="background: white; padding: 15px; border-radius: 8px;">
                            <h5 style="color: #2e7d32;">Goal State</h5>
                            <p>(2, n) - 4-liter jug has exactly 2 liters</p>
                        </div>
                        <div style="background: white; padding: 15px; border-radius: 8px;">
                            <h5 style="color: #2e7d32;">Actions (Production Rules)</h5>
                            <ul style="margin-left: 15px; font-size: 0.9em;">
                                <li>Fill 4-liter jug</li>
                                <li>Fill 3-liter jug</li>
                                <li>Empty 4-liter jug</li>
                                <li>Empty 3-liter jug</li>
                                <li>Pour from 4L to 3L jug</li>
                                <li>Pour from 3L to 4L jug</li>
                            </ul>
                        </div>
                    </div>

                    <div style="background: white; padding: 20px; border-radius: 8px; margin-top: 15px;">
                        <h5 style="color: #2e7d32;">Solution Path</h5>
                        <table style="margin: 10px 0; font-size: 0.9em;">
                            <tr><th>Step</th><th>Action</th><th>4L Jug</th><th>3L Jug</th></tr>
                            <tr><td>1</td><td>Fill 4L jug</td><td>4</td><td>0</td></tr>
                            <tr><td>2</td><td>Pour 4L  3L</td><td>1</td><td>3</td></tr>
                            <tr><td>3</td><td>Empty 3L jug</td><td>1</td><td>0</td></tr>
                            <tr><td>4</td><td>Pour 4L  3L</td><td>0</td><td>1</td></tr>
                            <tr><td>5</td><td>Fill 4L jug</td><td>4</td><td>1</td></tr>
                            <tr><td>6</td><td>Pour 4L  3L</td><td><strong>2</strong></td><td>3</td></tr>
                        </table>
                    </div>
                </div>

                <!-- Traveling Salesman Problem -->
                <div class="case-study" style="background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); border-left-color: #2196f3;">
                    <div class="case-study-title" style="color: #1565c0;"><i class="fas fa-route"></i> Case Study 3: Traveling Salesman Problem (TSP)</div>

                    <p><strong>Problem Description:</strong> A salesman must visit n cities exactly once and return to the starting city, minimizing total travel distance.</p>

                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0;">
                        <div style="background: white; padding: 15px; border-radius: 8px;">
                            <h5 style="color: #1565c0;">Initial State</h5>
                            <p>Salesman at starting city, no cities visited</p>
                        </div>
                        <div style="background: white; padding: 15px; border-radius: 8px;">
                            <h5 style="color: #1565c0;">Goal State</h5>
                            <p>All cities visited, returned to start</p>
                        </div>
                        <div style="background: white; padding: 15px; border-radius: 8px;">
                            <h5 style="color: #1565c0;">Actions</h5>
                            <p>Travel from current city to any unvisited city</p>
                        </div>
                        <div style="background: white; padding: 15px; border-radius: 8px;">
                            <h5 style="color: #1565c0;">Path Cost</h5>
                            <p>Sum of distances traveled</p>
                            <p><strong>Complexity:</strong> (n-1)!/2 possible tours</p>
                        </div>
                    </div>
                </div>

                <h3><i class="fas fa-list-ol"></i>Problem-Solving Steps in AI</h3>

                <div class="algorithm-box">
                    <div class="algorithm-title"><i class="fas fa-cogs"></i> General Problem-Solving Procedure</div>
                    <ol class="algorithm-steps">
                        <li><strong>Goal Formulation:</strong> Define what constitutes a successful solution</li>
                        <li><strong>Problem Formulation:</strong> Describe states, actions, and costs</li>
                        <li><strong>Search:</strong> Find a sequence of actions leading to the goal</li>
                        <li><strong>Execution:</strong> Carry out the actions in the solution</li>
                    </ol>
                </div>

                <div class="analogy-box">
                    <div class="analogy-header">
                        <i class="fas fa-lightbulb"></i> Real-World Analogy: Planning a Trip
                    </div>
                    <div class="analogy-scenario">
                        <h5>Planning a Journey from Delhi to Mumbai</h5>
                        <ul style="margin-left: 20px;">
                            <li><strong>Initial State:</strong> You are in Delhi</li>
                            <li><strong>Goal State:</strong> Reach Mumbai</li>
                            <li><strong>Actions:</strong> Take flight, train, bus, or drive</li>
                            <li><strong>Path Cost:</strong> Time, money, or distance</li>
                            <li><strong>State Space:</strong> All intermediate cities and connection options</li>
                        </ul>
                        <p style="margin-top: 15px;"><em>Just like this trip planning, AI problems need clear definition of start, end, and possible moves!</em></p>
                    </div>
                </div>

                <!-- Exam Questions -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-pen"></i> Important Exam Questions - Problem Representation</div>

                    <div style="margin-bottom: 30px;">
                        <span class="marks-badge four">4 MARKS</span>
                        <p><strong>Q1. What are the components of a well-defined problem in AI? Explain each briefly.</strong></p>
                        <div style="background: #f0fdf4; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #22c55e;">
                            <h5 style="color: #166534; margin-bottom: 15px;"><i class="fas fa-check-circle"></i> Model Answer:</h5>
                            <p>A well-defined problem in AI has <strong>five essential components</strong>:</p>
                            <ol style="margin-left: 25px; margin-top: 10px;">
                                <li style="margin: 10px 0;"><strong>Initial State:</strong> The starting condition from which problem-solving begins. It describes "where we are now."<br><em>Example: In 8-puzzle, the initial arrangement of tiles.</em></li>
                                <li style="margin: 10px 0;"><strong>Goal State (Goal Test):</strong> The desired end condition that defines success. It can be a single state or set of states.<br><em>Example: Tiles arranged in order 1-8.</em></li>
                                <li style="margin: 10px 0;"><strong>Actions/Operators:</strong> The set of possible moves that transform one state to another.<br><em>Example: Move blank UP, DOWN, LEFT, RIGHT.</em></li>
                                <li style="margin: 10px 0;"><strong>Path Cost Function:</strong> A function that assigns numeric cost to each path for evaluating solution quality.<br><em>Example: Each move costs 1; total cost = number of moves.</em></li>
                                <li style="margin: 10px 0;"><strong>State Space:</strong> The set of all possible states reachable from initial state by any sequence of actions.<br><em>Example: All 181,440 possible configurations of 8-puzzle.</em></li>
                            </ol>
                        </div>
                    </div>

                    <div style="margin-bottom: 30px;">
                        <span class="marks-badge eight">8 MARKS</span>
                        <p><strong>Q2. Formulate the 8-Puzzle problem as a well-defined AI problem. Define all components clearly.</strong></p>
                        <div style="background: #f0fdf4; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #22c55e;">
                            <h5 style="color: #166534; margin-bottom: 15px;"><i class="fas fa-check-circle"></i> Model Answer:</h5>

                            <p><strong>Problem Description:</strong> The 8-puzzle consists of a 33 board with 8 numbered tiles (1-8) and one blank space. Tiles slide into the blank space. Goal is to reach a specified configuration.</p>

                            <div style="display: flex; justify-content: space-around; margin: 15px 0; flex-wrap: wrap; gap: 15px;">
                                <div style="text-align: center; padding: 10px; background: #e0e0e0; border-radius: 8px;">
                                    <strong>Initial State</strong>
                                    <pre style="font-family: monospace; margin-top: 5px;">| 2 | 8 | 3 |
| 1 | 6 | 4 |
| 7 | _ | 5 |</pre>
                                </div>
                                <div style="text-align: center; padding: 10px; background: #c8e6c9; border-radius: 8px;">
                                    <strong>Goal State</strong>
                                    <pre style="font-family: monospace; margin-top: 5px;">| 1 | 2 | 3 |
| 8 | _ | 4 |
| 7 | 6 | 5 |</pre>
                                </div>
                            </div>

                            <p><strong>Problem Formulation:</strong></p>
                            <ol style="margin-left: 25px;">
                                <li style="margin: 8px 0;"><strong>Initial State:</strong> Any valid arrangement of 8 tiles and blank on 33 board.</li>
                                <li style="margin: 8px 0;"><strong>Goal State:</strong> Tiles arranged as 1,2,3,8,_,4,7,6,5. Goal test checks if current matches this.</li>
                                <li style="margin: 8px 0;"><strong>Actions/Operators:</strong>
                                    <ul style="margin-left: 20px;">
                                        <li>Move blank UP (if not in top row)</li>
                                        <li>Move blank DOWN (if not in bottom row)</li>
                                        <li>Move blank LEFT (if not in left column)</li>
                                        <li>Move blank RIGHT (if not in right column)</li>
                                    </ul>
                                </li>
                                <li style="margin: 8px 0;"><strong>Path Cost:</strong> Each move costs 1. Total cost = number of moves. Objective: minimize cost.</li>
                                <li style="margin: 8px 0;"><strong>State Space:</strong> Total arrangements = 9! = 362,880. Reachable states = 9!/2 = <strong>181,440</strong>. Branching factor: 2-4 (average  3).</li>
                            </ol>
                        </div>
                    </div>

                    <div style="margin-bottom: 30px;">
                        <span class="marks-badge eight">8 MARKS</span>
                        <p><strong>Q3. Explain the Water Jug Problem with its state space representation. Provide a solution path.</strong></p>
                        <div style="background: #f0fdf4; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #22c55e;">
                            <h5 style="color: #166534; margin-bottom: 15px;"><i class="fas fa-check-circle"></i> Model Answer:</h5>

                            <p><strong>Problem Statement:</strong> Given two jugs - 4-liter and 3-liter capacity - measure exactly 2 liters of water. Unlimited water supply available, no measuring marks on jugs.</p>

                            <p style="margin-top: 15px;"><strong>State Space Representation:</strong></p>
                            <ul style="margin-left: 25px;">
                                <li><strong>State:</strong> (x, y) where x = water in 4L jug (0x4), y = water in 3L jug (0y3)</li>
                                <li><strong>Initial State:</strong> (0, 0) - both jugs empty</li>
                                <li><strong>Goal State:</strong> (2, n) - 4L jug contains exactly 2 liters</li>
                            </ul>

                            <p style="margin-top: 15px;"><strong>Production Rules (Operators):</strong></p>
                            <table style="width: 100%; margin: 10px 0; font-size: 0.85em;">
                                <tr style="background: #1e3a5f; color: white;"><th>Rule</th><th>Condition</th><th>Action</th><th>Result</th></tr>
                                <tr><td>R1</td><td>x &lt; 4</td><td>Fill 4L jug</td><td>(4, y)</td></tr>
                                <tr style="background:#f0f0f0;"><td>R2</td><td>y &lt; 3</td><td>Fill 3L jug</td><td>(x, 3)</td></tr>
                                <tr><td>R3</td><td>x &gt; 0</td><td>Empty 4L jug</td><td>(0, y)</td></tr>
                                <tr style="background:#f0f0f0;"><td>R4</td><td>y &gt; 0</td><td>Empty 3L jug</td><td>(x, 0)</td></tr>
                                <tr><td>R5</td><td>x+y4, y&gt;0</td><td>Pour 3L4L till full</td><td>(4, y-(4-x))</td></tr>
                                <tr style="background:#f0f0f0;"><td>R6</td><td>x+y3, x&gt;0</td><td>Pour 4L3L till full</td><td>(x-(3-y), 3)</td></tr>
                                <tr><td>R7</td><td>x+y4, y&gt;0</td><td>Pour all 3L4L</td><td>(x+y, 0)</td></tr>
                                <tr style="background:#f0f0f0;"><td>R8</td><td>x+y3, x&gt;0</td><td>Pour all 4L3L</td><td>(0, x+y)</td></tr>
                            </table>

                            <p style="margin-top: 15px;"><strong>Solution Path:</strong></p>
                            <table style="width: 100%; margin: 10px 0;">
                                <tr style="background: #1e3a5f; color: white;"><th>Step</th><th>Rule</th><th>Action</th><th>4L Jug</th><th>3L Jug</th></tr>
                                <tr><td>0</td><td>-</td><td>Initial</td><td>0</td><td>0</td></tr>
                                <tr style="background:#f0f0f0;"><td>1</td><td>R1</td><td>Fill 4L jug</td><td>4</td><td>0</td></tr>
                                <tr><td>2</td><td>R6</td><td>Pour 4L  3L</td><td>1</td><td>3</td></tr>
                                <tr style="background:#f0f0f0;"><td>3</td><td>R4</td><td>Empty 3L jug</td><td>1</td><td>0</td></tr>
                                <tr><td>4</td><td>R8</td><td>Pour 4L  3L</td><td>0</td><td>1</td></tr>
                                <tr style="background:#f0f0f0;"><td>5</td><td>R1</td><td>Fill 4L jug</td><td>4</td><td>1</td></tr>
                                <tr style="background:#c8e6c9;"><td>6</td><td>R6</td><td>Pour 4L  3L</td><td><strong>2</strong></td><td>3</td></tr>
                            </table>
                            <p><strong>Result:</strong> Goal state (2, 3) achieved in 6 steps.</p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ==================== SECTION 3: STATE SPACE SEARCH ==================== -->
            <section id="statespace">
                <h2><i class="fas fa-project-diagram"></i>3. State Space Search</h2>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>State Space</strong> is a mathematical representation of a problem that includes all possible configurations (states) that the system can be in. It is typically represented as a graph or tree where nodes represent states and edges represent actions/operators.</p>
                </div>

                <div class="formal-definition">
                    <p><strong>State Space Search</strong> is the process of exploring the state space to find a path from the initial state to the goal state. The state space can be formally defined as a 4-tuple: <strong>S = (S, A, Action(s), Result(s,a))</strong></p>
                    <ul style="margin-top: 15px; margin-left: 20px;">
                        <li><strong>S:</strong> Set of all possible states</li>
                        <li><strong>A:</strong> Set of all possible actions</li>
                        <li><strong>Action(s):</strong> Returns actions applicable in state s</li>
                        <li><strong>Result(s,a):</strong> Returns state resulting from action a in state s</li>
                    </ul>
                </div>

                <div class="wwwh-grid">
                    <div class="wwwh-item what">
                        <h4><i class="fas fa-question-circle"></i>WHAT is State Space?</h4>
                        <p>State space is the collection of all possible states that can be reached from the initial state through valid operations. It forms the search space for finding solutions.</p>
                    </div>
                    <div class="wwwh-item why">
                        <h4><i class="fas fa-lightbulb"></i>WHY Use State Space?</h4>
                        <ul style="margin-left: 15px; font-size: 0.95em;">
                            <li>Provides structured problem representation</li>
                            <li>Enables systematic search</li>
                            <li>Allows algorithm comparison</li>
                            <li>Supports complexity analysis</li>
                        </ul>
                    </div>
                    <div class="wwwh-item when">
                        <h4><i class="fas fa-clock"></i>WHEN to Use State Space Search?</h4>
                        <ul style="margin-left: 15px; font-size: 0.95em;">
                            <li>Puzzle solving (8-puzzle, Rubik's cube)</li>
                            <li>Route planning</li>
                            <li>Game playing</li>
                            <li>Planning and scheduling</li>
                            <li>Constraint satisfaction</li>
                        </ul>
                    </div>
                    <div class="wwwh-item how">
                        <h4><i class="fas fa-cogs"></i>HOW Does State Space Search Work?</h4>
                        <ol style="margin-left: 15px; font-size: 0.95em;">
                            <li>Start from initial state</li>
                            <li>Generate successor states</li>
                            <li>Check if goal is reached</li>
                            <li>If not, expand promising nodes</li>
                            <li>Repeat until solution found</li>
                        </ol>
                    </div>
                </div>

                <h3><i class="fas fa-sitemap"></i>State Space Representation</h3>

                <div class="comparison-grid">
                    <div class="comparison-card">
                        <h4><i class="fas fa-bezier-curve"></i> Graph Representation</h4>
                        <ul style="margin-left: 20px;">
                            <li>States are represented as <strong>nodes</strong></li>
                            <li>Actions are represented as <strong>edges</strong></li>
                            <li>Multiple paths to same state possible</li>
                            <li>May contain cycles</li>
                            <li>More space-efficient</li>
                            <li>Requires cycle checking</li>
                        </ul>
                    </div>
                    <div class="comparison-card">
                        <h4><i class="fas fa-code-branch"></i> Tree Representation</h4>
                        <ul style="margin-left: 20px;">
                            <li>Root is the <strong>initial state</strong></li>
                            <li>Branches represent <strong>operators</strong></li>
                            <li>Leaves are goal or dead-end states</li>
                            <li>No cycles (tree structure)</li>
                            <li>May have duplicate states</li>
                            <li>Simpler to implement</li>
                        </ul>
                    </div>
                </div>

                <h3><i class="fas fa-key"></i>Key Concepts in State Space Search</h3>

                <div class="key-points">
                    <h4><i class="fas fa-list"></i> Essential Terminology</h4>
                    <ul>
                        <li><strong>Node:</strong> A data structure representing a state in the search tree, including parent pointer, action taken, path cost, and depth</li>
                        <li><strong>Expanding a Node:</strong> Generating all successor states by applying all applicable operators</li>
                        <li><strong>Frontier (Open List):</strong> Set of nodes that have been generated but not yet expanded</li>
                        <li><strong>Explored Set (Closed List):</strong> Set of states that have already been expanded</li>
                        <li><strong>Solution:</strong> A sequence of actions from initial state to goal state</li>
                        <li><strong>Optimal Solution:</strong> A solution with the lowest path cost among all solutions</li>
                    </ul>
                </div>

                <h3><i class="fas fa-chart-bar"></i>Measuring Search Performance</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Criterion</th>
                            <th>Description</th>
                            <th>Importance</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Completeness</strong></td>
                            <td>Is the algorithm guaranteed to find a solution if one exists?</td>
                            <td>Essential for reliability</td>
                        </tr>
                        <tr>
                            <td><strong>Optimality</strong></td>
                            <td>Does the algorithm find the best (lowest cost) solution?</td>
                            <td>Critical for cost-sensitive applications</td>
                        </tr>
                        <tr>
                            <td><strong>Time Complexity</strong></td>
                            <td>How long does it take to find a solution?</td>
                            <td>Determines practical feasibility</td>
                        </tr>
                        <tr>
                            <td><strong>Space Complexity</strong></td>
                            <td>How much memory is required during search?</td>
                            <td>Limits problem size that can be solved</td>
                        </tr>
                    </tbody>
                </table>

                <div class="math-box">
                    <h4 style="color: #616161;"><i class="fas fa-calculator"></i> Complexity Parameters</h4>
                    <ul style="margin-left: 20px; margin-top: 15px;">
                        <li><strong>b (Branching Factor):</strong> Maximum number of successors of any node</li>
                        <li><strong>d (Depth):</strong> Depth of the shallowest goal node</li>
                        <li><strong>m (Maximum Depth):</strong> Maximum length of any path in state space</li>
                    </ul>
                </div>

                <h3><i class="fas fa-code-branch"></i>Classification of Search Strategies</h3>

                <div class="diagram-container">
                    <div style="text-align: center; padding: 20px;">
                        <div style="display: inline-block; background: linear-gradient(135deg, #1e3a5f, #3d5a80); color: white; padding: 15px 30px; border-radius: 30px; font-weight: bold; font-size: 1.2em;">
                            SEARCH STRATEGIES
                        </div>
                        <div style="margin: 20px 0; font-size: 2em; color: #3d5a80;"></div>
                        <div style="display: flex; justify-content: center; gap: 50px; flex-wrap: wrap;">
                            <div style="text-align: center;">
                                <div style="background: #ef4444; color: white; padding: 12px 25px; border-radius: 25px; font-weight: bold;">
                                    UNINFORMED (Blind)
                                </div>
                                <div style="margin-top: 15px; padding: 15px; background: #fee2e2; border-radius: 10px;">
                                    <ul style="text-align: left; margin-left: 15px;">
                                        <li>Breadth-First Search</li>
                                        <li>Depth-First Search</li>
                                        <li>Uniform Cost Search</li>
                                        <li>Depth-Limited Search</li>
                                        <li>Iterative Deepening</li>
                                    </ul>
                                </div>
                            </div>
                            <div style="text-align: center;">
                                <div style="background: #22c55e; color: white; padding: 12px 25px; border-radius: 25px; font-weight: bold;">
                                    INFORMED (Heuristic)
                                </div>
                                <div style="margin-top: 15px; padding: 15px; background: #dcfce7; border-radius: 10px;">
                                    <ul style="text-align: left; margin-left: 15px;">
                                        <li>Greedy Best-First Search</li>
                                        <li>A* Search</li>
                                        <li>AO* Search</li>
                                        <li>Hill Climbing</li>
                                        <li>Beam Search</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="simple-explanation">
                    <div class="simple-explanation-title">
                        <i class="fas fa-lightbulb"></i>Understanding the Difference
                    </div>
                    <p><strong>Uninformed Search:</strong> Like finding your way in a dark room - you explore systematically but have no idea where the goal is.</p>
                    <p style="margin-top: 10px;"><strong>Informed Search:</strong> Like having a compass - you have some information (heuristic) that guides you toward the goal.</p>
                </div>

                <!-- Exam Questions -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-pen"></i> Important Exam Questions - State Space Search</div>

                    <div style="margin-bottom: 30px;">
                        <span class="marks-badge four">4 MARKS</span>
                        <p><strong>Q1. Define state space. What are the four criteria used to measure search algorithm performance?</strong></p>
                        <div style="background: #f0fdf4; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #22c55e;">
                            <h5 style="color: #166534; margin-bottom: 15px;"><i class="fas fa-check-circle"></i> Model Answer:</h5>

                            <p><strong>State Space Definition:</strong></p>
                            <p style="margin: 10px 0 15px 15px;">State Space is a mathematical representation of a problem consisting of all possible configurations (states) that the system can be in. It is typically represented as a graph where nodes represent states and edges represent actions/operators that transform one state to another.</p>

                            <p><strong>Four Criteria for Measuring Search Algorithm Performance:</strong></p>
                            <ol style="margin-left: 25px;">
                                <li style="margin: 8px 0;"><strong>Completeness:</strong> Is the algorithm guaranteed to find a solution if one exists? A complete algorithm will always find a solution in finite time.</li>
                                <li style="margin: 8px 0;"><strong>Optimality:</strong> Does the algorithm find the best (lowest cost) solution? An optimal algorithm guarantees the solution with minimum path cost.</li>
                                <li style="margin: 8px 0;"><strong>Time Complexity:</strong> How long does it take to find a solution? Usually expressed as O(b^d) where b=branching factor, d=depth.</li>
                                <li style="margin: 8px 0;"><strong>Space Complexity:</strong> How much memory is required during search? Measured as maximum nodes stored in memory.</li>
                            </ol>
                        </div>
                    </div>

                    <div style="margin-bottom: 30px;">
                        <span class="marks-badge four">4 MARKS</span>
                        <p><strong>Q2. Differentiate between uninformed and informed search strategies.</strong></p>
                        <div style="background: #f0fdf4; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #22c55e;">
                            <h5 style="color: #166534; margin-bottom: 15px;"><i class="fas fa-check-circle"></i> Model Answer:</h5>

                            <table style="width: 100%; margin: 10px 0; font-size: 0.95em;">
                                <tr style="background: #1e3a5f; color: white;">
                                    <th style="padding: 10px;">Aspect</th>
                                    <th style="padding: 10px;">Uninformed (Blind) Search</th>
                                    <th style="padding: 10px;">Informed (Heuristic) Search</th>
                                </tr>
                                <tr>
                                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Definition</strong></td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">Search without domain-specific knowledge</td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">Search using heuristics to guide toward goal</td>
                                </tr>
                                <tr style="background: #f8f8f8;">
                                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Knowledge</strong></td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">Only knows how to generate successors and identify goal</td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">Uses h(n) to estimate distance to goal</td>
                                </tr>
                                <tr>
                                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Efficiency</strong></td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">Less efficient; explores systematically</td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">More efficient; focuses on promising paths</td>
                                </tr>
                                <tr style="background: #f8f8f8;">
                                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Examples</strong></td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">BFS, DFS, Uniform Cost Search</td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">A*, Greedy Best-First, Hill Climbing</td>
                                </tr>
                            </table>
                            <p style="margin-top: 10px;"><strong>Analogy:</strong> Uninformed is like finding way in dark room; Informed is like using a compass toward destination.</p>
                        </div>
                    </div>

                    <div style="margin-bottom: 30px;">
                        <span class="marks-badge eight">8 MARKS</span>
                        <p><strong>Q3. Explain state space representation with graph and tree methods. Compare both approaches.</strong></p>
                        <div style="background: #f0fdf4; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #22c55e;">
                            <h5 style="color: #166534; margin-bottom: 15px;"><i class="fas fa-check-circle"></i> Model Answer:</h5>

                            <p><strong>1. Graph Representation:</strong></p>
                            <ul style="margin-left: 25px;">
                                <li>States represented as <strong>nodes</strong>, actions as <strong>edges</strong></li>
                                <li>Multiple paths to same state possible</li>
                                <li>May contain cycles (loops)</li>
                                <li>Requires cycle checking to avoid infinite loops</li>
                                <li>More memory-efficient (stores each state once)</li>
                            </ul>

                            <p style="margin-top: 15px;"><strong>2. Tree Representation:</strong></p>
                            <ul style="margin-left: 25px;">
                                <li>Root is <strong>initial state</strong>, branches are <strong>operators</strong></li>
                                <li>Leaves are goal states or dead-ends</li>
                                <li>No cycles (tree structure)</li>
                                <li>May have duplicate states on different branches</li>
                                <li>Simpler to implement</li>
                            </ul>

                            <p style="margin-top: 15px;"><strong>Comparison:</strong></p>
                            <table style="width: 100%; margin: 10px 0; font-size: 0.9em;">
                                <tr style="background: #1e3a5f; color: white;">
                                    <th style="padding: 8px;">Aspect</th>
                                    <th style="padding: 8px;">Graph</th>
                                    <th style="padding: 8px;">Tree</th>
                                </tr>
                                <tr><td style="padding: 8px; border: 1px solid #ddd;">Structure</td><td style="padding: 8px; border: 1px solid #ddd;">Nodes and edges with cycles</td><td style="padding: 8px; border: 1px solid #ddd;">Hierarchical, no cycles</td></tr>
                                <tr style="background: #f8f8f8;"><td style="padding: 8px; border: 1px solid #ddd;">Duplicate States</td><td style="padding: 8px; border: 1px solid #ddd;">Stored once</td><td style="padding: 8px; border: 1px solid #ddd;">May be duplicated</td></tr>
                                <tr><td style="padding: 8px; border: 1px solid #ddd;">Cycle Handling</td><td style="padding: 8px; border: 1px solid #ddd;">Needs explicit checking</td><td style="padding: 8px; border: 1px solid #ddd;">No cycles possible</td></tr>
                                <tr style="background: #f8f8f8;"><td style="padding: 8px; border: 1px solid #ddd;">Memory</td><td style="padding: 8px; border: 1px solid #ddd;">More efficient</td><td style="padding: 8px; border: 1px solid #ddd;">Less efficient</td></tr>
                                <tr><td style="padding: 8px; border: 1px solid #ddd;">Implementation</td><td style="padding: 8px; border: 1px solid #ddd;">Complex</td><td style="padding: 8px; border: 1px solid #ddd;">Simple</td></tr>
                            </table>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ==================== SECTION 4: BLIND/UNINFORMED SEARCH ==================== -->
            <section id="blind">
                <h2><i class="fas fa-eye-slash"></i>4. Blind Search (Uninformed Search)</h2>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>Uninformed Search (Blind Search)</strong> refers to search strategies that have no additional information about states beyond the problem definition. They can only generate successors and distinguish a goal state from a non-goal state. These strategies do not know whether one non-goal state is better than another.</p>
                </div>

                <div class="characteristics-box">
                    <h4><i class="fas fa-list-ul"></i> Characteristics of Blind Search</h4>
                    <ul style="margin-left: 20px;">
                        <li>No domain-specific knowledge used</li>
                        <li>Explores state space systematically</li>
                        <li>Cannot estimate distance to goal</li>
                        <li>Generates successors in a fixed order</li>
                        <li>May be inefficient for large state spaces</li>
                        <li>Guarantees finding solution (if complete)</li>
                    </ul>
                </div>

                <!-- BFS Section -->
                <h3><i class="fas fa-arrows-alt-h"></i>4.1 Breadth-First Search (BFS)</h3>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>Breadth-First Search (BFS)</strong> is a search algorithm that explores all nodes at the present depth level before moving on to nodes at the next depth level. It uses a FIFO (First-In-First-Out) queue data structure.</p>
                </div>

                <div class="wwwh-grid">
                    <div class="wwwh-item what">
                        <h4><i class="fas fa-question-circle"></i>WHAT is BFS?</h4>
                        <p>BFS systematically explores the search tree level by level, starting from the root and exploring all neighbors before moving to the next level. It guarantees finding the shallowest solution.</p>
                    </div>
                    <div class="wwwh-item why">
                        <h4><i class="fas fa-lightbulb"></i>WHY Use BFS?</h4>
                        <ul style="margin-left: 15px; font-size: 0.95em;">
                            <li>Guarantees shortest path (uniform cost)</li>
                            <li>Complete - finds solution if exists</li>
                            <li>Simple to implement</li>
                            <li>Good for shallow solutions</li>
                        </ul>
                    </div>
                    <div class="wwwh-item when">
                        <h4><i class="fas fa-clock"></i>WHEN to Use BFS?</h4>
                        <ul style="margin-left: 15px; font-size: 0.95em;">
                            <li>When optimal solution is needed</li>
                            <li>Solution is known to be shallow</li>
                            <li>All actions have same cost</li>
                            <li>Memory is not a constraint</li>
                        </ul>
                    </div>
                    <div class="wwwh-item how">
                        <h4><i class="fas fa-cogs"></i>HOW BFS Works?</h4>
                        <ol style="margin-left: 15px; font-size: 0.95em;">
                            <li>Add root node to queue</li>
                            <li>Remove front node from queue</li>
                            <li>If goal, return solution</li>
                            <li>Else, add all children to queue</li>
                            <li>Repeat until goal found or queue empty</li>
                        </ol>
                    </div>
                </div>

                <div class="algorithm-box">
                    <div class="algorithm-title"><i class="fas fa-code"></i> BFS Algorithm (Step-by-Step)</div>
                    <ol class="algorithm-steps">
                        <li><strong>Initialize:</strong> Create a queue and enqueue the initial state</li>
                        <li><strong>Check Empty:</strong> If queue is empty, return FAILURE (no solution)</li>
                        <li><strong>Dequeue:</strong> Remove the front node from the queue</li>
                        <li><strong>Goal Test:</strong> If current node is the goal, return SUCCESS with solution path</li>
                        <li><strong>Expand:</strong> Generate all successor nodes of current node</li>
                        <li><strong>Enqueue:</strong> Add all successors to the rear of the queue</li>
                        <li><strong>Repeat:</strong> Go to step 2</li>
                    </ol>
                </div>

                <div class="complexity-box">
                    <div class="complexity-item">
                        <div class="label">Time Complexity</div>
                        <div class="value">O(b<sup>d</sup>)</div>
                    </div>
                    <div class="complexity-item">
                        <div class="label">Space Complexity</div>
                        <div class="value">O(b<sup>d</sup>)</div>
                    </div>
                    <div class="complexity-item">
                        <div class="label">Complete?</div>
                        <div class="value" style="color: #22c55e;">Yes</div>
                    </div>
                    <div class="complexity-item">
                        <div class="label">Optimal?</div>
                        <div class="value" style="color: #22c55e;">Yes*</div>
                    </div>
                </div>
                <p style="text-align: center; font-size: 0.9em; color: #666;">*Optimal when all step costs are equal; b = branching factor, d = depth of solution</p>

                <!-- BFS Complexity Explanation -->
                <div class="simple-explanation" style="background: linear-gradient(135deg, #e0f2fe, #f0f9ff); border-left: 4px solid #0284c7; margin: 20px 0;">
                    <div class="simple-explanation-title" style="color: #0369a1;">
                        <i class="fas fa-calculator"></i> Understanding BFS Complexity (Simple Explanation)
                    </div>

                    <p><strong>What do b and d mean?</strong></p>
                    <ul style="margin: 10px 0 15px 20px;">
                        <li><strong>b (Branching Factor):</strong> How many children each node has. If every node has 3 children, b = 3.</li>
                        <li><strong>d (Depth):</strong> How many levels deep the goal is. If goal is at level 4, d = 4.</li>
                    </ul>

                    <p><strong>Time Complexity O(b<sup>d</sup>) - Why?</strong></p>
                    <div style="background: white; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p>BFS visits ALL nodes level by level until it finds the goal. Let's count how many nodes are at each level:</p>
                        <table style="width: 100%; margin: 10px 0; text-align: center;">
                            <tr style="background: #e0f2fe;">
                                <th style="padding: 8px;">Level</th>
                                <th style="padding: 8px;">Nodes at this level</th>
                                <th style="padding: 8px;">Example (b=2)</th>
                            </tr>
                            <tr><td style="padding: 8px; border: 1px solid #ddd;">0 (Root)</td><td style="padding: 8px; border: 1px solid #ddd;">1</td><td style="padding: 8px; border: 1px solid #ddd;">1</td></tr>
                            <tr><td style="padding: 8px; border: 1px solid #ddd;">1</td><td style="padding: 8px; border: 1px solid #ddd;">b</td><td style="padding: 8px; border: 1px solid #ddd;">2</td></tr>
                            <tr><td style="padding: 8px; border: 1px solid #ddd;">2</td><td style="padding: 8px; border: 1px solid #ddd;">b  b = b</td><td style="padding: 8px; border: 1px solid #ddd;">4</td></tr>
                            <tr><td style="padding: 8px; border: 1px solid #ddd;">3</td><td style="padding: 8px; border: 1px solid #ddd;">b  b  b = b</td><td style="padding: 8px; border: 1px solid #ddd;">8</td></tr>
                            <tr style="background: #fef3c7;"><td style="padding: 8px; border: 1px solid #ddd;">d</td><td style="padding: 8px; border: 1px solid #ddd;">b<sup>d</sup></td><td style="padding: 8px; border: 1px solid #ddd;">2<sup>d</sup></td></tr>
                        </table>
                        <p style="margin-top: 10px;"><strong>Total nodes = 1 + b + b + b + ... + b<sup>d</sup>  O(b<sup>d</sup>)</strong></p>
                        <p style="color: #666; font-size: 0.9em;">The largest term b<sup>d</sup> dominates, so we write O(b<sup>d</sup>)</p>
                    </div>

                    <p><strong>Space Complexity O(b<sup>d</sup>) - Why?</strong></p>
                    <div style="background: white; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p>BFS stores all nodes at the current level in the queue (frontier).</p>
                        <p style="margin-top: 10px;">At level d, there are <strong>b<sup>d</sup> nodes</strong> in the queue waiting to be explored.</p>
                        <p style="margin-top: 10px;"><strong>Example:</strong> If b=10 and d=6:</p>
                        <ul style="margin-left: 20px;">
                            <li>Level 6 has 10<sup>6</sup> = <strong>1,000,000 nodes</strong> in memory!</li>
                            <li>If each node is 1KB, that's <strong>1 GB of RAM</strong> just for the frontier.</li>
                        </ul>
                        <p style="margin-top: 10px; color: #dc2626;"><strong>This is why BFS has a memory problem!</strong></p>
                    </div>

                    <p><strong>Real Numbers Example:</strong></p>
                    <div style="background: #fef3c7; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p>If branching factor b = 10 and depth d = 10:</p>
                        <p style="margin: 5px 0;"><strong>Time:</strong> 10<sup>10</sup> = 10,000,000,000 nodes to visit!</p>
                        <p style="margin: 5px 0;"><strong>Space:</strong> 10<sup>10</sup> nodes in memory at worst!</p>
                        <p style="margin-top: 10px; color: #b45309;">At 10,000 nodes/second, this takes <strong>~11.5 days</strong> to complete!</p>
                    </div>
                </div>

                <div class="example-box student">
                    <div class="example-title">
                        <i class="fas fa-user-graduate"></i>Student Example: Finding a Book in Library
                        <span class="example-level student">STUDENT</span>
                    </div>
                    <p>Imagine searching for a book in a library with multiple floors and sections:</p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><strong>BFS Approach:</strong> Check ALL books on Floor 1, then ALL books on Floor 2, then Floor 3...</li>
                        <li>You won't miss any section because you explore completely level by level</li>
                        <li>If the book is on Floor 2, you'll find it after checking all of Floor 1</li>
                    </ul>
                </div>

                <div class="example-box realworld">
                    <div class="example-title">
                        <i class="fas fa-globe"></i>Real-World Example: Social Network Friend Finder
                        <span class="example-level realworld">REAL-WORLD</span>
                    </div>
                    <p>Finding degrees of separation on Facebook/LinkedIn:</p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li>Start with your profile</li>
                        <li>Level 1: Check all your direct friends</li>
                        <li>Level 2: Check all friends of friends</li>
                        <li>Level 3: Check all friends of friends of friends</li>
                        <li>This finds the shortest connection path</li>
                    </ul>
                </div>

                <div class="example-box industry">
                    <div class="example-title">
                        <i class="fas fa-building"></i>Industry Application: Web Crawlers
                        <span class="example-level industry">INDUSTRY</span>
                    </div>
                    <p><strong>Google/Bing Search Engines:</strong></p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li>Start from seed URLs</li>
                        <li>BFS explores pages level by level</li>
                        <li>First indexes direct links, then links from those pages</li>
                        <li>Ensures important pages (closer to root) are indexed first</li>
                        <li>Used for site mapping and link structure analysis</li>
                    </ul>
                </div>

                <!-- BFS Visual Animation -->
                <div class="visualization-box" style="background: linear-gradient(135deg, #eff6ff, #dbeafe); border-radius: 15px; padding: 25px; margin: 25px 0; border: 2px solid #3b82f6;">
                    <h4 style="color: #1d4ed8; margin-bottom: 20px;"><i class="fas fa-play-circle"></i> BFS Visualization - Watch It In Action!</h4>

                    <!-- Animated GIF/Video -->
                    <div style="text-align: center; margin-bottom: 25px;">
                        <img src="assets/videos/bfs_search.gif" alt="BFS Animation" style="max-width: 100%; height: auto; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                        <p style="color: #1e40af; margin-top: 10px; font-style: italic;">Animation showing BFS exploring level by level</p>
                    </div>

                    <!-- Step-by-step Images -->
                    <h5 style="color: #1d4ed8; margin: 20px 0 15px 0;"><i class="fas fa-images"></i> Step-by-Step Visualization</h5>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px;">
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/bfs_step_0.png" alt="BFS Step 0" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #1e40af; margin-top: 8px;"><strong>Step 0:</strong> Initial State</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/bfs_step_1.png" alt="BFS Step 1" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #1e40af; margin-top: 8px;"><strong>Step 1:</strong> Expand Root</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/bfs_step_2.png" alt="BFS Step 2" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #1e40af; margin-top: 8px;"><strong>Step 2:</strong> Level 1 - Node 1</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/bfs_step_3.png" alt="BFS Step 3" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #1e40af; margin-top: 8px;"><strong>Step 3:</strong> Level 1 - Node 2</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/bfs_step_4.png" alt="BFS Step 4" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #1e40af; margin-top: 8px;"><strong>Step 4:</strong> Level 2 Begins</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/bfs_step_5.png" alt="BFS Step 5" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #1e40af; margin-top: 8px;"><strong>Step 5:</strong> Continue Level 2</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/bfs_step_6.png" alt="BFS Step 6" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #1e40af; margin-top: 8px;"><strong>Step 6:</strong> Level 2 Complete</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/bfs_step_7.png" alt="BFS Step 7" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #1e40af; margin-top: 8px;"><strong>Step 7:</strong> Goal Found!</p>
                        </div>
                    </div>

                    <!-- Video Player -->
                    <div style="margin-top: 25px; text-align: center;">
                        <h5 style="color: #1d4ed8; margin-bottom: 15px;"><i class="fas fa-video"></i> Full Video Explanation</h5>
                        <video controls style="max-width: 100%; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                            <source src="assets/videos/bfs_search.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                    </div>
                </div>

                <div class="pros-cons">
                    <div class="pros-box">
                        <h4><i class="fas fa-check-circle"></i> Advantages of BFS</h4>
                        <ul>
                            <li>Always finds the <strong>shortest path</strong> (fewest edges)</li>
                            <li><strong>Complete</strong> - will find solution if exists</li>
                            <li><strong>Optimal</strong> when all costs are equal</li>
                            <li>Never gets stuck in infinite loops (with graph search)</li>
                            <li>Simple and easy to implement</li>
                        </ul>
                    </div>
                    <div class="cons-box">
                        <h4><i class="fas fa-times-circle"></i> Disadvantages of BFS</h4>
                        <ul>
                            <li><strong>High memory usage</strong> - stores all nodes at current level</li>
                            <li>Slow for deep solutions</li>
                            <li>Exponential time and space complexity</li>
                            <li>Not suitable for infinite state spaces</li>
                            <li>Doesn't use any domain knowledge</li>
                        </ul>
                    </div>
                </div>

                <!-- DFS Section -->
                <h3><i class="fas fa-arrow-down"></i>4.2 Depth-First Search (DFS)</h3>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>Depth-First Search (DFS)</strong> is a search algorithm that explores as far as possible along each branch before backtracking. It uses a LIFO (Last-In-First-Out) stack data structure (or recursion).</p>
                </div>

                <div class="wwwh-grid">
                    <div class="wwwh-item what">
                        <h4><i class="fas fa-question-circle"></i>WHAT is DFS?</h4>
                        <p>DFS dives deep into one path until it reaches a dead-end or goal, then backtracks to explore other paths. It explores the deepest nodes first before exploring sibling nodes.</p>
                    </div>
                    <div class="wwwh-item why">
                        <h4><i class="fas fa-lightbulb"></i>WHY Use DFS?</h4>
                        <ul style="margin-left: 15px; font-size: 0.95em;">
                            <li>Very low memory usage - O(bm)</li>
                            <li>Good for deep solutions</li>
                            <li>Simple recursive implementation</li>
                            <li>Fast when solution is deep</li>
                        </ul>
                    </div>
                    <div class="wwwh-item when">
                        <h4><i class="fas fa-clock"></i>WHEN to Use DFS?</h4>
                        <ul style="margin-left: 15px; font-size: 0.95em;">
                            <li>Memory is limited</li>
                            <li>Solutions are deep in the tree</li>
                            <li>Many solutions exist at various depths</li>
                            <li>Optimality is not required</li>
                        </ul>
                    </div>
                    <div class="wwwh-item how">
                        <h4><i class="fas fa-cogs"></i>HOW DFS Works?</h4>
                        <ol style="margin-left: 15px; font-size: 0.95em;">
                            <li>Push root node to stack</li>
                            <li>Pop top node from stack</li>
                            <li>If goal, return solution</li>
                            <li>Else, push all children to stack</li>
                            <li>Repeat until goal found or stack empty</li>
                        </ol>
                    </div>
                </div>

                <div class="algorithm-box">
                    <div class="algorithm-title"><i class="fas fa-code"></i> DFS Algorithm (Step-by-Step)</div>
                    <ol class="algorithm-steps">
                        <li><strong>Initialize:</strong> Create a stack and push the initial state</li>
                        <li><strong>Check Empty:</strong> If stack is empty, return FAILURE</li>
                        <li><strong>Pop:</strong> Remove the top node from the stack</li>
                        <li><strong>Goal Test:</strong> If current node is the goal, return SUCCESS</li>
                        <li><strong>Expand:</strong> Generate all successor nodes of current node</li>
                        <li><strong>Push:</strong> Add all successors to the top of the stack</li>
                        <li><strong>Repeat:</strong> Go to step 2</li>
                    </ol>
                </div>

                <div class="complexity-box">
                    <div class="complexity-item">
                        <div class="label">Time Complexity</div>
                        <div class="value">O(b<sup>m</sup>)</div>
                    </div>
                    <div class="complexity-item">
                        <div class="label">Space Complexity</div>
                        <div class="value">O(bm)</div>
                    </div>
                    <div class="complexity-item">
                        <div class="label">Complete?</div>
                        <div class="value" style="color: #ef4444;">No*</div>
                    </div>
                    <div class="complexity-item">
                        <div class="label">Optimal?</div>
                        <div class="value" style="color: #ef4444;">No</div>
                    </div>
                </div>
                <p style="text-align: center; font-size: 0.9em; color: #666;">*Complete for finite spaces with loop detection; m = maximum depth</p>

                <!-- DFS Complexity Explanation -->
                <div class="simple-explanation" style="background: linear-gradient(135deg, #fef3c7, #fffbeb); border-left: 4px solid #d97706; margin: 20px 0;">
                    <div class="simple-explanation-title" style="color: #b45309;">
                        <i class="fas fa-calculator"></i> Understanding DFS Complexity (Simple Explanation)
                    </div>

                    <p><strong>What do b and m mean?</strong></p>
                    <ul style="margin: 10px 0 15px 20px;">
                        <li><strong>b (Branching Factor):</strong> How many children each node has.</li>
                        <li><strong>m (Maximum Depth):</strong> The deepest level in the entire tree (not just where goal is!).</li>
                    </ul>

                    <p><strong>Time Complexity O(b<sup>m</sup>) - Why?</strong></p>
                    <div style="background: white; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p>In the <strong>worst case</strong>, DFS might explore the ENTIRE tree before finding the goal.</p>
                        <p style="margin-top: 10px;">If the goal is in the rightmost branch, and DFS goes left first, it explores:</p>
                        <p style="margin: 10px 0; text-align: center; font-size: 1.1em;"><strong>Total nodes = 1 + b + b + b + ... + b<sup>m</sup>  O(b<sup>m</sup>)</strong></p>
                        <p style="color: #dc2626;"><strong>Note:</strong> This is worse than BFS's O(b<sup>d</sup>) because m (max depth) is usually much larger than d (goal depth)!</p>
                    </div>

                    <p><strong>Space Complexity O(bm) - Why? (THIS IS DFS's ADVANTAGE!)</strong></p>
                    <div style="background: white; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p>DFS only stores <strong>nodes along the current path</strong> (plus their siblings).</p>

                        <div style="text-align: center; margin: 15px 0;">
                            <pre style="display: inline-block; text-align: left; background: #f5f5f5; padding: 15px; border-radius: 8px; font-family: monospace;">
        A           Level 0 (1 node)
       /|\
      B C D         Level 1 (b nodes)
     /|\
    E F G           Level 2 (b nodes)
   /|\
  H I J             Level 3 (b nodes)
  
Currently exploring H
                            </pre>
                        </div>

                        <p><strong>What's stored in memory when at node H?</strong></p>
                        <ul style="margin: 10px 0 15px 20px;">
                            <li>Path: A  B  E  H (that's m nodes = depth)</li>
                            <li>At each level, we store siblings we haven't explored yet (at most b-1 each level)</li>
                            <li>Total  m levels  b nodes per level = <strong>O(bm)</strong></li>
                        </ul>

                        <p><strong>Comparison with BFS:</strong></p>
                        <table style="width: 100%; margin: 10px 0; text-align: center;">
                            <tr style="background: #fef3c7;">
                                <th style="padding: 8px;">Algorithm</th>
                                <th style="padding: 8px;">Space</th>
                                <th style="padding: 8px;">If b=10, m=12, d=6</th>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border: 1px solid #ddd;">BFS</td>
                                <td style="padding: 8px; border: 1px solid #ddd;">O(b<sup>d</sup>)</td>
                                <td style="padding: 8px; border: 1px solid #ddd; color: #dc2626;"><strong>10<sup>6</sup> = 1,000,000 nodes</strong></td>
                            </tr>
                            <tr style="background: #dcfce7;">
                                <td style="padding: 8px; border: 1px solid #ddd;">DFS</td>
                                <td style="padding: 8px; border: 1px solid #ddd;">O(bm)</td>
                                <td style="padding: 8px; border: 1px solid #ddd; color: #16a34a;"><strong>10  12 = 120 nodes</strong></td>
                            </tr>
                        </table>
                        <p style="margin-top: 10px; color: #16a34a;"><strong>DFS uses ~8,333 times LESS memory! This is its main advantage.</strong></p>
                    </div>

                    <p><strong>Why is DFS Not Complete?</strong></p>
                    <div style="background: #fee2e2; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p>If there's an <strong>infinite branch</strong>, DFS will keep going down forever and never find the goal, even if it's in another branch!</p>
                        <pre style="background: white; padding: 10px; border-radius: 5px; margin-top: 10px; font-family: monospace;">
    A (Start)
   / \
  B   G (Goal!)
  |
  C
  |
  D
  |
  ... (infinite)
                        </pre>
                        <p style="margin-top: 10px;">DFS goes A  B  C  D  ... forever, <strong>never reaches G!</strong></p>
                    </div>

                    <p><strong>Why is DFS Not Optimal?</strong></p>
                    <div style="background: #fef9c3; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p>DFS returns the <strong>first solution</strong> it finds, not the <strong>best</strong> one.</p>
                        <pre style="background: white; padding: 10px; border-radius: 5px; margin-top: 10px; font-family: monospace;">
    A (Start)
   / \
  B   G (Goal at depth 1 - OPTIMAL!)
  |
  C
  |
  G (Goal at depth 3)
                        </pre>
                        <p style="margin-top: 10px;">DFS goes A  B  C  G and returns path of length 3.</p>
                        <p style="color: #dc2626;"><strong>It misses the shorter path A  G of length 1!</strong></p>
                    </div>
                </div>

                <div class="example-box student">
                    <div class="example-title">
                        <i class="fas fa-user-graduate"></i>Student Example: Solving a Maze
                        <span class="example-level student">STUDENT</span>
                    </div>
                    <p>Imagine navigating through a maze:</p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><strong>DFS Approach:</strong> Keep going forward until you hit a wall</li>
                        <li>When blocked, backtrack to last junction and try another path</li>
                        <li>Like following the "right-hand rule" - always turn right, backtrack when stuck</li>
                        <li>You might find a long path even if a short one exists</li>
                    </ul>
                </div>

                <div class="example-box realworld">
                    <div class="example-title">
                        <i class="fas fa-globe"></i>Real-World Example: File System Traversal
                        <span class="example-level realworld">REAL-WORLD</span>
                    </div>
                    <p>Finding a file in folder hierarchy:</p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li>Start at root folder (C:\)</li>
                        <li>Go into first subfolder, then its subfolder, and so on</li>
                        <li>Reach deepest folder, then backtrack</li>
                        <li>Explore next sibling folder deeply</li>
                        <li>Like the "dir /s" or "find" command works</li>
                    </ul>
                </div>

                <div class="example-box industry">
                    <div class="example-title">
                        <i class="fas fa-building"></i>Industry Application: Compiler Syntax Analysis
                        <span class="example-level industry">INDUSTRY</span>
                    </div>
                    <p><strong>Parsing Source Code:</strong></p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li>Compilers use DFS to traverse Abstract Syntax Trees (AST)</li>
                        <li>Analyzes nested code structures (if-else, loops, functions)</li>
                        <li>Memory efficient for deep nesting levels</li>
                        <li>Used in GCC, LLVM, and other major compilers</li>
                    </ul>
                </div>

                <!-- DFS Visual Animation -->
                <div class="visualization-box" style="background: linear-gradient(135deg, #fef3c7, #fef9c3); border-radius: 15px; padding: 25px; margin: 25px 0; border: 2px solid #f59e0b;">
                    <h4 style="color: #b45309; margin-bottom: 20px;"><i class="fas fa-play-circle"></i> DFS Visualization - Watch It In Action!</h4>

                    <!-- Animated GIF/Video -->
                    <div style="text-align: center; margin-bottom: 25px;">
                        <img src="assets/videos/dfs_search.gif" alt="DFS Animation" style="max-width: 100%; height: auto; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                        <p style="color: #92400e; margin-top: 10px; font-style: italic;">Animation showing DFS diving deep before backtracking</p>
                    </div>

                    <!-- Step-by-step Images -->
                    <h5 style="color: #b45309; margin: 20px 0 15px 0;"><i class="fas fa-images"></i> Step-by-Step Visualization</h5>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/dfs_step_0.png" alt="DFS Step 0" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #92400e; margin-top: 8px;"><strong>Step 0:</strong> Start at Root</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/dfs_step_1.png" alt="DFS Step 1" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #92400e; margin-top: 8px;"><strong>Step 1:</strong> Go Deep Left</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/dfs_step_2.png" alt="DFS Step 2" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #92400e; margin-top: 8px;"><strong>Step 2:</strong> Continue Deeper</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/dfs_step_3.png" alt="DFS Step 3" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #92400e; margin-top: 8px;"><strong>Step 3:</strong> Dead End - Backtrack</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/dfs_step_4.png" alt="DFS Step 4" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #92400e; margin-top: 8px;"><strong>Step 4:</strong> Try Next Branch</p>
                        </div>
                    </div>

                    <!-- Video Player -->
                    <div style="margin-top: 25px; text-align: center;">
                        <h5 style="color: #b45309; margin-bottom: 15px;"><i class="fas fa-video"></i> Full Video Explanation</h5>
                        <video controls style="max-width: 100%; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                            <source src="assets/videos/dfs_search.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                    </div>
                </div>

                <div class="pros-cons">
                    <div class="pros-box">
                        <h4><i class="fas fa-check-circle"></i> Advantages of DFS</h4>
                        <ul>
                            <li><strong>Low memory requirement</strong> - O(bm)</li>
                            <li>Works well when solution is deep</li>
                            <li>Easy recursive implementation</li>
                            <li>Can find a solution without exploring all states</li>
                            <li>Good for game trees and puzzles</li>
                        </ul>
                    </div>
                    <div class="cons-box">
                        <h4><i class="fas fa-times-circle"></i> Disadvantages of DFS</h4>
                        <ul>
                            <li><strong>Not complete</strong> - can get stuck in infinite paths</li>
                            <li><strong>Not optimal</strong> - may find longer solution first</li>
                            <li>Can go very deep unnecessarily</li>
                            <li>May explore same state multiple times</li>
                            <li>Not suitable for infinite state spaces</li>
                        </ul>
                    </div>
                </div>

                <!-- BFS vs DFS Comparison -->
                <h3><i class="fas fa-balance-scale"></i>BFS vs DFS: Comprehensive Comparison</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>BFS</th>
                            <th>DFS</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Data Structure</strong></td>
                            <td>Queue (FIFO)</td>
                            <td>Stack (LIFO)</td>
                        </tr>
                        <tr>
                            <td><strong>Exploration</strong></td>
                            <td>Level by level (horizontal)</td>
                            <td>Path by path (vertical)</td>
                        </tr>
                        <tr>
                            <td><strong>Time Complexity</strong></td>
                            <td>O(b<sup>d</sup>)</td>
                            <td>O(b<sup>m</sup>)</td>
                        </tr>
                        <tr>
                            <td><strong>Space Complexity</strong></td>
                            <td>O(b<sup>d</sup>) - High</td>
                            <td>O(bm) - Low</td>
                        </tr>
                        <tr>
                            <td><strong>Completeness</strong></td>
                            <td>Yes (finite branching)</td>
                            <td>No (can loop infinitely)</td>
                        </tr>
                        <tr>
                            <td><strong>Optimality</strong></td>
                            <td>Yes (uniform cost)</td>
                            <td>No</td>
                        </tr>
                        <tr>
                            <td><strong>Best For</strong></td>
                            <td>Shortest path, shallow goals</td>
                            <td>Memory-limited, deep goals</td>
                        </tr>
                        <tr>
                            <td><strong>Worst Case</strong></td>
                            <td>Deep solutions</td>
                            <td>Shallow solutions on deep paths</td>
                        </tr>
                    </tbody>
                </table>

                <div class="analogy-box">
                    <div class="analogy-header">
                        <i class="fas fa-lightbulb"></i> Understanding Through Analogy
                    </div>
                    <div class="analogy-scenario">
                        <h5>Finding a Person in a Building</h5>
                        <p><strong>BFS:</strong> Check everyone on Ground Floor  Everyone on 1st Floor  Everyone on 2nd Floor...</p>
                        <p style="margin-top: 10px;"><strong>DFS:</strong> Go to Ground Floor Room 1  Check basement under Room 1  Back to Room 1  Go to storage behind Room 1  Back to Ground Floor Room 2...</p>
                        <p style="margin-top: 15px;"><em>BFS guarantees finding the nearest person; DFS might find someone in the basement first even if there's someone right next door!</em></p>
                    </div>
                </div>

                <!-- Exam Questions -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-pen"></i> Important Exam Questions - Blind Search</div>

                    <div style="margin-bottom: 30px;">
                        <span class="marks-badge four">4 MARKS</span>
                        <p><strong>Q1. What is Blind Search? List its characteristics.</strong></p>
                        <div style="background: #f0fdf4; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #22c55e;">
                            <h5 style="color: #166534; margin-bottom: 15px;"><i class="fas fa-check-circle"></i> Model Answer:</h5>

                            <p><strong>Blind Search (Uninformed Search):</strong></p>
                            <p style="margin: 10px 0 15px 15px;">Blind Search refers to search strategies that have no additional information about states beyond the problem definition. They can only generate successors and distinguish goal states from non-goal states, without knowing which non-goal state is closer to the goal.</p>

                            <p><strong>Characteristics of Blind Search:</strong></p>
                            <ol style="margin-left: 25px;">
                                <li style="margin: 6px 0;"><strong>No Domain Knowledge:</strong> Does not use problem-specific information to guide search</li>
                                <li style="margin: 6px 0;"><strong>Systematic Exploration:</strong> Explores state space in a fixed, predetermined order</li>
                                <li style="margin: 6px 0;"><strong>Cannot Estimate Distance:</strong> Has no way to judge how far current state is from goal</li>
                                <li style="margin: 6px 0;"><strong>Fixed Successor Order:</strong> Generates successors without any prioritization</li>
                                <li style="margin: 6px 0;"><strong>Complete (usually):</strong> Guarantees finding solution if one exists in finite spaces</li>
                            </ol>
                            <p style="margin-top: 10px;"><strong>Examples:</strong> BFS, DFS, Uniform Cost Search, Iterative Deepening DFS</p>
                        </div>
                    </div>

                    <div style="margin-bottom: 30px;">
                        <span class="marks-badge four">4 MARKS</span>
                        <p><strong>Q2. Explain the BFS algorithm with its time and space complexity.</strong></p>
                        <div style="background: #f0fdf4; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #22c55e;">
                            <h5 style="color: #166534; margin-bottom: 15px;"><i class="fas fa-check-circle"></i> Model Answer:</h5>

                            <p><strong>Breadth-First Search (BFS):</strong></p>
                            <p style="margin: 10px 0;">BFS is a search algorithm that explores all nodes at current depth level before moving to nodes at the next depth level. It uses a FIFO (First-In-First-Out) Queue data structure.</p>

                            <p><strong>Algorithm Steps:</strong></p>
                            <ol style="margin-left: 25px;">
                                <li>Initialize queue with start node</li>
                                <li>Remove front node from queue</li>
                                <li>If goal, return success with solution path</li>
                                <li>Else, add all unvisited children to rear of queue</li>
                                <li>Repeat until goal found or queue empty</li>
                            </ol>

                            <p style="margin-top: 15px;"><strong>Complexity:</strong></p>
                            <ul style="margin-left: 25px;">
                                <li><strong>Time Complexity:</strong> O(b<sup>d</sup>) where b = branching factor, d = depth of solution</li>
                                <li><strong>Space Complexity:</strong> O(b<sup>d</sup>) - stores all nodes at current level</li>
                            </ul>

                            <p style="margin-top: 10px;"><strong>Properties:</strong> Complete: Yes | Optimal: Yes (when all costs equal)</p>
                        </div>
                    </div>

                    <div style="margin-bottom: 30px;">
                        <span class="marks-badge four">4 MARKS</span>
                        <p><strong>Q3. Explain the DFS algorithm. State its advantages and disadvantages.</strong></p>
                        <div style="background: #f0fdf4; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #22c55e;">
                            <h5 style="color: #166534; margin-bottom: 15px;"><i class="fas fa-check-circle"></i> Model Answer:</h5>

                            <p><strong>Depth-First Search (DFS):</strong></p>
                            <p style="margin: 10px 0;">DFS explores as far as possible along each branch before backtracking. It uses a LIFO (Last-In-First-Out) Stack data structure or recursion.</p>

                            <p><strong>Algorithm Steps:</strong></p>
                            <ol style="margin-left: 25px;">
                                <li>Push start node onto stack</li>
                                <li>Pop top node from stack</li>
                                <li>If goal, return success</li>
                                <li>Else, push all unvisited children onto stack</li>
                                <li>Repeat until goal found or stack empty</li>
                            </ol>

                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 15px;">
                                <div style="background: #dcfce7; padding: 12px; border-radius: 8px;">
                                    <strong style="color: #166534;">Advantages:</strong>
                                    <ul style="margin-left: 15px; margin-top: 5px; font-size: 0.9em;">
                                        <li>Low memory: O(bm)</li>
                                        <li>Fast for deep solutions</li>
                                        <li>Simple recursive implementation</li>
                                    </ul>
                                </div>
                                <div style="background: #fee2e2; padding: 12px; border-radius: 8px;">
                                    <strong style="color: #991b1b;">Disadvantages:</strong>
                                    <ul style="margin-left: 15px; margin-top: 5px; font-size: 0.9em;">
                                        <li>Not complete (infinite paths)</li>
                                        <li>Not optimal</li>
                                        <li>May go unnecessarily deep</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div style="margin-bottom: 30px;">
                        <span class="marks-badge eight">8 MARKS</span>
                        <p><strong>Q4. Compare and contrast BFS and DFS with respect to data structure, completeness, optimality, time complexity, and space complexity.</strong></p>
                        <div style="background: #f0fdf4; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #22c55e;">
                            <h5 style="color: #166534; margin-bottom: 15px;"><i class="fas fa-check-circle"></i> Model Answer:</h5>

                            <p><strong>Introduction:</strong> BFS and DFS are fundamental uninformed search strategies with contrasting approaches.</p>

                            <table style="width: 100%; margin: 15px 0; font-size: 0.9em;">
                                <tr style="background: #1e3a5f; color: white;">
                                    <th style="padding: 8px;">Aspect</th>
                                    <th style="padding: 8px;">BFS</th>
                                    <th style="padding: 8px;">DFS</th>
                                </tr>
                                <tr><td style="padding: 8px; border: 1px solid #ddd;"><strong>Data Structure</strong></td><td style="padding: 8px; border: 1px solid #ddd;">Queue (FIFO)</td><td style="padding: 8px; border: 1px solid #ddd;">Stack (LIFO)</td></tr>
                                <tr style="background:#f8f8f8;"><td style="padding: 8px; border: 1px solid #ddd;"><strong>Exploration</strong></td><td style="padding: 8px; border: 1px solid #ddd;">Level by level (horizontal)</td><td style="padding: 8px; border: 1px solid #ddd;">Path by path (vertical)</td></tr>
                                <tr><td style="padding: 8px; border: 1px solid #ddd;"><strong>Completeness</strong></td><td style="padding: 8px; border: 1px solid #ddd;"><span style="color:green;">Yes</span> (finite branching)</td><td style="padding: 8px; border: 1px solid #ddd;"><span style="color:red;">No</span> (can loop infinitely)</td></tr>
                                <tr style="background:#f8f8f8;"><td style="padding: 8px; border: 1px solid #ddd;"><strong>Optimality</strong></td><td style="padding: 8px; border: 1px solid #ddd;"><span style="color:green;">Yes</span> (uniform cost)</td><td style="padding: 8px; border: 1px solid #ddd;"><span style="color:red;">No</span></td></tr>
                                <tr><td style="padding: 8px; border: 1px solid #ddd;"><strong>Time Complexity</strong></td><td style="padding: 8px; border: 1px solid #ddd;">O(b<sup>d</sup>)</td><td style="padding: 8px; border: 1px solid #ddd;">O(b<sup>m</sup>)</td></tr>
                                <tr style="background:#f8f8f8;"><td style="padding: 8px; border: 1px solid #ddd;"><strong>Space Complexity</strong></td><td style="padding: 8px; border: 1px solid #ddd;">O(b<sup>d</sup>) - High</td><td style="padding: 8px; border: 1px solid #ddd;">O(bm) - Low</td></tr>
                                <tr><td style="padding: 8px; border: 1px solid #ddd;"><strong>Best For</strong></td><td style="padding: 8px; border: 1px solid #ddd;">Shortest path, shallow goals</td><td style="padding: 8px; border: 1px solid #ddd;">Memory-limited, deep goals</td></tr>
                            </table>

                            <p><strong>When to Use:</strong></p>
                            <ul style="margin-left: 25px;">
                                <li><strong>BFS:</strong> When optimal solution needed, solution is shallow, memory not constrained</li>
                                <li><strong>DFS:</strong> When memory is limited, solution is deep, any solution is acceptable</li>
                            </ul>
                        </div>
                    </div>

                    <div style="margin-bottom: 30px;">
                        <span class="marks-badge eight">8 MARKS</span>
                        <p><strong>Q5. Apply BFS and DFS to solve the following graph. Show the order of node expansion for both.</strong></p>
                        <div style="background: #f0fdf4; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #22c55e;">
                            <h5 style="color: #166534; margin-bottom: 15px;"><i class="fas fa-check-circle"></i> Model Answer:</h5>

                            <p><strong>Given Graph:</strong> (A=Start, G=Goal)</p>
                            <pre style="background: #e0e0e0; padding: 10px; border-radius: 5px; font-family: monospace;">     A
    / \
   B   C
  / \   \
 D   E   F
      \
       G</pre>

                            <p style="margin-top: 15px;"><strong>BFS Solution (using Queue):</strong></p>
                            <table style="width: 100%; margin: 10px 0; font-size: 0.85em;">
                                <tr style="background: #1e3a5f; color: white;"><th>Step</th><th>Current</th><th>Queue</th><th>Visited</th></tr>
                                <tr><td>1</td><td>A</td><td>[B, C]</td><td>{A}</td></tr>
                                <tr style="background:#f8f8f8;"><td>2</td><td>B</td><td>[C, D, E]</td><td>{A, B}</td></tr>
                                <tr><td>3</td><td>C</td><td>[D, E, F]</td><td>{A, B, C}</td></tr>
                                <tr style="background:#f8f8f8;"><td>4</td><td>D</td><td>[E, F]</td><td>{A, B, C, D}</td></tr>
                                <tr><td>5</td><td>E</td><td>[F, G]</td><td>{A, B, C, D, E}</td></tr>
                                <tr style="background:#f8f8f8;"><td>6</td><td>F</td><td>[G]</td><td>{A, B, C, D, E, F}</td></tr>
                                <tr style="background:#c8e6c9;"><td>7</td><td>G</td><td>Goal!</td><td>{A, B, C, D, E, F, G}</td></tr>
                            </table>
                            <p><strong>BFS Order:</strong> A  B  C  D  E  F  G</p>

                            <p style="margin-top: 15px;"><strong>DFS Solution (using Stack):</strong></p>
                            <table style="width: 100%; margin: 10px 0; font-size: 0.85em;">
                                <tr style="background: #1e3a5f; color: white;"><th>Step</th><th>Current</th><th>Stack</th><th>Visited</th></tr>
                                <tr><td>1</td><td>A</td><td>[C, B]</td><td>{A}</td></tr>
                                <tr style="background:#f8f8f8;"><td>2</td><td>B</td><td>[C, E, D]</td><td>{A, B}</td></tr>
                                <tr><td>3</td><td>D</td><td>[C, E]</td><td>{A, B, D}</td></tr>
                                <tr style="background:#f8f8f8;"><td>4</td><td>E</td><td>[C, G]</td><td>{A, B, D, E}</td></tr>
                                <tr style="background:#c8e6c9;"><td>5</td><td>G</td><td>Goal!</td><td>{A, B, D, E, G}</td></tr>
                            </table>
                            <p><strong>DFS Order:</strong> A  B  D  E  G</p>

                            <p style="margin-top: 10px; padding: 10px; background: #dbeafe; border-radius: 5px;"><strong>Comparison:</strong> BFS expanded 7 nodes; DFS expanded 5 nodes. Both found the same path ABEG in this case.</p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ==================== SECTION 5: INFORMED SEARCH ==================== -->
            <section id="informed">
                <h2><i class="fas fa-lightbulb"></i>5. Informed Search (Heuristic Search)</h2>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>Informed Search (Heuristic Search)</strong> uses problem-specific knowledge beyond the basic problem definition to guide the search toward the goal more efficiently. This additional knowledge is provided through a <strong>heuristic function</strong> that estimates the cost or distance from any given state to the goal.</p>
                </div>

                <h3><i class="fas fa-function"></i>5.1 Heuristic Function</h3>

                <div class="definition">
                    <p><i class="fas fa-book"></i>A <strong>Heuristic Function h(n)</strong> is an estimate of the cost of the cheapest path from the current node n to the goal state. It provides domain-specific knowledge to guide the search.</p>
                </div>

                <div class="formal-definition">
                    <p><strong>Formal Definition:</strong> h(n) = estimated cost of the cheapest path from state n to a goal state</p>
                    <ul style="margin-top: 15px; margin-left: 20px;">
                        <li>h(n)  0 for all nodes</li>
                        <li>h(goal) = 0</li>
                        <li>Lower h(n) means node appears closer to goal</li>
                    </ul>
                </div>

                <div class="wwwh-grid">
                    <div class="wwwh-item what">
                        <h4><i class="fas fa-question-circle"></i>WHAT is a Heuristic?</h4>
                        <p>A heuristic is a "rule of thumb" or educated guess that helps solve problems faster by prioritizing promising paths. It may not guarantee the best solution but significantly reduces search effort.</p>
                    </div>
                    <div class="wwwh-item why">
                        <h4><i class="fas fa-lightbulb"></i>WHY Use Heuristics?</h4>
                        <ul style="margin-left: 15px; font-size: 0.95em;">
                            <li>Reduces search space dramatically</li>
                            <li>Finds solutions faster</li>
                            <li>Makes intractable problems solvable</li>
                            <li>Mimics human problem-solving</li>
                        </ul>
                    </div>
                    <div class="wwwh-item when">
                        <h4><i class="fas fa-clock"></i>WHEN to Use Heuristics?</h4>
                        <ul style="margin-left: 15px; font-size: 0.95em;">
                            <li>Large state spaces</li>
                            <li>When domain knowledge is available</li>
                            <li>When optimal solution not critical</li>
                            <li>Time-constrained scenarios</li>
                        </ul>
                    </div>
                    <div class="wwwh-item how">
                        <h4><i class="fas fa-cogs"></i>HOW to Design Heuristics?</h4>
                        <ul style="margin-left: 15px; font-size: 0.95em;">
                            <li>Relax problem constraints</li>
                            <li>Use domain expertise</li>
                            <li>Consider goal properties</li>
                            <li>Ensure admissibility if optimal needed</li>
                        </ul>
                    </div>
                </div>

                <h4><i class="fas fa-ruler"></i>Types of Heuristics</h4>

                <table>
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Description</th>
                            <th>Property</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Admissible Heuristic</strong></td>
                            <td>Never overestimates the true cost to goal</td>
                            <td>h(n)  h*(n) always</td>
                            <td>Straight-line distance for navigation</td>
                        </tr>
                        <tr>
                            <td><strong>Consistent (Monotonic)</strong></td>
                            <td>h(n)  c(n,a,n') + h(n') for all successors</td>
                            <td>Triangle inequality</td>
                            <td>Manhattan distance for grid</td>
                        </tr>
                        <tr>
                            <td><strong>Inadmissible Heuristic</strong></td>
                            <td>May overestimate true cost</td>
                            <td>h(n) > h*(n) possible</td>
                            <td>Weighted heuristics for speed</td>
                        </tr>
                    </tbody>
                </table>

                <div class="example-box student">
                    <div class="example-title">
                        <i class="fas fa-th"></i>Common Heuristics for 8-Puzzle
                        <span class="example-level student">STUDENT</span>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-top: 15px;">
                        <div style="background: white; padding: 15px; border-radius: 8px;">
                            <h5 style="color: #4caf50;">h1: Misplaced Tiles</h5>
                            <p>Count of tiles not in goal position</p>
                            <p style="margin-top: 10px;"><strong>Example:</strong> If 5 tiles are wrong, h1 = 5</p>
                            <p style="color: #666; font-size: 0.9em;">Simple but less informative</p>
                        </div>
                        <div style="background: white; padding: 15px; border-radius: 8px;">
                            <h5 style="color: #2196f3;">h2: Manhattan Distance</h5>
                            <p>Sum of horizontal + vertical distances of each tile from goal</p>
                            <p style="margin-top: 10px;"><strong>Example:</strong> Tile 3 needs to move 2 right + 1 up = 3</p>
                            <p style="color: #666; font-size: 0.9em;">More informative, still admissible</p>
                        </div>
                    </div>
                </div>

                <!-- Hill Climbing -->
                <h3><i class="fas fa-mountain"></i>5.2 Hill Climbing Search</h3>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>Hill Climbing</strong> is a local search algorithm that continuously moves in the direction of increasing value (or decreasing cost). It's like climbing a hill in fog where you can only see your immediate surroundings and always move upward.</p>
                </div>

                <div class="mechanism-box">
                    <h4><i class="fas fa-cogs"></i> How Hill Climbing Works</h4>
                    <ol style="margin-left: 20px;">
                        <li>Start with an initial state (random or given)</li>
                        <li>Evaluate current state using heuristic function</li>
                        <li>Generate all neighbors (successor states)</li>
                        <li>Evaluate all neighbors</li>
                        <li>If best neighbor is better than current, move to it</li>
                        <li>If no neighbor is better, stop (local maximum reached)</li>
                    </ol>
                </div>

                <div class="algorithm-box">
                    <div class="algorithm-title"><i class="fas fa-code"></i> Simple Hill Climbing Algorithm</div>
                    <ol class="algorithm-steps">
                        <li><strong>Initialize:</strong> current = initial state</li>
                        <li><strong>Loop:</strong> Generate a neighbor of current</li>
                        <li><strong>Evaluate:</strong> If neighbor is better than current, current = neighbor</li>
                        <li><strong>Else:</strong> Return current (local optimum)</li>
                        <li><strong>Repeat:</strong> Continue until no improvement possible</li>
                    </ol>
                </div>

                <h4><i class="fas fa-shapes"></i>Variants of Hill Climbing</h4>

                <div class="comparison-grid">
                    <div class="comparison-card">
                        <h4>Simple Hill Climbing</h4>
                        <ul style="margin-left: 15px;">
                            <li>Examines one neighbor at a time</li>
                            <li>Moves to first better neighbor found</li>
                            <li>Fast but may miss better neighbors</li>
                        </ul>
                    </div>
                    <div class="comparison-card">
                        <h4>Steepest Ascent Hill Climbing</h4>
                        <ul style="margin-left: 15px;">
                            <li>Examines ALL neighbors</li>
                            <li>Moves to the BEST neighbor</li>
                            <li>Slower but more thorough</li>
                        </ul>
                    </div>
                    <div class="comparison-card">
                        <h4>Stochastic Hill Climbing</h4>
                        <ul style="margin-left: 15px;">
                            <li>Randomly selects among uphill moves</li>
                            <li>Probability based on steepness</li>
                            <li>Escapes some local optima</li>
                        </ul>
                    </div>
                </div>

                <h4><i class="fas fa-exclamation-triangle"></i>Problems with Hill Climbing</h4>

                <div class="warning-box">
                    <h4 style="color: #dc2626;"><i class="fas fa-exclamation-triangle"></i> Common Issues</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 15px;">
                        <div>
                            <strong>Local Maximum:</strong>
                            <p style="font-size: 0.9em;">A peak lower than the global maximum. Algorithm gets stuck here thinking it's the best.</p>
                        </div>
                        <div>
                            <strong>Plateau (Flat Local Maximum):</strong>
                            <p style="font-size: 0.9em;">A flat area where all neighbors have equal value. No direction seems better.</p>
                        </div>
                        <div>
                            <strong>Ridge:</strong>
                            <p style="font-size: 0.9em;">A narrow path where movement in any single direction goes downhill, but diagonal movement would help.</p>
                        </div>
                    </div>
                </div>

                <div class="tip-box">
                    <h4 style="color: #047857;"><i class="fas fa-lightbulb"></i> Solutions to Hill Climbing Problems</h4>
                    <ul style="margin-left: 20px; margin-top: 10px;">
                        <li><strong>Random Restart:</strong> Run multiple times from different starting points</li>
                        <li><strong>Simulated Annealing:</strong> Allow occasional downhill moves</li>
                        <li><strong>Tabu Search:</strong> Keep track of visited states to avoid cycles</li>
                        <li><strong>Sideways Moves:</strong> Allow moves to equal-value neighbors</li>
                    </ul>
                </div>

                <div class="pros-cons">
                    <div class="pros-box">
                        <h4><i class="fas fa-check-circle"></i> Advantages</h4>
                        <ul>
                            <li>Very little memory required</li>
                            <li>Can find solutions in large state spaces</li>
                            <li>Simple to implement</li>
                            <li>Fast convergence when landscape is smooth</li>
                        </ul>
                    </div>
                    <div class="cons-box">
                        <h4><i class="fas fa-times-circle"></i> Disadvantages</h4>
                        <ul>
                            <li>Gets stuck at local optima</li>
                            <li>Not complete or optimal</li>
                            <li>Depends heavily on initial state</li>
                            <li>Cannot handle ridges and plateaus well</li>
                        </ul>
                    </div>
                </div>

                <!-- Hill Climbing Visual Animation -->
                <div class="visualization-box" style="background: linear-gradient(135deg, #ecfdf5, #d1fae5); border-radius: 15px; padding: 25px; margin: 25px 0; border: 2px solid #10b981;">
                    <h4 style="color: #047857; margin-bottom: 20px;"><i class="fas fa-mountain"></i> Hill Climbing Visualization - Watch the Climb!</h4>

                    <!-- Animated GIF/Video -->
                    <div style="text-align: center; margin-bottom: 25px;">
                        <img src="assets/videos/hillclimbing.gif" alt="Hill Climbing Animation" style="max-width: 100%; height: auto; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                        <p style="color: #065f46; margin-top: 10px; font-style: italic;">Animation showing Hill Climbing ascending toward local optimum</p>
                    </div>

                    <!-- Step-by-step Images -->
                    <h5 style="color: #047857; margin: 20px 0 15px 0;"><i class="fas fa-images"></i> Step-by-Step: Climbing the Landscape</h5>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px;">
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/hillclimb_step_0.png" alt="Hill Climb Step 0" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #065f46; margin-top: 8px;"><strong>Step 0:</strong> Random Start</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/hillclimb_step_1.png" alt="Hill Climb Step 1" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #065f46; margin-top: 8px;"><strong>Step 1:</strong> Evaluate Neighbors</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/hillclimb_step_2.png" alt="Hill Climb Step 2" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #065f46; margin-top: 8px;"><strong>Step 2:</strong> Move Uphill</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/hillclimb_step_3.png" alt="Hill Climb Step 3" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #065f46; margin-top: 8px;"><strong>Step 3:</strong> Continue Climbing</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/hillclimb_step_4.png" alt="Hill Climb Step 4" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #065f46; margin-top: 8px;"><strong>Step 4:</strong> Near Peak</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/hillclimb_step_5.png" alt="Hill Climb Step 5" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #065f46; margin-top: 8px;"><strong>Step 5:</strong> Local Maximum!</p>
                        </div>
                    </div>

                    <!-- Video Player -->
                    <div style="margin-top: 25px; text-align: center;">
                        <h5 style="color: #047857; margin-bottom: 15px;"><i class="fas fa-video"></i> Full Video Explanation</h5>
                        <video controls style="max-width: 100%; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                            <source src="assets/videos/hillclimbing.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                    </div>
                </div>

                <!-- Best First Search -->
                <h3><i class="fas fa-trophy"></i>5.3 Best-First Search</h3>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>Best-First Search</strong> is a search algorithm that explores the most promising node first, as determined by an evaluation function f(n). It uses a priority queue to always expand the node with the lowest f(n) value.</p>
                </div>

                <div class="formal-definition">
                    <p><strong>Evaluation Function:</strong> f(n) = evaluation of node n</p>
                    <p style="margin-top: 10px;">The function f(n) determines the "desirability" of expanding node n. Different choices of f(n) give different search strategies:</p>
                    <ul style="margin-top: 10px; margin-left: 20px;">
                        <li><strong>f(n) = h(n):</strong> Greedy Best-First Search</li>
                        <li><strong>f(n) = g(n) + h(n):</strong> A* Search</li>
                        <li><strong>f(n) = g(n):</strong> Uniform Cost Search</li>
                    </ul>
                </div>

                <h4><i class="fas fa-bolt"></i>Greedy Best-First Search</h4>

                <div class="mechanism-box">
                    <h4><i class="fas fa-cogs"></i> How Greedy Best-First Works</h4>
                    <p>Uses f(n) = h(n), expanding the node that appears closest to the goal.</p>
                    <ol style="margin-left: 20px; margin-top: 15px;">
                        <li>Add initial node to priority queue (sorted by h(n))</li>
                        <li>Remove node with lowest h(n)</li>
                        <li>If goal, return solution</li>
                        <li>Expand node, add children to queue</li>
                        <li>Repeat until goal found or queue empty</li>
                    </ol>
                </div>

                <div class="complexity-box">
                    <div class="complexity-item">
                        <div class="label">Time Complexity</div>
                        <div class="value">O(b<sup>m</sup>)</div>
                    </div>
                    <div class="complexity-item">
                        <div class="label">Space Complexity</div>
                        <div class="value">O(b<sup>m</sup>)</div>
                    </div>
                    <div class="complexity-item">
                        <div class="label">Complete?</div>
                        <div class="value" style="color: #ef4444;">No</div>
                    </div>
                    <div class="complexity-item">
                        <div class="label">Optimal?</div>
                        <div class="value" style="color: #ef4444;">No</div>
                    </div>
                </div>

                <!-- Greedy Best-First Complexity Explanation -->
                <div class="simple-explanation" style="background: linear-gradient(135deg, #fff7ed, #ffedd5); border-left: 4px solid #f97316; margin: 20px 0;">
                    <div class="simple-explanation-title" style="color: #ea580c;">
                        <i class="fas fa-calculator"></i> Understanding Greedy Best-First Complexity
                    </div>

                    <p><strong>Time & Space: O(b<sup>m</sup>) - Why so bad?</strong></p>
                    <div style="background: white; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p>Greedy Best-First can be <strong>deceived by the heuristic!</strong></p>

                        <p style="margin-top: 10px;"><strong>Problem:</strong> It only looks at h(n) (estimated distance to goal), ignoring g(n) (cost already spent).</p>

                        <ul style="margin: 10px 0 15px 20px;">
                            <li>If heuristic is misleading, it may explore a very long, wrong path</li>
                            <li>It could go down to maximum depth m before realizing mistake</li>
                            <li>In worst case, explores all b<sup>m</sup> nodes (like DFS)</li>
                        </ul>

                        <p><strong>Example of Greedy Going Wrong:</strong></p>
                        <pre style="background: #f5f5f5; padding: 10px; border-radius: 5px; font-family: monospace; margin: 10px 0;">
Start  A (h=5)  B (h=4)  C (h=3)  D (h=2)  Dead End!
        
          Goal (h=0) was just ONE step away from Start!
                        </pre>
                        <p style="color: #dc2626;">Greedy followed the decreasing h values into a dead end!</p>
                    </div>

                    <p><strong>Why is it Not Complete?</strong></p>
                    <div style="background: #fee2e2; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p>Can get stuck in <strong>infinite loops</strong> without proper cycle checking:</p>
                        <ul style="margin: 10px 0 0 20px;">
                            <li>If A looks closer to goal, go to A</li>
                            <li>From A, if B looks closer, go to B</li>
                            <li>From B, if A looks closer again... loop forever!</li>
                        </ul>
                    </div>

                    <p><strong>Why is it Not Optimal?</strong></p>
                    <div style="background: #fef3c7; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p>Ignores path cost g(n), so may find a solution that <strong>looks close but takes long route:</strong></p>
                        <ul style="margin: 10px 0 0 20px;">
                            <li>Direct flight to city (h=100km) costs $1000</li>
                            <li>Greedy picks this because h is low</li>
                            <li>But connecting flight via hub (h=500km first leg) costs only $200 total!</li>
                        </ul>
                    </div>

                    <p><strong>When Greedy Works Well:</strong></p>
                    <p style="margin: 5px 0;">Despite limitations, Greedy is useful when:</p>
                    <ul style="margin: 5px 0 0 20px;">
                        <li>You need <strong>any solution fast</strong> (not necessarily optimal)</li>
                        <li>The heuristic is very accurate</li>
                        <li>The search space is simple without misleading paths</li>
                    </ul>
                </div>

                <div class="example-box realworld">
                    <div class="example-title">
                        <i class="fas fa-map-marker-alt"></i>Real-World Example: GPS Navigation
                        <span class="example-level realworld">REAL-WORLD</span>
                    </div>
                    <p><strong>Greedy approach:</strong> At each intersection, choose the road that points most directly toward destination.</p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li>Fast but might miss better routes</li>
                        <li>Could lead into dead ends</li>
                        <li>Doesn't consider road conditions or total distance traveled</li>
                    </ul>
                </div>

                <div class="pros-cons">
                    <div class="pros-box">
                        <h4><i class="fas fa-check-circle"></i> Advantages</h4>
                        <ul>
                            <li>Much faster than uninformed search</li>
                            <li>Uses domain knowledge effectively</li>
                            <li>Good for finding any solution quickly</li>
                        </ul>
                    </div>
                    <div class="cons-box">
                        <h4><i class="fas fa-times-circle"></i> Disadvantages</h4>
                        <ul>
                            <li>Not optimal - may find suboptimal solution</li>
                            <li>Not complete - can get stuck in loops</li>
                            <li>Depends entirely on heuristic quality</li>
                        </ul>
                    </div>
                </div>

                <!-- Exam Questions -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-pen"></i> Important Exam Questions - Informed Search</div>

                    <div style="margin-bottom: 30px;">
                        <span class="marks-badge four">4 MARKS</span>
                        <p><strong>Q1. What is a heuristic function? Explain admissible and consistent heuristics.</strong></p>
                        <div style="background: #f0fdf4; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #22c55e;">
                            <h5 style="color: #166534; margin-bottom: 15px;"><i class="fas fa-check-circle"></i> Model Answer:</h5>

                            <p><strong>Heuristic Function:</strong></p>
                            <p style="margin: 10px 0 15px 15px;">A heuristic function h(n) is an estimate of the cost from node n to the goal state. It provides problem-specific knowledge to guide search toward the goal more efficiently. Properties: h(n)  0 for all nodes, and h(goal) = 0.</p>

                            <p><strong>Admissible Heuristic:</strong></p>
                            <ul style="margin-left: 25px;">
                                <li><strong>Definition:</strong> A heuristic is admissible if it <u>never overestimates</u> the true cost to goal</li>
                                <li><strong>Condition:</strong> h(n)  h*(n) for all nodes, where h*(n) is actual cost</li>
                                <li><strong>Importance:</strong> Guarantees A* finds optimal solution</li>
                                <li><strong>Example:</strong> Straight-line distance for road navigation</li>
                            </ul>

                            <p style="margin-top: 15px;"><strong>Consistent (Monotonic) Heuristic:</strong></p>
                            <ul style="margin-left: 25px;">
                                <li><strong>Definition:</strong> Satisfies triangle inequality</li>
                                <li><strong>Condition:</strong> h(n)  c(n, a, n') + h(n') for all successors n'</li>
                                <li><strong>Meaning:</strong> Estimated cost from n  step cost + estimated cost from successor</li>
                                <li><strong>Note:</strong> Every consistent heuristic is also admissible</li>
                            </ul>
                        </div>
                    </div>

                    <div style="margin-bottom: 30px;">
                        <span class="marks-badge four">4 MARKS</span>
                        <p><strong>Q2. Explain Hill Climbing search. What are its limitations?</strong></p>
                        <div style="background: #f0fdf4; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #22c55e;">
                            <h5 style="color: #166534; margin-bottom: 15px;"><i class="fas fa-check-circle"></i> Model Answer:</h5>

                            <p><strong>Hill Climbing Search:</strong></p>
                            <p style="margin: 10px 0;">A local search algorithm that continuously moves toward increasing value. Like climbing a hill in fog - you only see immediate surroundings and always move upward.</p>

                            <p><strong>Algorithm:</strong></p>
                            <ol style="margin-left: 25px;">
                                <li>Start with initial state</li>
                                <li>Generate all neighbors</li>
                                <li>If best neighbor is better than current, move to it</li>
                                <li>Repeat until no better neighbor (local optimum)</li>
                            </ol>

                            <p style="margin-top: 15px;"><strong>Limitations:</strong></p>
                            <ol style="margin-left: 25px;">
                                <li style="margin: 6px 0;"><strong>Local Maximum:</strong> A peak lower than global maximum. Algorithm gets stuck thinking it's the best.</li>
                                <li style="margin: 6px 0;"><strong>Plateau:</strong> Flat region where all neighbors have equal value. No direction seems better.</li>
                                <li style="margin: 6px 0;"><strong>Ridge:</strong> Narrow path where any single direction goes downhill, but diagonal would help.</li>
                            </ol>

                            <p style="margin-top: 10px;"><strong>Solutions:</strong> Random restart, Simulated annealing, Sideways moves</p>
                        </div>
                    </div>

                    <div style="margin-bottom: 30px;">
                        <span class="marks-badge eight">8 MARKS</span>
                        <p><strong>Q3. Explain Best-First Search and its variants. Compare Greedy Best-First with other search strategies.</strong></p>
                        <div style="background: #f0fdf4; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #22c55e;">
                            <h5 style="color: #166534; margin-bottom: 15px;"><i class="fas fa-check-circle"></i> Model Answer:</h5>

                            <p><strong>Best-First Search:</strong></p>
                            <p style="margin: 10px 0;">A search algorithm that explores the most promising node first using an evaluation function f(n). Uses a priority queue to always expand the node with lowest f(n).</p>

                            <p><strong>Variants based on f(n):</strong></p>
                            <ul style="margin-left: 25px;">
                                <li><strong>f(n) = h(n):</strong> Greedy Best-First Search</li>
                                <li><strong>f(n) = g(n) + h(n):</strong> A* Search</li>
                                <li><strong>f(n) = g(n):</strong> Uniform Cost Search</li>
                            </ul>

                            <p style="margin-top: 15px;"><strong>Greedy Best-First Search:</strong></p>
                            <p style="margin-left: 15px;">Expands node appearing closest to goal. Fast but not optimal or complete.</p>

                            <p style="margin-top: 15px;"><strong>Comparison:</strong></p>
                            <table style="width: 100%; margin: 10px 0; font-size: 0.85em;">
                                <tr style="background: #1e3a5f; color: white;"><th>Aspect</th><th>Greedy Best-First</th><th>BFS</th><th>A*</th></tr>
                                <tr><td style="padding: 6px; border: 1px solid #ddd;">f(n)</td><td style="padding: 6px; border: 1px solid #ddd;">h(n)</td><td style="padding: 6px; border: 1px solid #ddd;">depth</td><td style="padding: 6px; border: 1px solid #ddd;">g(n)+h(n)</td></tr>
                                <tr style="background:#f8f8f8;"><td style="padding: 6px; border: 1px solid #ddd;">Complete</td><td style="padding: 6px; border: 1px solid #ddd;">No</td><td style="padding: 6px; border: 1px solid #ddd;">Yes</td><td style="padding: 6px; border: 1px solid #ddd;">Yes</td></tr>
                                <tr><td style="padding: 6px; border: 1px solid #ddd;">Optimal</td><td style="padding: 6px; border: 1px solid #ddd;">No</td><td style="padding: 6px; border: 1px solid #ddd;">Yes</td><td style="padding: 6px; border: 1px solid #ddd;">Yes</td></tr>
                                <tr style="background:#f8f8f8;"><td style="padding: 6px; border: 1px solid #ddd;">Time</td><td style="padding: 6px; border: 1px solid #ddd;">O(b<sup>m</sup>)</td><td style="padding: 6px; border: 1px solid #ddd;">O(b<sup>d</sup>)</td><td style="padding: 6px; border: 1px solid #ddd;">O(b<sup>d</sup>)</td></tr>
                            </table>
                        </div>
                    </div>

                    <div style="margin-bottom: 30px;">
                        <span class="marks-badge eight">8 MARKS</span>
                        <p><strong>Q4. Describe the different types of heuristics used in the 8-puzzle problem. Compare Manhattan distance with misplaced tiles heuristic.</strong></p>
                        <div style="background: #f0fdf4; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #22c55e;">
                            <h5 style="color: #166534; margin-bottom: 15px;"><i class="fas fa-check-circle"></i> Model Answer:</h5>

                            <p><strong>8-Puzzle:</strong> 33 board with tiles 1-8 and blank. Goal: arrange tiles in order.</p>

                            <p style="margin-top: 15px;"><strong>h1: Misplaced Tiles Heuristic</strong></p>
                            <ul style="margin-left: 25px;">
                                <li><strong>Definition:</strong> Count of tiles not in their goal position</li>
                                <li><strong>Example:</strong> If tiles 2, 5, 8 are misplaced, h1 = 3</li>
                                <li><strong>Property:</strong> Admissible (each misplaced tile needs at least 1 move)</li>
                            </ul>

                            <p style="margin-top: 15px;"><strong>h2: Manhattan Distance Heuristic</strong></p>
                            <ul style="margin-left: 25px;">
                                <li><strong>Definition:</strong> Sum of horizontal + vertical distances of each tile from goal position</li>
                                <li><strong>Example:</strong> If tile 5 needs to move 2 right + 1 up, its contribution = 3</li>
                                <li><strong>Property:</strong> Admissible (actual moves  Manhattan distance)</li>
                            </ul>

                            <p style="margin-top: 15px;"><strong>Comparison:</strong></p>
                            <table style="width: 100%; margin: 10px 0; font-size: 0.9em;">
                                <tr style="background: #1e3a5f; color: white;"><th>Aspect</th><th>Misplaced Tiles (h1)</th><th>Manhattan Distance (h2)</th></tr>
                                <tr><td style="padding: 8px; border: 1px solid #ddd;">Computation</td><td style="padding: 8px; border: 1px solid #ddd;">Simple counting</td><td style="padding: 8px; border: 1px solid #ddd;">Sum of distances</td></tr>
                                <tr style="background:#f8f8f8;"><td style="padding: 8px; border: 1px solid #ddd;">Accuracy</td><td style="padding: 8px; border: 1px solid #ddd;">Less accurate</td><td style="padding: 8px; border: 1px solid #ddd;">More accurate</td></tr>
                                <tr><td style="padding: 8px; border: 1px solid #ddd;">Nodes Expanded</td><td style="padding: 8px; border: 1px solid #ddd;">More nodes</td><td style="padding: 8px; border: 1px solid #ddd;">Fewer nodes</td></tr>
                                <tr style="background:#f8f8f8;"><td style="padding: 8px; border: 1px solid #ddd;">Dominance</td><td style="padding: 8px; border: 1px solid #ddd;">h1  h2 always</td><td style="padding: 8px; border: 1px solid #ddd;">h2 dominates h1</td></tr>
                            </table>

                            <p style="margin-top: 10px;"><strong>Conclusion:</strong> Manhattan distance is better as h2  h1 always, so h2 is more informative and expands fewer nodes while remaining admissible.</p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ==================== SECTION 6: A* AND AO* SEARCH ==================== -->
            <section id="astar">
                <h2><i class="fas fa-star"></i>6. A* and AO* Search Algorithms</h2>

                <!-- A* Search -->
                <h3><i class="fas fa-star"></i>6.1 A* Search Algorithm</h3>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>A* (A-Star) Search</strong> is the most widely-used informed search algorithm. It combines the cost to reach the node (g(n)) with the estimated cost to the goal (h(n)) to find the optimal path.</p>
                </div>

                <div class="formal-definition">
                    <p><strong>Evaluation Function:</strong> f(n) = g(n) + h(n)</p>
                    <ul style="margin-top: 15px; margin-left: 20px;">
                        <li><strong>g(n):</strong> Actual cost from start to node n (known)</li>
                        <li><strong>h(n):</strong> Estimated cost from n to goal (heuristic)</li>
                        <li><strong>f(n):</strong> Estimated total cost of path through n to goal</li>
                    </ul>
                    <p style="margin-top: 15px;"><strong>Key Property:</strong> A* is <span class="highlight">optimal and complete</span> if h(n) is admissible (never overestimates).</p>
                </div>

                <div class="wwwh-grid">
                    <div class="wwwh-item what">
                        <h4><i class="fas fa-question-circle"></i>WHAT is A*?</h4>
                        <p>A* is a best-first search that uses both path cost and heuristic estimate. It always expands the node with lowest f(n) = g(n) + h(n), balancing exploration of short paths with paths appearing close to the goal.</p>
                    </div>
                    <div class="wwwh-item why">
                        <h4><i class="fas fa-lightbulb"></i>WHY Use A*?</h4>
                        <ul style="margin-left: 15px; font-size: 0.95em;">
                            <li>Guarantees optimal solution</li>
                            <li>More efficient than blind search</li>
                            <li>Widely applicable</li>
                            <li>Well-studied and proven</li>
                        </ul>
                    </div>
                    <div class="wwwh-item when">
                        <h4><i class="fas fa-clock"></i>WHEN to Use A*?</h4>
                        <ul style="margin-left: 15px; font-size: 0.95em;">
                            <li>Path planning problems</li>
                            <li>When optimal solution required</li>
                            <li>Good heuristic available</li>
                            <li>Navigation and routing</li>
                        </ul>
                    </div>
                    <div class="wwwh-item how">
                        <h4><i class="fas fa-cogs"></i>HOW A* Works?</h4>
                        <ol style="margin-left: 15px; font-size: 0.95em;">
                            <li>Add start to OPEN list</li>
                            <li>Pick node with lowest f(n)</li>
                            <li>If goal, reconstruct path</li>
                            <li>Move to CLOSED, expand children</li>
                            <li>Update f values, repeat</li>
                        </ol>
                    </div>
                </div>

                <div class="algorithm-box">
                    <div class="algorithm-title"><i class="fas fa-code"></i> A* Algorithm (Detailed)</div>
                    <ol class="algorithm-steps">
                        <li><strong>Initialize:</strong> Create OPEN list (priority queue) with start node. Create empty CLOSED list. Set g(start) = 0, f(start) = h(start)</li>
                        <li><strong>Check OPEN:</strong> If OPEN is empty, return FAILURE</li>
                        <li><strong>Select:</strong> Remove node n with lowest f(n) from OPEN</li>
                        <li><strong>Goal Test:</strong> If n is goal, return solution path</li>
                        <li><strong>Add to CLOSED:</strong> Add n to CLOSED list</li>
                        <li><strong>Expand:</strong> For each successor s of n:
                            <ul style="margin-left: 20px; margin-top: 5px;">
                                <li>Calculate g(s) = g(n) + cost(n, s)</li>
                                <li>If s in CLOSED with lower g, skip</li>
                                <li>If s in OPEN with lower g, skip</li>
                                <li>Otherwise, set parent of s to n, calculate f(s) = g(s) + h(s), add s to OPEN</li>
                            </ul>
                        </li>
                        <li><strong>Repeat:</strong> Go to step 2</li>
                    </ol>
                </div>

                <div class="complexity-box">
                    <div class="complexity-item">
                        <div class="label">Time Complexity</div>
                        <div class="value">O(b<sup>d</sup>)</div>
                    </div>
                    <div class="complexity-item">
                        <div class="label">Space Complexity</div>
                        <div class="value">O(b<sup>d</sup>)</div>
                    </div>
                    <div class="complexity-item">
                        <div class="label">Complete?</div>
                        <div class="value" style="color: #22c55e;">Yes</div>
                    </div>
                    <div class="complexity-item">
                        <div class="label">Optimal?</div>
                        <div class="value" style="color: #22c55e;">Yes*</div>
                    </div>
                </div>
                <p style="text-align: center; font-size: 0.9em; color: #666;">*Optimal when h(n) is admissible; with consistent h(n), graph search is also optimal</p>

                <!-- A* Complexity Explanation -->
                <div class="simple-explanation" style="background: linear-gradient(135deg, #fdf4ff, #faf5ff); border-left: 4px solid #a855f7; margin: 20px 0;">
                    <div class="simple-explanation-title" style="color: #7c3aed;">
                        <i class="fas fa-calculator"></i> Understanding A* Complexity (Simple Explanation)
                    </div>

                    <p><strong>Time & Space: O(b<sup>d</sup>) - What does this mean?</strong></p>
                    <div style="background: white; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p>A* has the <strong>same worst-case complexity as BFS</strong>, but in practice it's MUCH faster!</p>

                        <p style="margin-top: 15px;"><strong>Why O(b<sup>d</sup>)?</strong></p>
                        <ul style="margin: 10px 0 15px 20px;">
                            <li>In the <strong>worst case</strong>, if heuristic h(n) = 0 for all nodes, A* becomes BFS</li>
                            <li>BFS explores all nodes up to depth d, which is 1 + b + b + ... + b<sup>d</sup>  O(b<sup>d</sup>)</li>
                            <li>A* can't do worse than this because it's guaranteed to find optimal solution</li>
                        </ul>

                        <p><strong>The Good News - Practical Performance:</strong></p>
                        <table style="width: 100%; margin: 10px 0; text-align: center;">
                            <tr style="background: #faf5ff;">
                                <th style="padding: 8px;">Heuristic Quality</th>
                                <th style="padding: 8px;">Nodes Expanded</th>
                                <th style="padding: 8px;">Effective Complexity</th>
                            </tr>
                            <tr><td style="padding: 8px; border: 1px solid #ddd;">h(n) = 0 (no heuristic)</td><td style="padding: 8px; border: 1px solid #ddd;">All nodes at each level</td><td style="padding: 8px; border: 1px solid #ddd;">O(b<sup>d</sup>) - same as BFS</td></tr>
                            <tr style="background: #f0fdf4;"><td style="padding: 8px; border: 1px solid #ddd;">Good heuristic</td><td style="padding: 8px; border: 1px solid #ddd;">Much fewer nodes</td><td style="padding: 8px; border: 1px solid #ddd;">Often O(d) or O(bd)</td></tr>
                            <tr style="background: #dcfce7;"><td style="padding: 8px; border: 1px solid #ddd;">h(n) = h*(n) (perfect!)</td><td style="padding: 8px; border: 1px solid #ddd;">Only optimal path</td><td style="padding: 8px; border: 1px solid #ddd;"><strong>O(d)</strong> - linear!</td></tr>
                        </table>
                    </div>

                    <p><strong>Why is A* Space-Expensive?</strong></p>
                    <div style="background: white; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p>A* keeps <strong>all generated nodes in memory</strong> (in OPEN and CLOSED lists):</p>
                        <ul style="margin: 10px 0 15px 20px;">
                            <li><strong>OPEN list:</strong> Nodes we've discovered but not yet explored (the frontier)</li>
                            <li><strong>CLOSED list:</strong> Nodes we've already explored (to avoid revisiting)</li>
                        </ul>
                        <p style="color: #dc2626;"><strong>Problem:</strong> For large problems, A* often runs out of memory before time!</p>
                        <p style="margin-top: 10px;"><strong>Solutions:</strong></p>
                        <ul style="margin-left: 20px;">
                            <li><strong>IDA*:</strong> Iterative Deepening A* - uses O(bd) space like DFS</li>
                            <li><strong>SMA*:</strong> Simplified Memory-Bounded A* - uses available memory</li>
                        </ul>
                    </div>

                    <p><strong>Real Example - 8-Puzzle:</strong></p>
                    <div style="background: #fef3c7; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p>8-puzzle: b  3 (average moves), typical d  22 steps for random start</p>
                        <table style="width: 100%; margin: 10px 0; text-align: center;">
                            <tr style="background: #fef3c7;"><th style="padding: 8px;">Method</th><th style="padding: 8px;">Nodes Expanded</th></tr>
                            <tr><td style="padding: 8px; border: 1px solid #ddd;">BFS</td><td style="padding: 8px; border: 1px solid #ddd; color: #dc2626;">~3<sup>22</sup>  31 billion!</td></tr>
                            <tr><td style="padding: 8px; border: 1px solid #ddd;">A* with h1 (misplaced tiles)</td><td style="padding: 8px; border: 1px solid #ddd;">~500 nodes</td></tr>
                            <tr style="background: #dcfce7;"><td style="padding: 8px; border: 1px solid #ddd;">A* with h2 (Manhattan)</td><td style="padding: 8px; border: 1px solid #ddd; color: #16a34a;"><strong>~25 nodes</strong></td></tr>
                        </table>
                        <p style="margin-top: 10px; color: #16a34a;"><strong>A* with good heuristic is over 1 BILLION times faster than BFS!</strong></p>
                    </div>
                </div>

                <div class="key-points">
                    <h4><i class="fas fa-key"></i> Key Properties of A*</h4>
                    <ul>
                        <li><strong>Optimality:</strong> A* with admissible heuristic always finds the optimal solution</li>
                        <li><strong>Optimally Efficient:</strong> No other optimal algorithm expands fewer nodes than A* (with same heuristic)</li>
                        <li><strong>f(n) values increase:</strong> Along any path, f(n) values are non-decreasing (if h is consistent)</li>
                        <li><strong>Completeness:</strong> Will find a solution if one exists (finite branching factor, positive step costs)</li>
                    </ul>
                </div>

                <div class="case-study">
                    <div class="case-study-title"><i class="fas fa-route"></i> Case Study: Route Finding (Bucharest to Arad)</div>

                    <p><strong>Problem:</strong> Find shortest path between two cities using road network.</p>

                    <div style="background: white; padding: 20px; border-radius: 8px; margin-top: 15px;">
                        <h5 style="color: #c2185b;">Step-by-Step A* Execution</h5>
                        <p>Using straight-line distance as heuristic h(n):</p>

                        <table style="margin-top: 15px; font-size: 0.9em;">
                            <tr><th>Step</th><th>Current</th><th>g(n)</th><th>h(n)</th><th>f(n)</th><th>Action</th></tr>
                            <tr><td>1</td><td>Arad</td><td>0</td><td>366</td><td>366</td><td>Start, expand</td></tr>
                            <tr><td>2</td><td>Sibiu</td><td>140</td><td>253</td><td>393</td><td>Lowest f, expand</td></tr>
                            <tr><td>3</td><td>Rimnicu</td><td>220</td><td>193</td><td>413</td><td>Lowest f, expand</td></tr>
                            <tr><td>4</td><td>Pitesti</td><td>317</td><td>98</td><td>415</td><td>Expand</td></tr>
                            <tr><td>5</td><td>Bucharest</td><td>418</td><td>0</td><td>418</td><td>Goal reached!</td></tr>
                        </table>

                        <p style="margin-top: 15px;"><strong>Optimal Path:</strong> Arad  Sibiu  Rimnicu  Pitesti  Bucharest (418 km)</p>
                    </div>
                </div>

                <div class="example-box industry">
                    <div class="example-title">
                        <i class="fas fa-building"></i>Industry Applications of A*
                        <span class="example-level industry">INDUSTRY</span>
                    </div>
                    <ul style="margin-top: 10px;">
                        <li><strong>Google Maps / GPS Navigation:</strong> Finding shortest/fastest routes between locations</li>
                        <li><strong>Video Game AI:</strong> NPC pathfinding in games like StarCraft, Age of Empires</li>
                        <li><strong>Robotics:</strong> Robot motion planning, autonomous navigation</li>
                        <li><strong>Network Routing:</strong> Finding optimal packet routes in networks</li>
                        <li><strong>Puzzle Solving:</strong> Rubik's cube solvers, sliding puzzles</li>
                    </ul>
                </div>

                <!-- A* Visual Animation -->
                <div class="visualization-box" style="background: linear-gradient(135deg, #fdf4ff, #f5d0fe); border-radius: 15px; padding: 25px; margin: 25px 0; border: 2px solid #a855f7;">
                    <h4 style="color: #7c3aed; margin-bottom: 20px;"><i class="fas fa-star"></i> A* Pathfinding Visualization - Watch It Find the Optimal Path!</h4>

                    <!-- Animated GIF/Video -->
                    <div style="text-align: center; margin-bottom: 25px;">
                        <img src="assets/videos/astar_pathfinding.gif" alt="A* Pathfinding Animation" style="max-width: 100%; height: auto; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                        <p style="color: #6b21a8; margin-top: 10px; font-style: italic;">Animation showing A* finding optimal path using f(n) = g(n) + h(n)</p>
                    </div>

                    <!-- Step-by-step Images -->
                    <h5 style="color: #7c3aed; margin: 20px 0 15px 0;"><i class="fas fa-images"></i> Step-by-Step: A* in Action</h5>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px;">
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/astar_step_0.png" alt="A* Step 0" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #6b21a8; margin-top: 8px;"><strong>Step 0:</strong> Initialize Start</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/astar_step_1.png" alt="A* Step 1" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #6b21a8; margin-top: 8px;"><strong>Step 1:</strong> Expand Neighbors</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/astar_step_2.png" alt="A* Step 2" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #6b21a8; margin-top: 8px;"><strong>Step 2:</strong> Pick Lowest f(n)</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/astar_step_3.png" alt="A* Step 3" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #6b21a8; margin-top: 8px;"><strong>Step 3:</strong> Continue Search</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/astar_step_4.png" alt="A* Step 4" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #6b21a8; margin-top: 8px;"><strong>Step 4:</strong> Approaching Goal</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/astar_step_5.png" alt="A* Step 5" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #6b21a8; margin-top: 8px;"><strong>Step 5:</strong> Near Goal</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/astar_step_6.png" alt="A* Step 6" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #6b21a8; margin-top: 8px;"><strong>Step 6:</strong> Optimal Path Found!</p>
                        </div>
                    </div>

                    <!-- Video Player -->
                    <div style="margin-top: 25px; text-align: center;">
                        <h5 style="color: #7c3aed; margin-bottom: 15px;"><i class="fas fa-video"></i> Full Video Explanation</h5>
                        <video controls style="max-width: 100%; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                            <source src="assets/videos/astar_pathfinding.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                    </div>
                </div>

                <div class="pros-cons">
                    <div class="pros-box">
                        <h4><i class="fas fa-check-circle"></i> Advantages of A*</h4>
                        <ul>
                            <li>Guaranteed optimal solution (with admissible h)</li>
                            <li>Complete - finds solution if exists</li>
                            <li>Expands minimum nodes necessary</li>
                            <li>Flexible - works with any admissible heuristic</li>
                            <li>Well-understood theoretical properties</li>
                        </ul>
                    </div>
                    <div class="cons-box">
                        <h4><i class="fas fa-times-circle"></i> Disadvantages of A*</h4>
                        <ul>
                            <li>High memory requirement - stores all nodes</li>
                            <li>Exponential space complexity</li>
                            <li>Performance depends on heuristic quality</li>
                            <li>May be slow with poor heuristic</li>
                            <li>Not suitable for very large state spaces</li>
                        </ul>
                    </div>
                </div>

                <!-- AO* Search -->
                <h3><i class="fas fa-project-diagram"></i>6.2 AO* Search Algorithm</h3>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>AO* (AND-OR Star) Search</strong> is an extension of A* for problems that can be decomposed into subproblems (AND nodes) or have alternative solutions (OR nodes). It's used for problems represented as AND-OR graphs.</p>
                </div>

                <div class="formal-definition">
                    <p><strong>AND-OR Graph:</strong></p>
                    <ul style="margin-top: 10px; margin-left: 20px;">
                        <li><strong>OR Node:</strong> Represents a choice - solving ANY one child solves the node</li>
                        <li><strong>AND Node:</strong> Represents decomposition - ALL children must be solved</li>
                        <li><strong>Leaf Nodes:</strong> Terminal states (solvable or unsolvable)</li>
                    </ul>
                </div>

                <div class="wwwh-grid">
                    <div class="wwwh-item what">
                        <h4><i class="fas fa-question-circle"></i>WHAT is AO*?</h4>
                        <p>AO* finds optimal solution graphs in AND-OR trees. Unlike A* which finds a single path, AO* finds a solution that may involve solving multiple subproblems (AND nodes) while choosing among alternatives (OR nodes).</p>
                    </div>
                    <div class="wwwh-item why">
                        <h4><i class="fas fa-lightbulb"></i>WHY Use AO*?</h4>
                        <ul style="margin-left: 15px; font-size: 0.95em;">
                            <li>Problems with subproblems</li>
                            <li>Planning with choices</li>
                            <li>Game tree analysis</li>
                            <li>Theorem proving</li>
                        </ul>
                    </div>
                    <div class="wwwh-item when">
                        <h4><i class="fas fa-clock"></i>WHEN to Use AO*?</h4>
                        <ul style="margin-left: 15px; font-size: 0.95em;">
                            <li>Problem decomposition</li>
                            <li>Multiple solutions paths</li>
                            <li>Planning under uncertainty</li>
                            <li>Expert systems</li>
                        </ul>
                    </div>
                    <div class="wwwh-item how">
                        <h4><i class="fas fa-cogs"></i>HOW AO* Works?</h4>
                        <ol style="margin-left: 15px; font-size: 0.95em;">
                            <li>Select most promising node</li>
                            <li>Expand node (AND or OR)</li>
                            <li>Update costs bottom-up</li>
                            <li>Mark solved/unsolvable nodes</li>
                            <li>Repeat until root solved</li>
                        </ol>
                    </div>
                </div>

                <div class="algorithm-box">
                    <div class="algorithm-title"><i class="fas fa-code"></i> AO* Algorithm</div>
                    <ol class="algorithm-steps">
                        <li><strong>Initialize:</strong> Create graph G with start node s, compute h(s)</li>
                        <li><strong>Terminate Check:</strong> If s is solved, return solution graph. If s is unsolvable, return failure</li>
                        <li><strong>Select:</strong> Trace the marked arcs from s and select an unexpanded node n</li>
                        <li><strong>Expand:</strong> Generate successors of n. For each successor m, compute h(m)</li>
                        <li><strong>Cost Update:</strong> Propagate costs and solved/unsolvable labels backward:
                            <ul style="margin-left: 20px; margin-top: 5px;">
                                <li>For OR node: h = min(cost of children) + arc cost</li>
                                <li>For AND node: h = sum(cost of children) + arc costs</li>
                            </ul>
                        </li>
                        <li><strong>Mark Best Path:</strong> At each OR node, mark arc to best successor</li>
                        <li><strong>Repeat:</strong> Go to step 2</li>
                    </ol>
                </div>

                <div class="example-box student">
                    <div class="example-title">
                        <i class="fas fa-user-graduate"></i>Understanding AND-OR with Example
                        <span class="example-level student">STUDENT</span>
                    </div>
                    <p><strong>Problem: Getting a Degree</strong></p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><strong>OR node (Goal):</strong> Get degree by completing EITHER Computer Science track OR Business track</li>
                        <li><strong>AND node (CS Track):</strong> Must complete Programming AND Mathematics AND Project</li>
                        <li><strong>AND node (Business Track):</strong> Must complete Economics AND Management AND Internship</li>
                    </ul>
                    <p style="margin-top: 10px;">AO* would find the cheapest way to achieve the degree by evaluating both tracks!</p>
                </div>

                <div class="example-box industry">
                    <div class="example-title">
                        <i class="fas fa-building"></i>Industry Applications of AO*
                        <span class="example-level industry">INDUSTRY</span>
                    </div>
                    <ul>
                        <li><strong>Assembly Planning:</strong> Decomposing product assembly into subtasks</li>
                        <li><strong>Medical Diagnosis:</strong> Evaluating treatment options with multiple conditions</li>
                        <li><strong>Theorem Proving:</strong> Mathematical proof systems (AND = conjunction, OR = alternatives)</li>
                        <li><strong>Configuration Systems:</strong> Product configuration with dependencies</li>
                    </ul>
                </div>

                <h3><i class="fas fa-balance-scale"></i>A* vs AO* Comparison</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>A* Search</th>
                            <th>AO* Search</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Graph Type</strong></td>
                            <td>OR graphs (single paths)</td>
                            <td>AND-OR graphs</td>
                        </tr>
                        <tr>
                            <td><strong>Solution</strong></td>
                            <td>Single optimal path</td>
                            <td>Solution graph (tree)</td>
                        </tr>
                        <tr>
                            <td><strong>Node Types</strong></td>
                            <td>Only OR nodes</td>
                            <td>Both AND and OR nodes</td>
                        </tr>
                        <tr>
                            <td><strong>Cost Calculation</strong></td>
                            <td>Sum along path</td>
                            <td>Min for OR, Sum for AND</td>
                        </tr>
                        <tr>
                            <td><strong>Use Case</strong></td>
                            <td>Pathfinding, routing</td>
                            <td>Planning, decomposition</td>
                        </tr>
                        <tr>
                            <td><strong>Complexity</strong></td>
                            <td>Simpler</td>
                            <td>More complex</td>
                        </tr>
                    </tbody>
                </table>

                <!-- Exam Questions -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-pen"></i> Important Exam Questions - A* and AO*</div>

                    <div style="margin-bottom: 30px;">
                        <span class="marks-badge four">4 MARKS</span>
                        <p><strong>Q1. Write the evaluation function of A* algorithm. When is A* optimal and complete?</strong></p>
                        <div style="background: #f0fdf4; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #22c55e;">
                            <h5 style="color: #166534; margin-bottom: 15px;"><i class="fas fa-check-circle"></i> Model Answer:</h5>

                            <p><strong>A* Evaluation Function:</strong></p>
                            <div style="background: #e0e0e0; padding: 15px; border-radius: 8px; text-align: center; margin: 10px 0; font-size: 1.2em;">
                                <strong>f(n) = g(n) + h(n)</strong>
                            </div>
                            <ul style="margin-left: 25px;">
                                <li><strong>f(n):</strong> Estimated total cost of path through node n to goal</li>
                                <li><strong>g(n):</strong> Actual cost from start to node n (known, computed)</li>
                                <li><strong>h(n):</strong> Estimated cost from node n to goal (heuristic)</li>
                            </ul>

                            <p style="margin-top: 15px;"><strong>When is A* Complete?</strong></p>
                            <ul style="margin-left: 25px;">
                                <li>Branching factor b is finite</li>
                                <li>Every action has cost   (positive constant)</li>
                            </ul>

                            <p style="margin-top: 15px;"><strong>When is A* Optimal?</strong></p>
                            <ul style="margin-left: 25px;">
                                <li>The heuristic h(n) is <strong>admissible</strong> (never overestimates)</li>
                                <li>For graph search: h(n) should also be <strong>consistent</strong></li>
                            </ul>
                        </div>
                    </div>

                    <div style="margin-bottom: 30px;">
                        <span class="marks-badge four">4 MARKS</span>
                        <p><strong>Q2. Differentiate between A* and AO* algorithms.</strong></p>
                        <div style="background: #f0fdf4; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #22c55e;">
                            <h5 style="color: #166534; margin-bottom: 15px;"><i class="fas fa-check-circle"></i> Model Answer:</h5>

                            <table style="width: 100%; margin: 10px 0; font-size: 0.9em;">
                                <tr style="background: #1e3a5f; color: white;">
                                    <th style="padding: 8px;">Aspect</th>
                                    <th style="padding: 8px;">A* Algorithm</th>
                                    <th style="padding: 8px;">AO* Algorithm</th>
                                </tr>
                                <tr><td style="padding: 8px; border: 1px solid #ddd;"><strong>Graph Type</strong></td><td style="padding: 8px; border: 1px solid #ddd;">OR graphs (single paths)</td><td style="padding: 8px; border: 1px solid #ddd;">AND-OR graphs</td></tr>
                                <tr style="background:#f8f8f8;"><td style="padding: 8px; border: 1px solid #ddd;"><strong>Node Types</strong></td><td style="padding: 8px; border: 1px solid #ddd;">Only OR nodes</td><td style="padding: 8px; border: 1px solid #ddd;">Both AND and OR nodes</td></tr>
                                <tr><td style="padding: 8px; border: 1px solid #ddd;"><strong>Solution</strong></td><td style="padding: 8px; border: 1px solid #ddd;">Single optimal path</td><td style="padding: 8px; border: 1px solid #ddd;">Solution graph (tree)</td></tr>
                                <tr style="background:#f8f8f8;"><td style="padding: 8px; border: 1px solid #ddd;"><strong>Cost Calculation</strong></td><td style="padding: 8px; border: 1px solid #ddd;">Sum along path</td><td style="padding: 8px; border: 1px solid #ddd;">Min for OR, Sum for AND</td></tr>
                                <tr><td style="padding: 8px; border: 1px solid #ddd;"><strong>Use Cases</strong></td><td style="padding: 8px; border: 1px solid #ddd;">Pathfinding, navigation</td><td style="padding: 8px; border: 1px solid #ddd;">Planning, decomposition</td></tr>
                            </table>
                        </div>
                    </div>

                    <div style="margin-bottom: 30px;">
                        <span class="marks-badge eight">8 MARKS</span>
                        <p><strong>Q3. Explain A* search algorithm with its properties. Solve a given problem using A*.</strong></p>
                        <div style="background: #f0fdf4; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #22c55e;">
                            <h5 style="color: #166534; margin-bottom: 15px;"><i class="fas fa-check-circle"></i> Model Answer:</h5>

                            <p><strong>A* Algorithm Steps:</strong></p>
                            <ol style="margin-left: 25px;">
                                <li>Initialize OPEN list with start node (f = h(start)), CLOSED = empty</li>
                                <li>While OPEN not empty: Remove node n with lowest f(n)</li>
                                <li>If n is goal, return solution path</li>
                                <li>Add n to CLOSED</li>
                                <li>For each successor s: Calculate g(s) = g(n) + cost(n,s)</li>
                                <li>If s not in OPEN/CLOSED or has better g, add/update in OPEN</li>
                                <li>Repeat until goal found or OPEN empty</li>
                            </ol>

                            <p style="margin-top: 15px;"><strong>Properties:</strong> Complete: Yes | Optimal: Yes (if h admissible) | Time: O(b<sup>d</sup>) | Space: O(b<sup>d</sup>)</p>

                            <p style="margin-top: 15px;"><strong>Example: Find shortest path S to G</strong></p>
                            <pre style="background: #e0e0e0; padding: 10px; border-radius: 5px; font-family: monospace; font-size: 0.85em;">Graph: S--3--A--2--G    h: S=5, A=2, G=0
       |     |
       4     1
       |     |
       B-----+</pre>

                            <table style="width: 100%; margin: 10px 0; font-size: 0.85em;">
                                <tr style="background: #1e3a5f; color: white;"><th>Step</th><th>OPEN (f=g+h)</th><th>Select</th><th>CLOSED</th></tr>
                                <tr><td>1</td><td>S: 0+5=5</td><td>S</td><td>{}</td></tr>
                                <tr style="background:#f8f8f8;"><td>2</td><td>A: 3+2=5, B: 4+3=7</td><td>A</td><td>{S}</td></tr>
                                <tr style="background:#c8e6c9;"><td>3</td><td>G: 5+0=5, B: 7</td><td>G</td><td>{S,A}</td></tr>
                            </table>
                            <p><strong>Optimal Path:</strong> S  A  G, Cost = 5</p>
                        </div>
                    </div>

                    <div style="margin-bottom: 30px;">
                        <span class="marks-badge eight">8 MARKS</span>
                        <p><strong>Q4. Explain AND-OR graphs and AO* algorithm with an example.</strong></p>
                        <div style="background: #f0fdf4; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #22c55e;">
                            <h5 style="color: #166534; margin-bottom: 15px;"><i class="fas fa-check-circle"></i> Model Answer:</h5>

                            <p><strong>AND-OR Graphs:</strong></p>
                            <ul style="margin-left: 25px;">
                                <li><strong>OR Node:</strong> Represents a choice - solving ANY one child solves the node</li>
                                <li><strong>AND Node:</strong> Represents decomposition - ALL children must be solved</li>
                                <li><strong>Leaf Nodes:</strong> Terminal states (solvable or unsolvable)</li>
                            </ul>

                            <p style="margin-top: 15px;"><strong>AO* Algorithm:</strong></p>
                            <ol style="margin-left: 25px;">
                                <li>Initialize graph with start node, compute h(start)</li>
                                <li>If start is solved, return solution graph</li>
                                <li>Select unexpanded node from current best solution path</li>
                                <li>Expand node, compute h for successors</li>
                                <li>Update costs: OR = min(children), AND = sum(children)</li>
                                <li>Mark best path at OR nodes; Repeat</li>
                            </ol>

                            <p style="margin-top: 15px;"><strong>Example: Passing an Exam</strong></p>
                            <pre style="background: #e0e0e0; padding: 10px; border-radius: 5px; font-family: monospace; font-size: 0.85em;">
         Pass Exam (OR)
         /           \
    Study(AND)    Cheat(cost=)
     /     \
  Read    Practice
 (cost=2)  (cost=3)</pre>

                            <p style="margin-top: 10px;"><strong>Cost Calculation:</strong></p>
                            <ul style="margin-left: 25px;">
                                <li>Study (AND): 2 + 3 = 5</li>
                                <li>Cheat:  (not viable)</li>
                                <li>Pass Exam (OR): min(5, ) = 5</li>
                            </ul>
                            <p><strong>Solution:</strong> Choose Study path, solve both Read and Practice.</p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ==================== SECTION 7: GAME TREES ==================== -->
            <section id="game">
                <h2><i class="fas fa-gamepad"></i>7. Game Trees and Evaluation Functions</h2>

                <div class="definition">
                    <p><i class="fas fa-book"></i>A <strong>Game Tree</strong> is a tree structure that represents all possible moves and countermoves in a game from the current position. Each node represents a game state, and edges represent moves. Game trees are used for adversarial search where two players have opposing goals.</p>
                </div>

                <h3><i class="fas fa-chess"></i>7.1 Understanding Game Trees</h3>

                <div class="formal-definition">
                    <p><strong>Adversarial Search:</strong> Search in multi-agent environments where agents have conflicting goals. One agent's gain is the other's loss (zero-sum games).</p>
                    <ul style="margin-top: 15px; margin-left: 20px;">
                        <li><strong>MAX player:</strong> Tries to maximize the game value (our AI)</li>
                        <li><strong>MIN player:</strong> Tries to minimize the game value (opponent)</li>
                        <li><strong>Terminal states:</strong> Game over positions with definite outcome</li>
                        <li><strong>Utility function:</strong> Assigns numeric value to terminal states</li>
                    </ul>
                </div>

                <div class="wwwh-grid">
                    <div class="wwwh-item what">
                        <h4><i class="fas fa-question-circle"></i>WHAT is a Game Tree?</h4>
                        <p>A game tree represents all possible game states starting from the current position. MAX levels alternate with MIN levels, representing turns of the two players. Leaves are terminal states with known outcomes.</p>
                    </div>
                    <div class="wwwh-item why">
                        <h4><i class="fas fa-lightbulb"></i>WHY Use Game Trees?</h4>
                        <ul style="margin-left: 15px; font-size: 0.95em;">
                            <li>Model strategic decision-making</li>
                            <li>Find optimal moves</li>
                            <li>Anticipate opponent's responses</li>
                            <li>Build game-playing AI</li>
                        </ul>
                    </div>
                    <div class="wwwh-item when">
                        <h4><i class="fas fa-clock"></i>WHEN to Use Game Trees?</h4>
                        <ul style="margin-left: 15px; font-size: 0.95em;">
                            <li>Two-player games</li>
                            <li>Zero-sum scenarios</li>
                            <li>Turn-based decisions</li>
                            <li>Perfect information games</li>
                        </ul>
                    </div>
                    <div class="wwwh-item how">
                        <h4><i class="fas fa-cogs"></i>HOW Game Trees Work?</h4>
                        <ol style="margin-left: 15px; font-size: 0.95em;">
                            <li>Start from current state</li>
                            <li>Generate all possible moves</li>
                            <li>Alternate MAX/MIN levels</li>
                            <li>Evaluate terminal states</li>
                            <li>Back-propagate values</li>
                        </ol>
                    </div>
                </div>

                <div class="mechanism-box">
                    <h4><i class="fas fa-sitemap"></i> Structure of a Game Tree</h4>
                    <ul style="margin-left: 20px;">
                        <li><strong>Root Node:</strong> Current game state (initial position)</li>
                        <li><strong>Internal Nodes:</strong> Non-terminal game states</li>
                        <li><strong>Edges:</strong> Legal moves from one state to another</li>
                        <li><strong>Leaf Nodes:</strong> Terminal states (win/lose/draw)</li>
                        <li><strong>Levels:</strong> Alternate between MAX (our turn) and MIN (opponent's turn)</li>
                        <li><strong>Branching Factor:</strong> Average number of legal moves per position</li>
                    </ul>
                </div>

                <div class="example-box student">
                    <div class="example-title">
                        <i class="fas fa-circle"></i>Student Example: Tic-Tac-Toe Game Tree
                        <span class="example-level student">STUDENT</span>
                    </div>
                    <p>Consider Tic-Tac-Toe (Noughts and Crosses):</p>
                    <ul style="margin: 10px 0 0 20px;">
                        <li><strong>Root:</strong> Empty 33 board</li>
                        <li><strong>Level 1 (MAX = X):</strong> 9 possible first moves</li>
                        <li><strong>Level 2 (MIN = O):</strong> 8 possible responses to each</li>
                        <li><strong>Terminal:</strong> Win (+1), Lose (-1), Draw (0)</li>
                        <li><strong>Total nodes:</strong> ~255,168 (but many can be pruned)</li>
                    </ul>
                </div>

                <!-- Evaluation Function -->
                <h3><i class="fas fa-calculator"></i>7.2 Evaluation Function</h3>

                <div class="definition">
                    <p><i class="fas fa-book"></i>An <strong>Evaluation Function (Utility Function or Static Evaluator)</strong> is a heuristic function that estimates the desirability of a game position when the full game tree cannot be explored. It returns a numeric score indicating how favorable the position is for MAX.</p>
                </div>

                <div class="formal-definition">
                    <p><strong>Properties of a Good Evaluation Function:</strong></p>
                    <ul style="margin-top: 10px; margin-left: 20px;">
                        <li>Returns same order for terminal states as true utility</li>
                        <li>Fast to compute (called many times)</li>
                        <li>Reflects true chances of winning</li>
                        <li>Higher value  better for MAX</li>
                        <li>Typically returns values in range [-, +] or [-1, +1]</li>
                    </ul>
                </div>

                <div class="key-points">
                    <h4><i class="fas fa-list"></i> Components of Evaluation Functions</h4>
                    <ul>
                        <li><strong>Material:</strong> Piece values (Chess: Pawn=1, Knight=3, Bishop=3, Rook=5, Queen=9)</li>
                        <li><strong>Position:</strong> Location advantages (center control, mobility)</li>
                        <li><strong>Structure:</strong> Pawn structure, king safety</li>
                        <li><strong>Tempo:</strong> Initiative, threats, development</li>
                        <li><strong>Pattern Recognition:</strong> Known winning/losing patterns</li>
                    </ul>
                </div>

                <div class="example-box realworld">
                    <div class="example-title">
                        <i class="fas fa-chess"></i>Real-World Example: Chess Evaluation
                        <span class="example-level realworld">REAL-WORLD</span>
                    </div>
                    <p><strong>Simple Chess Evaluation:</strong></p>
                    <div style="background: white; padding: 15px; border-radius: 8px; margin-top: 10px;">
                        <p>Eval = Material + Positional + King Safety + Mobility</p>
                        <p style="margin-top: 10px;">Material = (piece_value  count) for MAX - MIN</p>
                        <p style="margin-top: 10px;"><strong>Example:</strong> If MAX has Q+R and MIN has R+B:</p>
                        <p style="margin-left: 20px;">MAX material = 9 + 5 = 14</p>
                        <p style="margin-left: 20px;">MIN material = 5 + 3 = 8</p>
                        <p style="margin-left: 20px;">Material advantage = 14 - 8 = +6 (favorable for MAX)</p>
                    </div>
                </div>

                <div class="example-box industry">
                    <div class="example-title">
                        <i class="fas fa-building"></i>Industry Application: Game AI Engines
                        <span class="example-level industry">INDUSTRY</span>
                    </div>
                    <ul>
                        <li><strong>Stockfish (Chess):</strong> Uses complex evaluation with hundreds of parameters, neural network enhancement</li>
                        <li><strong>AlphaGo (Go):</strong> Neural network trained on millions of games for position evaluation</li>
                        <li><strong>Deep Blue (Historical):</strong> 8000+ features in evaluation function</li>
                        <li><strong>Commercial Games:</strong> NBA 2K, FIFA use similar concepts for AI opponents</li>
                    </ul>
                </div>

                <h3><i class="fas fa-shapes"></i>Types of Games</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Description</th>
                            <th>Examples</th>
                            <th>Algorithm</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Perfect Information</strong></td>
                            <td>Both players see complete game state</td>
                            <td>Chess, Checkers, Go</td>
                            <td>Mini-Max, Alpha-Beta</td>
                        </tr>
                        <tr>
                            <td><strong>Imperfect Information</strong></td>
                            <td>Hidden information exists</td>
                            <td>Poker, Bridge, Battleship</td>
                            <td>Expectiminimax, Monte Carlo</td>
                        </tr>
                        <tr>
                            <td><strong>Deterministic</strong></td>
                            <td>No chance elements</td>
                            <td>Chess, Tic-Tac-Toe</td>
                            <td>Mini-Max</td>
                        </tr>
                        <tr>
                            <td><strong>Stochastic</strong></td>
                            <td>Involves randomness (dice, cards)</td>
                            <td>Backgammon, Monopoly</td>
                            <td>Expectiminimax</td>
                        </tr>
                    </tbody>
                </table>

                <!-- Exam Questions -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-pen"></i> Important Exam Questions - Game Trees</div>

                    <div style="margin-bottom: 25px;">
                        <span class="marks-badge four">4 MARKS</span>
                        <p><strong>Q1. What is a game tree? Explain MAX and MIN nodes.</strong></p>
                        <div style="background: white; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #7c3aed;">
                            <h5 style="color: #5b21b6;">MODEL ANSWER:</h5>

                            <p><strong>Game Tree Definition:</strong></p>
                            <p style="margin: 10px 0;">A game tree is a tree structure that represents all possible moves and game states in a two-player game. Each node represents a game state, and edges represent possible moves that transition from one state to another.</p>

                            <p><strong>Structure of Game Tree:</strong></p>
                            <ul style="margin: 10px 0 15px 20px;">
                                <li><strong>Root Node:</strong> Initial game state</li>
                                <li><strong>Internal Nodes:</strong> Intermediate game states</li>
                                <li><strong>Leaf Nodes (Terminals):</strong> Final game states (win/lose/draw)</li>
                                <li><strong>Edges:</strong> Legal moves connecting states</li>
                            </ul>

                            <p><strong>MAX Node:</strong></p>
                            <p style="margin: 5px 0 15px 0;">MAX nodes represent positions where it's the maximizing player's turn (typically "our" player or the AI). At MAX nodes, the player chooses the move that leads to the <strong>highest</strong> utility value among all children.</p>

                            <p><strong>MIN Node:</strong></p>
                            <p style="margin: 5px 0 15px 0;">MIN nodes represent positions where it's the minimizing player's turn (opponent). At MIN nodes, the opponent chooses the move that leads to the <strong>lowest</strong> utility value, assuming optimal play.</p>

                            <p><strong>Example:</strong> In Tic-Tac-Toe, if X is MAX and O is MIN, X tries to win (maximize score: +1) while O tries to prevent X from winning (minimize score, ideally -1 for O's win).</p>
                        </div>
                    </div>

                    <div style="margin-bottom: 25px;">
                        <span class="marks-badge four">4 MARKS</span>
                        <p><strong>Q2. What is an evaluation function? What properties should it have?</strong></p>
                        <div style="background: white; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #7c3aed;">
                            <h5 style="color: #5b21b6;">MODEL ANSWER:</h5>

                            <p><strong>Definition:</strong></p>
                            <p style="margin: 10px 0;">An evaluation function (also called static evaluation function or heuristic evaluation) is a function that assigns a numerical score to a game state, estimating how favorable that position is for a player without searching to the end of the game.</p>

                            <p><strong>Purpose:</strong></p>
                            <p style="margin: 5px 0 15px 0;">Since exploring the complete game tree is often impossible (e.g., chess has ~10<sup>120</sup> possible games), evaluation functions provide estimates at intermediate positions when search must be cut off.</p>

                            <p><strong>Essential Properties:</strong></p>
                            <ol style="margin: 10px 0 15px 20px;">
                                <li><strong>Accuracy:</strong> Must correlate with actual winning chances; higher values for truly better positions</li>
                                <li><strong>Computational Efficiency:</strong> Must be fast to compute since it's called thousands of times during search</li>
                                <li><strong>Consistency:</strong> Terminal states must return true utility (win = +, loss = -, draw = 0)</li>
                                <li><strong>Good Ordering:</strong> Should rank moves correctly so better moves are evaluated first</li>
                            </ol>

                            <p><strong>Chess Example:</strong> eval(s) = (material_advantage) + (positional_factors)</p>
                            <p style="margin: 5px 0;">Material: Queen=9, Rook=5, Bishop/Knight=3, Pawn=1</p>
                            <p>Positional: Center control, king safety, piece mobility, pawn structure</p>
                        </div>
                    </div>

                    <div style="margin-bottom: 25px;">
                        <span class="marks-badge eight">8 MARKS</span>
                        <p><strong>Q3. Explain game trees with the help of Tic-Tac-Toe example. Discuss evaluation function design.</strong></p>
                        <div style="background: white; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #7c3aed;">
                            <h5 style="color: #5b21b6;">MODEL ANSWER:</h5>

                            <p><strong>1. Introduction to Game Trees:</strong></p>
                            <p style="margin: 10px 0;">A game tree is a directed graph where nodes represent game states and edges represent moves. It's used in adversarial search for two-player, turn-taking games. The tree alternates between MAX (our player) and MIN (opponent) levels.</p>

                            <p><strong>2. Tic-Tac-Toe Game Tree Structure:</strong></p>
                            <ul style="margin: 10px 0 15px 20px;">
                                <li><strong>Root:</strong> Empty 33 board (X's turn - MAX)</li>
                                <li><strong>Level 1:</strong> 9 possible positions after X's first move</li>
                                <li><strong>Level 2:</strong> O's responses (MIN nodes)</li>
                                <li><strong>Branching Factor:</strong> Starts at 9, decreases each level</li>
                                <li><strong>Maximum Depth:</strong> 9 moves (all cells filled)</li>
                                <li><strong>Total States:</strong> Approximately 5,478 unique positions</li>
                            </ul>

                            <p><strong>3. Tree Diagram (Partial):</strong></p>
                            <pre style="background: #f5f5f5; padding: 15px; border-radius: 8px; font-family: monospace; font-size: 0.9em;">
        Empty Board (MAX - X's turn)
              /    |    \
           X|__|    _|X|_   __|__|X  ... (9 children)
           (MIN)   (MIN)   (MIN)
          / | \
      XO|__|  X|O|_  ... (8 children each)
      (MAX)  (MAX)
              </pre>

                            <p><strong>4. Terminal States and Utilities:</strong></p>
                            <ul style="margin: 10px 0 15px 20px;">
                                <li><strong>X wins (3 in a row):</strong> Utility = +1</li>
                                <li><strong>O wins (3 in a row):</strong> Utility = -1</li>
                                <li><strong>Draw (board full, no winner):</strong> Utility = 0</li>
                            </ul>

                            <p><strong>5. Evaluation Function for Tic-Tac-Toe:</strong></p>
                            <p style="margin: 10px 0;">For non-terminal states, we need a heuristic evaluation:</p>
                            <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 10px 0;">
                                <p><strong>eval(state) = (X's open lines) - (O's open lines)</strong></p>
                                <p style="margin-top: 10px;">Where "open lines" = rows, columns, or diagonals where a player can still win</p>
                            </div>

                            <p><strong>6. Alternative Evaluation Function:</strong></p>
                            <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 10px 0;">
                                <p>eval(state) = 3(X two-in-a-row with empty) + 1(X one with two empties)</p>
                                <p style="margin-top: 5px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 3(O two-in-a-row with empty) - 1(O one with two empties)</p>
                            </div>

                            <p><strong>7. Key Observations:</strong></p>
                            <ul style="margin: 10px 0 15px 20px;">
                                <li>Tic-Tac-Toe is small enough to search completely (no evaluation needed)</li>
                                <li>With perfect play, the game always ends in a draw</li>
                                <li>Center and corners are strategically more valuable</li>
                                <li>Same principles scale to complex games like Chess, Go</li>
                            </ul>

                            <p><strong>8. Conclusion:</strong></p>
                            <p>Game trees provide a systematic way to analyze two-player games. Combined with evaluation functions, they enable AI to make intelligent decisions even when complete tree search is infeasible. Tic-Tac-Toe serves as an excellent learning example before tackling complex games.</p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ==================== SECTION 8: MINIMAX ALGORITHM ==================== -->
            <section id="minimax">
                <h2><i class="fas fa-chess"></i>8. Mini-Max Search Algorithm</h2>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>Mini-Max Algorithm</strong> is a decision-making algorithm used in two-player games to find the optimal move. MAX tries to maximize the score while MIN tries to minimize it. The algorithm assumes both players play optimally.</p>
                </div>

                <div class="formal-definition">
                    <p><strong>Minimax Value:</strong></p>
                    <div style="background: white; padding: 15px; border-radius: 8px; margin-top: 10px; font-family: monospace;">
                        <p>MINIMAX(s) = </p>
                        <ul style="margin-left: 30px; list-style: none;">
                            <li>UTILITY(s) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if TERMINAL(s)</li>
                            <li>max<sub>a</sub> MINIMAX(RESULT(s,a)) &nbsp;&nbsp;&nbsp; if PLAYER(s) = MAX</li>
                            <li>min<sub>a</sub> MINIMAX(RESULT(s,a)) &nbsp;&nbsp;&nbsp;&nbsp; if PLAYER(s) = MIN</li>
                        </ul>
                    </div>
                </div>

                <div class="wwwh-grid">
                    <div class="wwwh-item what">
                        <h4><i class="fas fa-question-circle"></i>WHAT is Minimax?</h4>
                        <p>Minimax is a backtracking algorithm that finds the optimal move by exploring the game tree depth-first. It assigns values to each node assuming optimal play from both sides - MAX maximizes, MIN minimizes.</p>
                    </div>
                    <div class="wwwh-item why">
                        <h4><i class="fas fa-lightbulb"></i>WHY Use Minimax?</h4>
                        <ul style="margin-left: 15px; font-size: 0.95em;">
                            <li>Guarantees optimal play</li>
                            <li>Simple and intuitive</li>
                            <li>Foundation for all game AI</li>
                            <li>Provably correct strategy</li>
                        </ul>
                    </div>
                    <div class="wwwh-item when">
                        <h4><i class="fas fa-clock"></i>WHEN to Use Minimax?</h4>
                        <ul style="margin-left: 15px; font-size: 0.95em;">
                            <li>Two-player zero-sum games</li>
                            <li>Perfect information games</li>
                            <li>Turn-based strategy</li>
                            <li>Small game trees</li>
                        </ul>
                    </div>
                    <div class="wwwh-item how">
                        <h4><i class="fas fa-cogs"></i>HOW Minimax Works?</h4>
                        <ol style="margin-left: 15px; font-size: 0.95em;">
                            <li>Generate complete game tree</li>
                            <li>Apply utility at terminals</li>
                            <li>Back up values to root</li>
                            <li>MAX picks max child value</li>
                            <li>MIN picks min child value</li>
                        </ol>
                    </div>
                </div>

                <div class="algorithm-box">
                    <div class="algorithm-title"><i class="fas fa-code"></i> Minimax Algorithm (Detailed)</div>
                    <ol class="algorithm-steps">
                        <li><strong>Base Case:</strong> If node is terminal, return its utility value</li>
                        <li><strong>MAX Node:</strong>
                            <ul style="margin-left: 20px; margin-top: 5px;">
                                <li>Initialize value = -</li>
                                <li>For each child: value = max(value, MINIMAX(child))</li>
                                <li>Return value</li>
                            </ul>
                        </li>
                        <li><strong>MIN Node:</strong>
                            <ul style="margin-left: 20px; margin-top: 5px;">
                                <li>Initialize value = +</li>
                                <li>For each child: value = min(value, MINIMAX(child))</li>
                                <li>Return value</li>
                            </ul>
                        </li>
                        <li><strong>Root Decision:</strong> At root (MAX), choose action leading to highest minimax value</li>
                    </ol>
                </div>

                <div class="complexity-box">
                    <div class="complexity-item">
                        <div class="label">Time Complexity</div>
                        <div class="value">O(b<sup>m</sup>)</div>
                    </div>
                    <div class="complexity-item">
                        <div class="label">Space Complexity</div>
                        <div class="value">O(bm)</div>
                    </div>
                    <div class="complexity-item">
                        <div class="label">Complete?</div>
                        <div class="value" style="color: #22c55e;">Yes</div>
                    </div>
                    <div class="complexity-item">
                        <div class="label">Optimal?</div>
                        <div class="value" style="color: #22c55e;">Yes*</div>
                    </div>
                </div>
                <p style="text-align: center; font-size: 0.9em; color: #666;">*Optimal against optimal opponent; b = branching factor, m = maximum depth</p>

                <!-- Minimax Complexity Explanation -->
                <div class="simple-explanation" style="background: linear-gradient(135deg, #ecfdf5, #f0fdf4); border-left: 4px solid #10b981; margin: 20px 0;">
                    <div class="simple-explanation-title" style="color: #059669;">
                        <i class="fas fa-calculator"></i> Understanding Minimax Complexity (Simple Explanation)
                    </div>

                    <p><strong>What do b and m mean in game context?</strong></p>
                    <ul style="margin: 10px 0 15px 20px;">
                        <li><strong>b (Branching Factor):</strong> Number of legal moves available at each position</li>
                        <li><strong>m (Maximum Depth):</strong> Maximum number of moves until game ends</li>
                    </ul>

                    <p><strong>Time Complexity O(b<sup>m</sup>) - Why?</strong></p>
                    <div style="background: white; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p>Minimax must explore the <strong>ENTIRE game tree</strong> to find optimal move:</p>

                        <div style="text-align: center; margin: 15px 0;">
                            <pre style="display: inline-block; text-align: left; background: #f5f5f5; padding: 15px; border-radius: 8px; font-family: monospace;">
Level 0 (Root):     1 node                    (MAX's turn)
Level 1:            b nodes                   (MIN's turn)
Level 2:            b  b = b nodes          (MAX's turn)
Level 3:            b  b  b = b nodes      (MIN's turn)
  ...
Level m:            b<sup>m</sup> nodes                  (Terminal)
                            </pre>
                        </div>

                        <p><strong>Total nodes = 1 + b + b + ... + b<sup>m</sup>  O(b<sup>m</sup>)</strong></p>

                        <p style="margin-top: 15px;"><strong>Real Game Examples:</strong></p>
                        <table style="width: 100%; margin: 10px 0; text-align: center;">
                            <tr style="background: #ecfdf5;">
                                <th style="padding: 8px;">Game</th>
                                <th style="padding: 8px;">b (moves)</th>
                                <th style="padding: 8px;">m (depth)</th>
                                <th style="padding: 8px;">b<sup>m</sup> (nodes)</th>
                            </tr>
                            <tr><td style="padding: 8px; border: 1px solid #ddd;">Tic-Tac-Toe</td><td style="padding: 8px; border: 1px solid #ddd;">~4</td><td style="padding: 8px; border: 1px solid #ddd;">9</td><td style="padding: 8px; border: 1px solid #ddd; color: #16a34a;">~250,000</td></tr>
                            <tr><td style="padding: 8px; border: 1px solid #ddd;">Checkers</td><td style="padding: 8px; border: 1px solid #ddd;">~3</td><td style="padding: 8px; border: 1px solid #ddd;">~100</td><td style="padding: 8px; border: 1px solid #ddd; color: #d97706;">~10<sup>40</sup></td></tr>
                            <tr style="background: #fef2f2;"><td style="padding: 8px; border: 1px solid #ddd;">Chess</td><td style="padding: 8px; border: 1px solid #ddd;">~35</td><td style="padding: 8px; border: 1px solid #ddd;">~100</td><td style="padding: 8px; border: 1px solid #ddd; color: #dc2626;"><strong>~10<sup>154</sup></strong></td></tr>
                            <tr style="background: #fef2f2;"><td style="padding: 8px; border: 1px solid #ddd;">Go</td><td style="padding: 8px; border: 1px solid #ddd;">~250</td><td style="padding: 8px; border: 1px solid #ddd;">~150</td><td style="padding: 8px; border: 1px solid #ddd; color: #dc2626;"><strong>~10<sup>360</sup></strong></td></tr>
                        </table>
                        <p style="margin-top: 10px; color: #dc2626;"><strong>Chess has more positions than atoms in the universe (~10<sup>80</sup>)!</strong></p>
                    </div>

                    <p><strong>Space Complexity O(bm) - Why?</strong></p>
                    <div style="background: white; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p>Minimax uses <strong>depth-first search</strong>, so it only stores:</p>
                        <ul style="margin: 10px 0 15px 20px;">
                            <li>Current path from root to current node: <strong>m nodes</strong></li>
                            <li>Siblings at each level waiting to be explored: <strong>up to b at each level</strong></li>
                            <li>Total: <strong>O(bm)</strong> - much better than storing entire tree!</li>
                        </ul>
                        <p><strong>Example (Chess):</strong> 35  100 = 3,500 nodes in memory (very manageable!)</p>
                        <p style="color: #16a34a;">Space is NOT the problem - TIME is!</p>
                    </div>

                    <p><strong>Why This is a Problem (and the Solution):</strong></p>
                    <div style="background: #fef3c7; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p>For Chess at 10<sup>6</sup> nodes/second:</p>
                        <p style="margin: 5px 0;">Time needed: 10<sup>154</sup> / 10<sup>6</sup> = 10<sup>148</sup> seconds</p>
                        <p style="margin: 5px 0;">That's <strong>10<sup>140</sup> years!</strong> (Universe is only ~10<sup>10</sup> years old)</p>

                        <p style="margin-top: 15px;"><strong>Solutions:</strong></p>
                        <ol style="margin-left: 20px;">
                            <li><strong>Alpha-Beta Pruning:</strong> Reduces to O(b<sup>m/2</sup>) in best case - can go twice as deep!</li>
                            <li><strong>Depth-Limited Search:</strong> Only search to depth d, use evaluation function</li>
                            <li><strong>Move Ordering:</strong> Examine best moves first for more pruning</li>
                        </ol>
                    </div>
                </div>

                <div class="walkthrough-box">
                    <div class="walkthrough-header">
                        <i class="fas fa-shoe-prints"></i> Step-by-Step Minimax Example
                    </div>

                    <p style="margin-bottom: 20px;">Consider this game tree (numbers at leaves are utility values):</p>

                    <div class="step">
                        <div class="step-number">1</div>
                        <h5>Given Game Tree</h5>
                        <pre style="background: #f0f0f0; padding: 15px; border-radius: 8px; font-family: monospace;">
                MAX (Root)
               /    \
            MIN      MIN
           / \      / \
          3   5    2   9
                        </pre>
                    </div>

                    <div class="step">
                        <div class="step-number">2</div>
                        <h5>Evaluate Terminal Nodes</h5>
                        <p>Leaf values are: 3, 5, 2, 9 (these are given utilities)</p>
                    </div>

                    <div class="step">
                        <div class="step-number">3</div>
                        <h5>Calculate MIN Nodes</h5>
                        <p>Left MIN: min(3, 5) = <strong>3</strong></p>
                        <p>Right MIN: min(2, 9) = <strong>2</strong></p>
                    </div>

                    <div class="step">
                        <div class="step-number">4</div>
                        <h5>Calculate MAX (Root)</h5>
                        <p>MAX: max(3, 2) = <strong>3</strong></p>
                        <p><strong>Optimal move:</strong> Go LEFT (leads to value 3)</p>
                    </div>
                </div>

                <div class="case-study">
                    <div class="case-study-title"><i class="fas fa-circle"></i> Case Study: Tic-Tac-Toe with Minimax</div>

                    <p><strong>Scenario:</strong> X's turn in this position:</p>

                    <div style="background: white; padding: 20px; border-radius: 8px; margin-top: 15px;">
                        <div style="font-family: monospace; text-align: center; font-size: 1.2em;">
                            | X | O | X |<br>
                            | O | X | _ |<br>
                            | _ | O | _ |
                        </div>

                        <p style="margin-top: 15px;"><strong>Analysis:</strong></p>
                        <ul style="margin-left: 20px;">
                            <li>Three empty positions: (1,2), (2,0), (2,2)</li>
                            <li>Minimax explores all possibilities</li>
                            <li>Position (2,2) leads to guaranteed win for X</li>
                            <li>Other moves allow O to draw or have better chances</li>
                        </ul>

                        <p style="margin-top: 15px;"><strong>Optimal Move:</strong> X plays at (2,2) - bottom right corner</p>
                    </div>
                </div>

                <!-- Minimax Visual Animation -->
                <div class="visualization-box" style="background: linear-gradient(135deg, #ecfdf5, #d1fae5); border-radius: 15px; padding: 25px; margin: 25px 0; border: 2px solid #10b981;">
                    <h4 style="color: #047857; margin-bottom: 20px;"><i class="fas fa-chess"></i> Minimax Visualization - Watch MAX and MIN Battle!</h4>

                    <!-- Animated GIF/Video -->
                    <div style="text-align: center; margin-bottom: 25px;">
                        <img src="assets/videos/minimax.gif" alt="Minimax Animation" style="max-width: 100%; height: auto; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                        <p style="color: #065f46; margin-top: 10px; font-style: italic;">Animation showing Minimax propagating values from leaves to root</p>
                    </div>

                    <!-- Step-by-step Images -->
                    <h5 style="color: #047857; margin: 20px 0 15px 0;"><i class="fas fa-images"></i> Step-by-Step: Value Propagation</h5>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px;">
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/minimax_step_0.png" alt="Minimax Step 0" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #065f46; margin-top: 8px;"><strong>Step 0:</strong> Initial Tree</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/minimax_step_1.png" alt="Minimax Step 1" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #065f46; margin-top: 8px;"><strong>Step 1:</strong> Evaluate Leaves</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/minimax_step_2.png" alt="Minimax Step 2" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #065f46; margin-top: 8px;"><strong>Step 2:</strong> First MIN Node</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/minimax_step_3.png" alt="Minimax Step 3" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #065f46; margin-top: 8px;"><strong>Step 3:</strong> Second MIN Node</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/minimax_step_4.png" alt="Minimax Step 4" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #065f46; margin-top: 8px;"><strong>Step 4:</strong> More MIN Nodes</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/minimax_step_5.png" alt="Minimax Step 5" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #065f46; margin-top: 8px;"><strong>Step 5:</strong> First MAX Node</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/minimax_step_6.png" alt="Minimax Step 6" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #065f46; margin-top: 8px;"><strong>Step 6:</strong> Second MAX Node</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/minimax_step_7.png" alt="Minimax Step 7" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #065f46; margin-top: 8px;"><strong>Step 7:</strong> Root MAX - Done!</p>
                        </div>
                    </div>

                    <!-- Video Player -->
                    <div style="margin-top: 25px; text-align: center;">
                        <h5 style="color: #047857; margin-bottom: 15px;"><i class="fas fa-video"></i> Full Video Explanation</h5>
                        <video controls style="max-width: 100%; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                            <source src="assets/videos/minimax.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                    </div>
                </div>

                <div class="pros-cons">
                    <div class="pros-box">
                        <h4><i class="fas fa-check-circle"></i> Advantages</h4>
                        <ul>
                            <li>Guarantees optimal move against optimal opponent</li>
                            <li>Simple to understand and implement</li>
                            <li>Complete - always finds a solution</li>
                            <li>Foundation for advanced algorithms</li>
                        </ul>
                    </div>
                    <div class="cons-box">
                        <h4><i class="fas fa-times-circle"></i> Disadvantages</h4>
                        <ul>
                            <li>Exponential time complexity O(b<sup>m</sup>)</li>
                            <li>Impractical for complex games (Chess: b35, m100)</li>
                            <li>Assumes perfect opponent (may not be realistic)</li>
                            <li>Explores many unnecessary branches</li>
                        </ul>
                    </div>
                </div>

                <div class="warning-box">
                    <h4><i class="fas fa-exclamation-triangle"></i> Practical Limitations</h4>
                    <p>For Chess: ~35 legal moves per position, ~100 moves per game</p>
                    <p style="margin-top: 10px;">Complete tree: 35<sup>100</sup>  10<sup>154</sup> nodes - more than atoms in the observable universe!</p>
                    <p style="margin-top: 10px;"><strong>Solution:</strong> Use depth-limited search with evaluation function, plus Alpha-Beta pruning</p>
                </div>

                <!-- Exam Questions -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-pen"></i> Important Exam Questions - Minimax</div>

                    <div style="margin-bottom: 25px;">
                        <span class="marks-badge four">4 MARKS</span>
                        <p><strong>Q1. Explain the Minimax algorithm with its properties.</strong></p>
                        <div style="background: white; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #7c3aed;">
                            <h5 style="color: #5b21b6;">MODEL ANSWER:</h5>

                            <p><strong>Definition:</strong></p>
                            <p style="margin: 10px 0;">Minimax is a decision-making algorithm for two-player, zero-sum games that finds the optimal move by recursively evaluating the game tree. It assumes both players play optimally.</p>

                            <p><strong>Working Principle:</strong></p>
                            <ul style="margin: 10px 0 15px 20px;">
                                <li><strong>MAX Player:</strong> Tries to maximize the utility score (chooses maximum value among children)</li>
                                <li><strong>MIN Player:</strong> Tries to minimize the utility score (chooses minimum value among children)</li>
                                <li>Algorithm explores tree depth-first, propagates values from leaves to root</li>
                            </ul>

                            <p><strong>Minimax Value Function:</strong></p>
                            <div style="background: #f5f5f5; padding: 10px; border-radius: 5px; font-family: monospace; margin: 10px 0;">
                                MINIMAX(s) = UTILITY(s) if terminal<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= max MINIMAX(children) if MAX's turn<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= min MINIMAX(children) if MIN's turn
                            </div>

                            <p><strong>Properties:</strong></p>
                            <ul style="margin: 10px 0 15px 20px;">
                                <li><strong>Complete:</strong> Yes, if tree is finite</li>
                                <li><strong>Optimal:</strong> Yes, against an optimal opponent</li>
                                <li><strong>Time Complexity:</strong> O(b<sup>m</sup>) where b=branching factor, m=depth</li>
                                <li><strong>Space Complexity:</strong> O(bm) using depth-first exploration</li>
                            </ul>
                        </div>
                    </div>

                    <div style="margin-bottom: 25px;">
                        <span class="marks-badge eight">8 MARKS</span>
                        <p><strong>Q2. Apply the Minimax algorithm to the following game tree and find the optimal move for MAX.</strong></p>
                        <div style="background: white; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #7c3aed;">
                            <h5 style="color: #5b21b6;">MODEL ANSWER:</h5>

                            <p><strong>Given Game Tree:</strong></p>
                            <pre style="background: #f5f5f5; padding: 15px; border-radius: 8px; font-family: monospace;">
             MAX (A)
            /       \
       MIN (B)    MIN (C)
       /   \       /   \
      D     E     F     G
     /\    /\    /\    /\
    3  5  6  9  1  2  0  7
                            </pre>

                            <p><strong>Step-by-Step Solution:</strong></p>

                            <p style="margin: 10px 0;"><strong>Step 1: Evaluate Terminal Nodes</strong></p>
                            <p>Leaf values are given: 3, 5, 6, 9, 1, 2, 0, 7</p>

                            <p style="margin: 15px 0 10px 0;"><strong>Step 2: Calculate MIN Nodes at Level 2</strong></p>
                            <ul style="margin-left: 20px;">
                                <li>Node D (MIN): min(3, 5) = <strong>3</strong></li>
                                <li>Node E (MIN): min(6, 9) = <strong>6</strong></li>
                                <li>Node F (MIN): min(1, 2) = <strong>1</strong></li>
                                <li>Node G (MIN): min(0, 7) = <strong>0</strong></li>
                            </ul>

                            <p style="margin: 15px 0 10px 0;"><strong>Step 3: Calculate MAX Nodes at Level 1</strong></p>
                            <ul style="margin-left: 20px;">
                                <li>Node B (MAX): max(3, 6) = <strong>6</strong></li>
                                <li>Node C (MAX): max(1, 0) = <strong>1</strong></li>
                            </ul>

                            <p style="margin: 15px 0 10px 0;"><strong>Step 4: Calculate Root MAX Node</strong></p>
                            <ul style="margin-left: 20px;">
                                <li>Node A (MAX): max(6, 1) = <strong>6</strong></li>
                            </ul>

                            <p style="margin: 15px 0 10px 0;"><strong>Final Tree with Values:</strong></p>
                            <pre style="background: #f5f5f5; padding: 15px; border-radius: 8px; font-family: monospace;">
             MAX (A) = 6    MINIMAX VALUE
            /           \
       MIN (B)=6     MIN (C)=1
       /      \       /      \
    MAX(D)=3 MAX(E)=6 MAX(F)=1 MAX(G)=0
     /\       /\       /\       /\
    3  5     6  9     1  2     0  7
                            </pre>

                            <p><strong>Conclusion:</strong></p>
                            <p style="margin: 10px 0;">The optimal move for MAX at root is to choose the <strong>LEFT branch (towards B)</strong>, which guarantees a minimax value of <strong>6</strong>. Even though the right subtree has leaf value 7, the MIN player will never allow MAX to reach it.</p>
                        </div>
                    </div>

                    <div style="margin-bottom: 25px;">
                        <span class="marks-badge eight">8 MARKS</span>
                        <p><strong>Q3. Explain the Minimax algorithm for game playing. What are its advantages and limitations?</strong></p>
                        <div style="background: white; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #7c3aed;">
                            <h5 style="color: #5b21b6;">MODEL ANSWER:</h5>

                            <p><strong>1. Introduction:</strong></p>
                            <p style="margin: 10px 0;">Minimax is a fundamental algorithm in game theory and artificial intelligence for determining the optimal move in two-player, zero-sum, perfect information games. It was formalized by John von Neumann in 1928.</p>

                            <p><strong>2. Algorithm Description:</strong></p>
                            <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin: 10px 0;">
                                <ol style="margin-left: 20px;">
                                    <li>Generate the complete game tree from current state</li>
                                    <li>Apply utility function at terminal (leaf) nodes</li>
                                    <li>Propagate values upward using:
                                        <ul style="margin-left: 20px;">
                                            <li>MAX nodes: Choose maximum child value</li>
                                            <li>MIN nodes: Choose minimum child value</li>
                                        </ul>
                                    </li>
                                    <li>At root, select move leading to the child with highest value</li>
                                </ol>
                            </div>

                            <p><strong>3. Pseudocode:</strong></p>
                            <pre style="background: #f5f5f5; padding: 15px; border-radius: 8px; font-family: monospace; font-size: 0.9em;">
function MINIMAX(node, depth, isMaximizing):
    if depth = 0 or node is terminal:
        return evaluate(node)

    if isMaximizing:
        value = -
        for each child of node:
            value = max(value, MINIMAX(child, depth-1, false))
        return value
    else:
        value = +
        for each child of node:
            value = min(value, MINIMAX(child, depth-1, true))
        return value
                            </pre>

                            <p><strong>4. Advantages of Minimax:</strong></p>
                            <ul style="margin: 10px 0 15px 20px;">
                                <li><strong>Optimal Strategy:</strong> Guarantees the best possible outcome against an optimal opponent</li>
                                <li><strong>Complete:</strong> Will always find a solution if one exists in a finite tree</li>
                                <li><strong>Provably Correct:</strong> Based on sound mathematical game theory principles</li>
                                <li><strong>Simple Implementation:</strong> Easy to understand and code using recursion</li>
                                <li><strong>Foundation for Advanced Methods:</strong> Base for Alpha-Beta, MCTS, and other algorithms</li>
                            </ul>

                            <p><strong>5. Limitations of Minimax:</strong></p>
                            <ul style="margin: 10px 0 15px 20px;">
                                <li><strong>Exponential Time Complexity:</strong> O(b<sup>m</sup>) makes it impractical for complex games
                                    <br><span style="font-size: 0.9em; color: #666;">Chess: ~35<sup>100</sup>  10<sup>154</sup> nodes!</span></li>
                                <li><strong>Assumes Perfect Opponent:</strong> Real opponents may not play optimally, potentially missing better strategies</li>
                                <li><strong>Memory Requirements:</strong> O(bm) space for the recursive call stack</li>
                                <li><strong>No Handling of Uncertainty:</strong> Doesn't work well with games involving chance (dice, cards)</li>
                            </ul>

                            <p><strong>6. Addressing Limitations:</strong></p>
                            <ul style="margin: 10px 0 15px 20px;">
                                <li><strong>Alpha-Beta Pruning:</strong> Eliminates unnecessary branches, achieving O(b<sup>m/2</sup>) in best case</li>
                                <li><strong>Depth-Limited Search:</strong> Cut off at fixed depth, use evaluation function for non-terminal nodes</li>
                                <li><strong>Iterative Deepening:</strong> Progressively increase depth within time constraints</li>
                                <li><strong>Expectiminimax:</strong> Extension for games with chance nodes</li>
                            </ul>

                            <p><strong>7. Conclusion:</strong></p>
                            <p>Minimax forms the theoretical backbone of game-playing AI. While computationally expensive for complex games, its combination with pruning techniques and heuristic evaluation functions makes it practical for real-world applications from Chess engines to strategic decision-making systems.</p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ==================== SECTION 9: ALPHA-BETA PRUNING ==================== -->
            <section id="alphabeta">
                <h2><i class="fas fa-cut"></i>9. Alpha-Beta Pruning</h2>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>Alpha-Beta Pruning</strong> is an optimization technique for the Minimax algorithm that eliminates branches that cannot possibly influence the final decision. It maintains two values, alpha and beta, to track the best options found so far for MAX and MIN respectively.</p>
                </div>

                <div class="formal-definition">
                    <p><strong>Alpha ():</strong> Best (highest) value that MAX can guarantee at current level or above (MAX's lower bound)</p>
                    <p style="margin-top: 10px;"><strong>Beta ():</strong> Best (lowest) value that MIN can guarantee at current level or above (MIN's upper bound)</p>
                    <p style="margin-top: 15px;"><strong>Pruning Condition:</strong> Prune remaining children if    (no need to explore further)</p>
                </div>

                <div class="wwwh-grid">
                    <div class="wwwh-item what">
                        <h4><i class="fas fa-question-circle"></i>WHAT is Alpha-Beta Pruning?</h4>
                        <p>Alpha-Beta pruning cuts off branches in the game tree that won't affect the final decision. If we know a branch can't produce a better result than what we've already found, we skip it entirely.</p>
                    </div>
                    <div class="wwwh-item why">
                        <h4><i class="fas fa-lightbulb"></i>WHY Use Alpha-Beta?</h4>
                        <ul style="margin-left: 15px; font-size: 0.95em;">
                            <li>Dramatically reduces search time</li>
                            <li>Same result as full minimax</li>
                            <li>Enables deeper search</li>
                            <li>Essential for practical games</li>
                        </ul>
                    </div>
                    <div class="wwwh-item when">
                        <h4><i class="fas fa-clock"></i>WHEN Does Pruning Occur?</h4>
                        <ul style="margin-left: 15px; font-size: 0.95em;">
                            <li>At MAX node: when value  </li>
                            <li>At MIN node: when value  </li>
                            <li>When    at any node</li>
                            <li>Prune remaining siblings</li>
                        </ul>
                    </div>
                    <div class="wwwh-item how">
                        <h4><i class="fas fa-cogs"></i>HOW Alpha-Beta Works?</h4>
                        <ol style="margin-left: 15px; font-size: 0.95em;">
                            <li>Initialize  = -,  = +</li>
                            <li>Pass ,  to children</li>
                            <li>Update  at MAX,  at MIN</li>
                            <li>Prune if   </li>
                            <li>Return value normally</li>
                        </ol>
                    </div>
                </div>

                <div class="algorithm-box">
                    <div class="algorithm-title"><i class="fas fa-code"></i> Alpha-Beta Pruning Algorithm</div>
                    <ol class="algorithm-steps">
                        <li><strong>Initialize:</strong>  = - (best for MAX),  = + (best for MIN)</li>
                        <li><strong>At MAX Node:</strong>
                            <ul style="margin-left: 20px; margin-top: 5px;">
                                <li>For each child: v = alphabeta(child, , )</li>
                                <li> = max(, v)</li>
                                <li>If   : PRUNE ( cutoff) - return </li>
                            </ul>
                        </li>
                        <li><strong>At MIN Node:</strong>
                            <ul style="margin-left: 20px; margin-top: 5px;">
                                <li>For each child: v = alphabeta(child, , )</li>
                                <li> = min(, v)</li>
                                <li>If   : PRUNE ( cutoff) - return </li>
                            </ul>
                        </li>
                        <li><strong>Terminal Node:</strong> Return utility value</li>
                        <li><strong>Return:</strong>  at MAX nodes,  at MIN nodes</li>
                    </ol>
                </div>

                <div class="walkthrough-box">
                    <div class="walkthrough-header">
                        <i class="fas fa-shoe-prints"></i> Alpha-Beta Pruning: Step-by-Step Example
                    </div>

                    <p style="margin-bottom: 20px;">Consider this game tree:</p>

                    <pre style="background: #f0f0f0; padding: 15px; border-radius: 8px; font-family: monospace;">
                     MAX (Root)
                    /         \
                MIN           MIN
               / \           / \
              3   5         2   9
                    </pre>

                    <div class="step">
                        <div class="step-number">1</div>
                        <h5>Start:  = -,  = +</h5>
                        <p>Begin at root MAX node, pass ,  to left MIN child</p>
                    </div>

                    <div class="step">
                        <div class="step-number">2</div>
                        <h5>Left MIN Node: First Child = 3</h5>
                        <p> = min(+, 3) = 3</p>
                        <p>Check: (-)  (3)? NO  Continue</p>
                    </div>

                    <div class="step">
                        <div class="step-number">3</div>
                        <h5>Left MIN Node: Second Child = 5</h5>
                        <p> = min(3, 5) = 3</p>
                        <p>Return 3 to MAX. Update  = max(-, 3) = 3</p>
                    </div>

                    <div class="step">
                        <div class="step-number">4</div>
                        <h5>Right MIN Node (=3, =+): First Child = 2</h5>
                        <p> = min(+, 2) = 2</p>
                        <p>Check: (3)  (2)? <strong>YES!</strong>  <span style="color: #dc2626; font-weight: bold;">PRUNE!</span></p>
                    </div>

                    <div class="step">
                        <div class="step-number">5</div>
                        <h5>Result</h5>
                        <p>Node with value 9 is NEVER explored!</p>
                        <p>We know this branch can only give 2, but MAX already has 3</p>
                        <p>Final answer: MAX chooses left branch, value = <strong>3</strong></p>
                    </div>
                </div>

                <div class="tip-box">
                    <h4><i class="fas fa-lightbulb"></i> Key Insight: Why Pruning Works</h4>
                    <p style="margin-top: 10px;">After MAX sees left subtree gives value 3, and right MIN node's first child is 2:</p>
                    <ul style="margin-left: 20px; margin-top: 10px;">
                        <li>MIN will choose value  2 (since it minimizes)</li>
                        <li>MAX already has option for 3</li>
                        <li>MAX will never choose 2 over 3</li>
                        <li>Therefore, remaining children of right MIN are irrelevant!</li>
                    </ul>
                </div>

                <div class="complexity-box">
                    <div class="complexity-item">
                        <div class="label">Best Case Time</div>
                        <div class="value">O(b<sup>d/2</sup>)</div>
                    </div>
                    <div class="complexity-item">
                        <div class="label">Worst Case Time</div>
                        <div class="value">O(b<sup>d</sup>)</div>
                    </div>
                    <div class="complexity-item">
                        <div class="label">Space Complexity</div>
                        <div class="value">O(bd)</div>
                    </div>
                    <div class="complexity-item">
                        <div class="label">Optimal?</div>
                        <div class="value" style="color: #22c55e;">Yes</div>
                    </div>
                </div>

                <!-- Alpha-Beta Complexity Explanation -->
                <div class="simple-explanation" style="background: linear-gradient(135deg, #fef2f2, #fff1f2); border-left: 4px solid #f43f5e; margin: 20px 0;">
                    <div class="simple-explanation-title" style="color: #e11d48;">
                        <i class="fas fa-calculator"></i> Understanding Alpha-Beta Complexity (Simple Explanation)
                    </div>

                    <p><strong>The Magic of Alpha-Beta: From O(b<sup>d</sup>) to O(b<sup>d/2</sup>)!</strong></p>
                    <div style="background: white; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p>Alpha-Beta achieves the <strong>SAME result</strong> as Minimax but explores <strong>FAR fewer nodes</strong>!</p>

                        <p style="margin-top: 15px;"><strong>Best Case: O(b<sup>d/2</sup>) - How is this possible?</strong></p>
                        <ul style="margin: 10px 0 15px 20px;">
                            <li>With <strong>perfect move ordering</strong> (best moves examined first), roughly <strong>half the nodes are pruned</strong> at each level</li>
                            <li>Instead of exploring b children at each level, we effectively explore only b children</li>
                            <li>Total nodes: (b)<sup>d</sup> = b<sup>d/2</sup></li>
                        </ul>

                        <p><strong>Visual Understanding:</strong></p>
                        <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin: 10px 0; text-align: center;">
                            <p><strong>Minimax explores:</strong> ALL branches</p>
                            <pre style="font-family: monospace;">
      MAX
    / | | \
  MIN MIN MIN MIN  (all 4 children)
  /|\ /|\ /|\ /|\
  all all all all   (all grandchildren)</pre>

                            <p style="margin-top: 15px;"><strong>Alpha-Beta (best case) explores:</strong></p>
                            <pre style="font-family: monospace;">
      MAX
    /   |
  MIN  MIN         (only 2 children fully)
  /|\   |
 all   1 only      (prunes rest)</pre>
                        </div>
                    </div>

                    <p><strong>Why O(b<sup>d/2</sup>)? The Mathematical Intuition:</strong></p>
                    <div style="background: white; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p>Think of it this way:</p>
                        <ul style="margin: 10px 0 15px 20px;">
                            <li>At each MAX level, we find the best move and prove others are worse</li>
                            <li>At each MIN level, we find opponent's best response and prove others are worse</li>
                            <li>With good ordering, we only need to <strong>fully explore 1 child</strong>, then <strong>partially explore siblings</strong> to prove they're worse</li>
                        </ul>

                        <p><strong>The b<sup>d/2</sup> formula derivation:</strong></p>
                        <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin: 10px 0;">
                            <p>In a tree of depth d with branching factor b:</p>
                            <ul style="margin: 10px 0 15px 20px;">
                                <li>At MAX levels: examine all b children of the first MIN child, but only 1 child of other MIN nodes</li>
                                <li>At MIN levels: similar pattern</li>
                                <li>This creates a pattern where we explore: <strong>b<sup>d/2</sup> + b<sup>d/2</sup> - 1</strong> nodes</li>
                                <li>For large d, this simplifies to approximately <strong>O(b<sup>d/2</sup>) = O((b<sup>d</sup>))</strong></li>
                            </ul>
                        </div>
                    </div>

                    <p><strong>Real Impact - Chess Example:</strong></p>
                    <div style="background: white; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p>Chess with b = 35, searching to depth d = 12:</p>
                        <table style="width: 100%; margin: 10px 0; text-align: center;">
                            <tr style="background: #fef2f2;">
                                <th style="padding: 8px;">Algorithm</th>
                                <th style="padding: 8px;">Complexity</th>
                                <th style="padding: 8px;">Nodes (d=12)</th>
                            </tr>
                            <tr><td style="padding: 8px; border: 1px solid #ddd;">Minimax</td><td style="padding: 8px; border: 1px solid #ddd;">O(b<sup>d</sup>)</td><td style="padding: 8px; border: 1px solid #ddd; color: #dc2626;">35<sup>12</sup>  3  10<sup>18</sup></td></tr>
                            <tr style="background: #dcfce7;"><td style="padding: 8px; border: 1px solid #ddd;">Alpha-Beta (best)</td><td style="padding: 8px; border: 1px solid #ddd;">O(b<sup>d/2</sup>)</td><td style="padding: 8px; border: 1px solid #ddd; color: #16a34a;"><strong>35<sup>6</sup>  1.8  10<sup>9</sup></strong></td></tr>
                        </table>
                        <p style="margin-top: 10px;"><strong>Improvement: ~1.7 billion times fewer nodes!</strong></p>
                        <p style="margin-top: 5px;">OR: Alpha-Beta can search to <strong>depth 24</strong> in the same time Minimax searches to depth 12!</p>
                    </div>

                    <p><strong>Worst Case O(b<sup>d</sup>) - When does this happen?</strong></p>
                    <div style="background: #fef3c7; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p>If moves are examined in the <strong>worst possible order</strong> (worst moves first):</p>
                        <ul style="margin: 10px 0 15px 20px;">
                            <li>No pruning can occur because we never find good bounds early</li>
                            <li>Alpha-Beta degenerates to regular Minimax</li>
                            <li>This is why <strong>move ordering is crucial!</strong></li>
                        </ul>
                        <p style="color: #b45309;"><strong>In practice:</strong> Average case is closer to O(b<sup>3d/4</sup>) with random ordering</p>
                    </div>

                    <p><strong>Space Complexity O(bd) - Same as Minimax</strong></p>
                    <div style="background: white; padding: 15px; border-radius: 8px; margin: 10px 0;">
                        <p>Alpha-Beta uses depth-first search, so it stores:</p>
                        <ul style="margin: 10px 0 0 20px;">
                            <li>Current path: d nodes</li>
                            <li>Siblings at each level: up to b per level</li>
                            <li>Plus ,  values at each level: negligible</li>
                            <li><strong>Total: O(bd)</strong> - very memory efficient!</li>
                        </ul>
                    </div>
                </div>

                <div class="key-points">
                    <h4><i class="fas fa-key"></i> Important Properties of Alpha-Beta</h4>
                    <ul>
                        <li><strong>Same Result:</strong> Alpha-Beta always returns the same value as full Minimax</li>
                        <li><strong>Move Ordering:</strong> Best pruning occurs when best moves are examined first</li>
                        <li><strong>Perfect Ordering:</strong> With perfect move ordering, can search twice as deep!</li>
                        <li><strong>Effective Branching Factor:</strong> Reduced from b to b in best case</li>
                        <li><strong>No Risk:</strong> Never prunes a branch that could affect the result</li>
                    </ul>
                </div>

                <h3><i class="fas fa-sort"></i>Move Ordering Strategies</h3>

                <div class="mechanism-box">
                    <h4><i class="fas fa-cogs"></i> How to Improve Alpha-Beta Performance</h4>
                    <ul style="margin-left: 20px;">
                        <li><strong>Killer Heuristic:</strong> Try moves that caused cutoffs at sibling nodes first</li>
                        <li><strong>History Heuristic:</strong> Track moves that have been good in the past</li>
                        <li><strong>Transposition Tables:</strong> Store evaluated positions to avoid re-computation</li>
                        <li><strong>Iterative Deepening:</strong> Use shallow search to order moves for deeper search</li>
                        <li><strong>Static Move Ordering:</strong> In chess: captures > checks > central moves > edge moves</li>
                    </ul>
                </div>

                <div class="example-box industry">
                    <div class="example-title">
                        <i class="fas fa-building"></i>Industry Applications
                        <span class="example-level industry">INDUSTRY</span>
                    </div>
                    <ul>
                        <li><strong>Chess Engines (Stockfish, Komodo):</strong> Alpha-Beta with deep enhancements</li>
                        <li><strong>Checkers (Chinook):</strong> Solved checkers using alpha-beta variants</li>
                        <li><strong>Backgammon (TD-Gammon):</strong> Combined with neural network evaluation</li>
                        <li><strong>Strategy Games:</strong> Real-time strategy games use modified versions</li>
                        <li><strong>Economic Modeling:</strong> Game theory applications in business strategy</li>
                    </ul>
                </div>

                <!-- Alpha-Beta Visual Animation -->
                <div class="visualization-box" style="background: linear-gradient(135deg, #fef2f2, #fecaca); border-radius: 15px; padding: 25px; margin: 25px 0; border: 2px solid #ef4444;">
                    <h4 style="color: #dc2626; margin-bottom: 20px;"><i class="fas fa-cut"></i> Alpha-Beta Pruning Visualization - Watch the Pruning!</h4>

                    <!-- Animated GIF/Video -->
                    <div style="text-align: center; margin-bottom: 25px;">
                        <img src="assets/videos/alphabeta.gif" alt="Alpha-Beta Pruning Animation" style="max-width: 100%; height: auto; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                        <p style="color: #991b1b; margin-top: 10px; font-style: italic;">Animation showing Alpha-Beta pruning branches that can't affect the result</p>
                    </div>

                    <!-- Step-by-step Images -->
                    <h5 style="color: #dc2626; margin: 20px 0 15px 0;"><i class="fas fa-images"></i> Step-by-Step: Watch Branches Get Pruned!</h5>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px;">
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/alphabeta_step_0.png" alt="Alpha-Beta Step 0" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #991b1b; margin-top: 8px;"><strong>Step 0:</strong> Start (=-, =+)</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/alphabeta_step_1.png" alt="Alpha-Beta Step 1" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #991b1b; margin-top: 8px;"><strong>Step 1:</strong> First Subtree</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/alphabeta_step_2.png" alt="Alpha-Beta Step 2" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #991b1b; margin-top: 8px;"><strong>Step 2:</strong> Update Alpha</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/alphabeta_step_3.png" alt="Alpha-Beta Step 3" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #991b1b; margin-top: 8px;"><strong>Step 3:</strong> Check Condition</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/alphabeta_step_4.png" alt="Alpha-Beta Step 4" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #991b1b; margin-top: 8px;"><strong>Step 4:</strong>     PRUNE!</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/alphabeta_step_5.png" alt="Alpha-Beta Step 5" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #991b1b; margin-top: 8px;"><strong>Step 5:</strong> More Pruning</p>
                        </div>
                        <div style="text-align: center; background: white; padding: 10px; border-radius: 8px;">
                            <img src="assets/images/alphabeta_step_6.png" alt="Alpha-Beta Step 6" style="width: 100%; border-radius: 5px;">
                            <p style="font-size: 0.85em; color: #991b1b; margin-top: 8px;"><strong>Step 6:</strong> Final Result</p>
                        </div>
                    </div>

                    <!-- Video Player -->
                    <div style="margin-top: 25px; text-align: center;">
                        <h5 style="color: #dc2626; margin-bottom: 15px;"><i class="fas fa-video"></i> Full Video Explanation</h5>
                        <video controls style="max-width: 100%; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                            <source src="assets/videos/alphabeta.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                    </div>
                </div>

                <div class="pros-cons">
                    <div class="pros-box">
                        <h4><i class="fas fa-check-circle"></i> Advantages</h4>
                        <ul>
                            <li>Dramatically faster than minimax</li>
                            <li>Guaranteed same result</li>
                            <li>Can search twice as deep</li>
                            <li>Easy to implement</li>
                            <li>Works with any minimax variant</li>
                        </ul>
                    </div>
                    <div class="cons-box">
                        <h4><i class="fas fa-times-circle"></i> Disadvantages</h4>
                        <ul>
                            <li>Performance depends on move ordering</li>
                            <li>Still exponential worst case</li>
                            <li>Sequential in nature (hard to parallelize)</li>
                            <li>May miss good moves if ordering is poor</li>
                        </ul>
                    </div>
                </div>

                <h3><i class="fas fa-balance-scale"></i>Minimax vs Alpha-Beta Comparison</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Minimax</th>
                            <th>Alpha-Beta</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Nodes Explored</strong></td>
                            <td>All nodes in tree</td>
                            <td>Only necessary nodes</td>
                        </tr>
                        <tr>
                            <td><strong>Time Complexity</strong></td>
                            <td>O(b<sup>m</sup>)</td>
                            <td>O(b<sup>m/2</sup>) best case</td>
                        </tr>
                        <tr>
                            <td><strong>Result</strong></td>
                            <td>Optimal move</td>
                            <td>Same optimal move</td>
                        </tr>
                        <tr>
                            <td><strong>Additional Parameters</strong></td>
                            <td>None</td>
                            <td> (alpha),  (beta)</td>
                        </tr>
                        <tr>
                            <td><strong>Move Ordering Impact</strong></td>
                            <td>None</td>
                            <td>Significant</td>
                        </tr>
                        <tr>
                            <td><strong>Practical Use</strong></td>
                            <td>Small trees only</td>
                            <td>Standard for game AI</td>
                        </tr>
                    </tbody>
                </table>

                <div class="analogy-box">
                    <div class="analogy-header">
                        <i class="fas fa-lightbulb"></i> Real-Life Analogy: House Hunting
                    </div>
                    <div class="analogy-scenario">
                        <h5>Understanding Alpha-Beta Through House Hunting</h5>
                        <p>You're helping a friend (MAX) find a house while their spouse (MIN) needs to agree:</p>
                        <ul style="margin-left: 20px; margin-top: 10px;">
                            <li>You find House A rated 7/10 ( = 7)</li>
                            <li>You go to area B, and the FIRST house you see is rated 5/10</li>
                            <li>You know the spouse will pick the WORST house in each area (MIN)</li>
                            <li>Even if other houses in area B are 9/10, spouse will still pick the 5</li>
                            <li>Since 5 < 7 (  ), no need to see other houses in area B!</li>
                        </ul>
                        <p style="margin-top: 15px;"><em>This is exactly how alpha-beta prunes: once we know a branch can't beat our current best, skip it!</em></p>
                    </div>
                </div>

                <!-- Exam Questions -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-pen"></i> Important Exam Questions - Alpha-Beta Pruning</div>

                    <div style="margin-bottom: 25px;">
                        <span class="marks-badge four">4 MARKS</span>
                        <p><strong>Q1. What is Alpha-Beta pruning? Define alpha and beta values.</strong></p>
                        <div style="background: white; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #7c3aed;">
                            <h5 style="color: #5b21b6;">MODEL ANSWER:</h5>

                            <p><strong>Definition of Alpha-Beta Pruning:</strong></p>
                            <p style="margin: 10px 0;">Alpha-Beta pruning is an optimization technique for the Minimax algorithm that reduces the number of nodes evaluated in the game tree. It eliminates branches that cannot possibly influence the final decision, without affecting the result.</p>

                            <p><strong>Alpha () Value:</strong></p>
                            <ul style="margin: 10px 0 15px 20px;">
                                <li>Represents the <strong>best (highest) value</strong> that MAX can guarantee so far</li>
                                <li>Acts as a <strong>lower bound</strong> for MAX's score</li>
                                <li>Initialized to - (negative infinity)</li>
                                <li>Updated at MAX nodes:  = max(, child_value)</li>
                            </ul>

                            <p><strong>Beta () Value:</strong></p>
                            <ul style="margin: 10px 0 15px 20px;">
                                <li>Represents the <strong>best (lowest) value</strong> that MIN can guarantee so far</li>
                                <li>Acts as an <strong>upper bound</strong> for MIN's score</li>
                                <li>Initialized to + (positive infinity)</li>
                                <li>Updated at MIN nodes:  = min(, child_value)</li>
                            </ul>

                            <p><strong>Pruning Condition:</strong></p>
                            <p style="margin: 10px 0;">Pruning occurs when <strong>  </strong>. At this point, the current node's remaining children need not be explored because:</p>
                            <ul style="margin: 5px 0 0 20px;">
                                <li>At MAX node ( cutoff): Value found exceeds what MIN will allow</li>
                                <li>At MIN node ( cutoff): Value found is below what MAX will accept</li>
                            </ul>
                        </div>
                    </div>

                    <div style="margin-bottom: 25px;">
                        <span class="marks-badge four">4 MARKS</span>
                        <p><strong>Q2. How does move ordering affect Alpha-Beta pruning?</strong></p>
                        <div style="background: white; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #7c3aed;">
                            <h5 style="color: #5b21b6;">MODEL ANSWER:</h5>

                            <p><strong>Impact of Move Ordering:</strong></p>
                            <p style="margin: 10px 0;">The effectiveness of Alpha-Beta pruning heavily depends on the order in which moves are examined. Better ordering leads to more pruning and faster search.</p>

                            <p><strong>Time Complexity Comparison:</strong></p>
                            <table style="width: 100%; margin: 15px 0; border-collapse: collapse;">
                                <tr style="background: #f0f0f0;">
                                    <th style="padding: 10px; border: 1px solid #ddd;">Scenario</th>
                                    <th style="padding: 10px; border: 1px solid #ddd;">Complexity</th>
                                </tr>
                                <tr>
                                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Best Case</strong> (optimal ordering)</td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">O(b<sup>d/2</sup>)</td>
                                </tr>
                                <tr>
                                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Worst Case</strong> (worst ordering)</td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">O(b<sup>d</sup>) - same as Minimax</td>
                                </tr>
                                <tr>
                                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Average Case</strong></td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">O(b<sup>3d/4</sup>)</td>
                                </tr>
                            </table>

                            <p><strong>Why Ordering Matters:</strong></p>
                            <ul style="margin: 10px 0 15px 20px;">
                                <li>If best moves are examined first,  and  reach their final values quickly</li>
                                <li>Tight bounds cause more cutoffs, pruning more branches</li>
                                <li>With perfect ordering, can search <strong>twice as deep</strong> in same time</li>
                            </ul>

                            <p><strong>Move Ordering Strategies:</strong></p>
                            <ul style="margin: 10px 0 0 20px;">
                                <li><strong>Killer Heuristic:</strong> Try moves that caused cutoffs at sibling nodes</li>
                                <li><strong>History Heuristic:</strong> Prioritize moves historically successful</li>
                                <li><strong>Iterative Deepening:</strong> Use results of shallow search to order deep search</li>
                                <li><strong>Static Ordering:</strong> Captures before quiet moves, center before edge</li>
                            </ul>
                        </div>
                    </div>

                    <div style="margin-bottom: 25px;">
                        <span class="marks-badge eight">8 MARKS</span>
                        <p><strong>Q3. Explain Alpha-Beta pruning algorithm. Apply it to the given game tree and show which nodes are pruned.</strong></p>
                        <div style="background: white; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #7c3aed;">
                            <h5 style="color: #5b21b6;">MODEL ANSWER:</h5>

                            <p><strong>1. Algorithm Explanation:</strong></p>
                            <p style="margin: 10px 0;">Alpha-Beta pruning enhances Minimax by maintaining two values:  (best for MAX) and  (best for MIN). When   , remaining branches are pruned.</p>

                            <p><strong>2. Pseudocode:</strong></p>
                            <pre style="background: #f5f5f5; padding: 15px; border-radius: 8px; font-family: monospace; font-size: 0.85em;">
ALPHA-BETA(node, depth, , , maximizing):
  if depth=0 or terminal: return evaluate(node)

  if maximizing:
    value = -
    for each child:
      value = max(value, ALPHA-BETA(child, depth-1, , , false))
       = max(, value)
      if   : break  //  cutoff
    return value
  else:
    value = +
    for each child:
      value = min(value, ALPHA-BETA(child, depth-1, , , true))
       = min(, value)
      if   : break  //  cutoff
    return value
                            </pre>

                            <p><strong>3. Given Game Tree:</strong></p>
                            <pre style="background: #f5f5f5; padding: 15px; border-radius: 8px; font-family: monospace;">
              MAX (A)
             /       \
        MIN (B)    MIN (C)
        /    \      /    \
       5      3    1      8
                            </pre>

                            <p><strong>4. Step-by-Step Execution:</strong></p>

                            <div style="background: #f9f9f9; padding: 15px; border-radius: 8px; margin: 10px 0;">
                                <p><strong>Step 1:</strong> Start at A (MAX),  = -,  = +</p>
                                <p><strong>Step 2:</strong> Go to B (MIN),  = -,  = +</p>
                                <p><strong>Step 3:</strong> B's first child = 5   = min(+, 5) = 5</p>
                                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check: (-)  (5)? NO  continue</p>
                                <p><strong>Step 4:</strong> B's second child = 3   = min(5, 3) = 3</p>
                                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B returns 3 to A</p>
                                <p><strong>Step 5:</strong> At A:  = max(-, 3) = 3</p>
                                <p><strong>Step 6:</strong> Go to C (MIN),  = 3,  = +</p>
                                <p><strong>Step 7:</strong> C's first child = 1   = min(+, 1) = 1</p>
                                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check: (3)  (1)? <strong style="color: red;">YES! PRUNE!</strong></p>
                                <p><strong>Step 8:</strong> Node with value 8 is <strong style="color: red;">PRUNED</strong> - never evaluated!</p>
                            </div>

                            <p><strong>5. Result Visualization:</strong></p>
                            <pre style="background: #f5f5f5; padding: 15px; border-radius: 8px; font-family: monospace;">
              MAX (A) = 3
             /         \
        MIN (B)=3    MIN (C)=1
        /    \        /    \
       5      3      1      <span style="color: red; text-decoration: line-through;">8</span>  PRUNED
                            </pre>

                            <p><strong>6. Conclusion:</strong></p>
                            <p style="margin: 10px 0;">The final minimax value is <strong>3</strong>. MAX chooses left branch (B). The node with value 8 was pruned because once MIN found value 1, and MAX already had 3 guaranteed, MAX would never choose this branch regardless of what other values exist.</p>
                        </div>
                    </div>

                    <div style="margin-bottom: 25px;">
                        <span class="marks-badge eight">8 MARKS</span>
                        <p><strong>Q4. Compare Minimax and Alpha-Beta Pruning. When and why is Alpha-Beta preferred?</strong></p>
                        <div style="background: white; padding: 20px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #7c3aed;">
                            <h5 style="color: #5b21b6;">MODEL ANSWER:</h5>

                            <p><strong>1. Comparison Table:</strong></p>
                            <table style="width: 100%; margin: 15px 0; border-collapse: collapse; font-size: 0.95em;">
                                <tr style="background: #5b21b6; color: white;">
                                    <th style="padding: 10px; border: 1px solid #ddd;">Aspect</th>
                                    <th style="padding: 10px; border: 1px solid #ddd;">Minimax</th>
                                    <th style="padding: 10px; border: 1px solid #ddd;">Alpha-Beta Pruning</th>
                                </tr>
                                <tr>
                                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Nodes Explored</strong></td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">All nodes in game tree</td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">Only necessary nodes</td>
                                </tr>
                                <tr style="background: #f9f9f9;">
                                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Time Complexity</strong></td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">O(b<sup>m</sup>)</td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">O(b<sup>m/2</sup>) best case</td>
                                </tr>
                                <tr>
                                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Space Complexity</strong></td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">O(bm)</td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">O(bm)</td>
                                </tr>
                                <tr style="background: #f9f9f9;">
                                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Result Quality</strong></td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">Optimal</td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">Same optimal result</td>
                                </tr>
                                <tr>
                                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Additional Parameters</strong></td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">None</td>
                                    <td style="padding: 10px; border: 1px solid #ddd;"> and  bounds</td>
                                </tr>
                                <tr style="background: #f9f9f9;">
                                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Move Ordering Impact</strong></td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">None</td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">Significant impact</td>
                                </tr>
                                <tr>
                                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Effective Branching</strong></td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">b</td>
                                    <td style="padding: 10px; border: 1px solid #ddd;">b (best case)</td>
                                </tr>
                            </table>

                            <p><strong>2. When is Alpha-Beta Preferred?</strong></p>
                            <ul style="margin: 10px 0 15px 20px;">
                                <li><strong>Large Game Trees:</strong> When complete search is computationally expensive</li>
                                <li><strong>Time-Limited Decisions:</strong> When moves must be made within time constraints</li>
                                <li><strong>Deep Searches:</strong> When deeper lookahead is needed for better play</li>
                                <li><strong>Complex Games:</strong> Chess, Go, Checkers where b<sup>m</sup> is astronomically large</li>
                            </ul>

                            <p><strong>3. Why Alpha-Beta is Preferred:</strong></p>
                            <ul style="margin: 10px 0 15px 20px;">
                                <li><strong>Same Result, Less Work:</strong> Guarantees identical result to Minimax with fewer node evaluations</li>
                                <li><strong>Depth Advantage:</strong> Can search twice as deep in the same time (best case)</li>
                                <li><strong>No Risk:</strong> Never prunes branches that could affect the optimal decision</li>
                                <li><strong>Industry Standard:</strong> Basis for all professional game-playing programs</li>
                                <li><strong>Combinable:</strong> Works with other enhancements (iterative deepening, transposition tables)</li>
                            </ul>

                            <p><strong>4. Practical Example - Chess:</strong></p>
                            <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin: 10px 0;">
                                <p>Chess: b  35, typical search depth m = 12</p>
                                <p>Minimax: 35<sup>12</sup>  3  10<sup>18</sup> nodes</p>
                                <p>Alpha-Beta (best): 35<sup>6</sup>  1.8  10<sup>9</sup> nodes</p>
                                <p><strong>Reduction: ~1 billion times fewer nodes!</strong></p>
                            </div>

                            <p><strong>5. Industry Applications:</strong></p>
                            <ul style="margin: 10px 0 15px 20px;">
                                <li><strong>Stockfish (Chess):</strong> Uses alpha-beta with advanced enhancements</li>
                                <li><strong>Chinook (Checkers):</strong> Solved checkers using alpha-beta variants</li>
                                <li><strong>Game Consoles:</strong> Used in strategy and board game implementations</li>
                                <li><strong>Decision Support:</strong> Business strategy and economic modeling</li>
                            </ul>

                            <p><strong>6. Conclusion:</strong></p>
                            <p>Alpha-Beta pruning is the de facto standard for game tree search. It provides all the benefits of Minimax (optimality, completeness) while dramatically reducing computational requirements, making it essential for any practical game-playing AI system.</p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ==================== MODEL ANSWERS SECTION ==================== -->
            <section id="answers">
                <h2><i class="fas fa-file-alt"></i>Model Answers for Exam Questions</h2>

                <div class="tip-box" style="background: linear-gradient(135deg, #1e3a5f, #2d4a6f); color: white; border-left-color: #ffd700; margin-bottom: 30px;">
                    <h4 style="color: #ffd700;"><i class="fas fa-info-circle"></i> How to Use These Answers</h4>
                    <ul style="margin-top: 10px;">
                        <li>4-mark answers: Write concise answers covering all key points</li>
                        <li>8-mark answers: Include introduction, detailed explanation, diagrams, examples, and conclusion</li>
                        <li>Always draw diagrams where applicable - they carry significant marks</li>
                        <li>Use proper headings and bullet points for clarity</li>
                    </ul>
                </div>

                <!-- ========== INTRODUCTION TO AI - ANSWERS ========== -->
                <h3><i class="fas fa-robot"></i>1. Introduction to AI - Model Answers</h3>

                <!-- Q1 - 4 Marks -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-question-circle"></i> Q1. Define Artificial Intelligence. List any four goals of AI. [4 Marks]</div>
                    <span class="marks-badge four">4 MARKS</span>

                    <div style="background: white; padding: 25px; border-radius: 12px; margin-top: 15px; border: 2px solid #7c3aed;">
                        <h5 style="color: #5b21b6; margin-bottom: 15px;">MODEL ANSWER:</h5>

                        <p><strong>Definition of Artificial Intelligence:</strong></p>
                        <p style="margin: 10px 0 20px 0;">Artificial Intelligence (AI) is the branch of computer science that deals with creating intelligent machines capable of performing tasks that typically require human intelligence. According to John McCarthy (1956), "AI is the science and engineering of making intelligent machines, especially intelligent computer programs."</p>

                        <p><strong>Four Goals of Artificial Intelligence:</strong></p>
                        <ol style="margin-left: 25px; margin-top: 10px;">
                            <li style="margin: 10px 0;"><strong>Systems that Think Humanly (Cognitive Modeling):</strong> Creating systems that think and reason like humans by understanding human thought processes through introspection, psychological experiments, and brain imaging.</li>
                            <li style="margin: 10px 0;"><strong>Systems that Act Humanly (Turing Test Approach):</strong> Building machines that can behave in a way indistinguishable from humans. The Turing Test is used to evaluate this capability.</li>
                            <li style="margin: 10px 0;"><strong>Systems that Think Rationally (Laws of Thought):</strong> Developing systems that use logic and formal reasoning to derive conclusions and solve problems systematically.</li>
                            <li style="margin: 10px 0;"><strong>Systems that Act Rationally (Rational Agent):</strong> Creating agents that take the best possible action to achieve their goals based on available information, even under uncertainty.</li>
                        </ol>
                    </div>
                </div>

                <!-- Q2 - 4 Marks -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-question-circle"></i> Q2. Differentiate between Narrow AI and General AI with examples. [4 Marks]</div>
                    <span class="marks-badge four">4 MARKS</span>

                    <div style="background: white; padding: 25px; border-radius: 12px; margin-top: 15px; border: 2px solid #7c3aed;">
                        <h5 style="color: #5b21b6; margin-bottom: 15px;">MODEL ANSWER:</h5>

                        <table style="width: 100%; margin-top: 10px;">
                            <thead>
                                <tr>
                                    <th>Aspect</th>
                                    <th>Narrow AI (Weak AI)</th>
                                    <th>General AI (Strong AI)</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Definition</strong></td>
                                    <td>AI designed and trained for a specific task or narrow range of tasks</td>
                                    <td>AI with human-like intelligence that can perform any intellectual task a human can</td>
                                </tr>
                                <tr>
                                    <td><strong>Capability</strong></td>
                                    <td>Limited to predefined functions; cannot generalize beyond training</td>
                                    <td>Can learn, understand, and apply knowledge across different domains</td>
                                </tr>
                                <tr>
                                    <td><strong>Learning</strong></td>
                                    <td>Learns patterns within its specific domain only</td>
                                    <td>Can transfer learning from one domain to another</td>
                                </tr>
                                <tr>
                                    <td><strong>Current Status</strong></td>
                                    <td>Exists and widely deployed</td>
                                    <td>Hypothetical; not yet achieved</td>
                                </tr>
                                <tr>
                                    <td><strong>Examples</strong></td>
                                    <td>Siri, Alexa, Chess engines, Spam filters, Face recognition, Netflix recommendations</td>
                                    <td>No real examples exist; depicted in science fiction like HAL 9000, JARVIS</td>
                                </tr>
                            </tbody>
                        </table>

                        <p style="margin-top: 15px;"><strong>Key Difference:</strong> Narrow AI excels at specific tasks but cannot adapt to new situations outside its training, while General AI would possess human-like flexibility and reasoning across all domains.</p>
                    </div>
                </div>

                <!-- Q3 - 8 Marks -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-question-circle"></i> Q3. Explain the different types of AI based on functionality with suitable examples. [8 Marks]</div>
                    <span class="marks-badge eight">8 MARKS</span>

                    <div style="background: white; padding: 25px; border-radius: 12px; margin-top: 15px; border: 2px solid #7c3aed;">
                        <h5 style="color: #5b21b6; margin-bottom: 15px;">MODEL ANSWER:</h5>

                        <p><strong>Introduction:</strong> Based on functionality, AI systems can be classified into four types according to their capabilities, memory, and level of intelligence:</p>

                        <h5 style="color: #3d5a80; margin-top: 20px;">1. Reactive Machines</h5>
                        <ul style="margin-left: 25px;">
                            <li><strong>Definition:</strong> The most basic type of AI that can only react to current situations without memory of past experiences.</li>
                            <li><strong>Characteristics:</strong>
                                <ul style="margin-left: 20px;">
                                    <li>No memory or ability to learn from past experiences</li>
                                    <li>Cannot use past data to inform future decisions</li>
                                    <li>Responds only to current input</li>
                                    <li>Highly specialized for specific tasks</li>
                                </ul>
                            </li>
                            <li><strong>Example:</strong> IBM Deep Blue (Chess computer that defeated Garry Kasparov). It analyzed current board positions and possible moves but couldn't learn from previous games.</li>
                        </ul>

                        <h5 style="color: #3d5a80; margin-top: 20px;">2. Limited Memory AI</h5>
                        <ul style="margin-left: 25px;">
                            <li><strong>Definition:</strong> AI systems that can store past experiences temporarily and use them to make better decisions.</li>
                            <li><strong>Characteristics:</strong>
                                <ul style="margin-left: 20px;">
                                    <li>Can learn from historical data</li>
                                    <li>Uses past information for short-term decisions</li>
                                    <li>Memory is temporary and task-specific</li>
                                    <li>Most current AI applications fall in this category</li>
                                </ul>
                            </li>
                            <li><strong>Examples:</strong>
                                <ul style="margin-left: 20px;">
                                    <li>Self-driving cars (store recent observations of other vehicles, traffic signals)</li>
                                    <li>Chatbots like ChatGPT (remember conversation context)</li>
                                    <li>Virtual assistants (Siri, Alexa)</li>
                                </ul>
                            </li>
                        </ul>

                        <h5 style="color: #3d5a80; margin-top: 20px;">3. Theory of Mind AI</h5>
                        <ul style="margin-left: 25px;">
                            <li><strong>Definition:</strong> AI that can understand and interpret human emotions, beliefs, intentions, and mental states.</li>
                            <li><strong>Characteristics:</strong>
                                <ul style="margin-left: 20px;">
                                    <li>Understands that others have thoughts and emotions</li>
                                    <li>Can predict behavior based on emotional understanding</li>
                                    <li>Capable of social interaction</li>
                                    <li>Currently in research phase</li>
                                </ul>
                            </li>
                            <li><strong>Example:</strong> Advanced social robots like Sophia (partially); Fully functional Theory of Mind AI doesn't exist yet but is being researched for healthcare robots and emotional companions.</li>
                        </ul>

                        <h5 style="color: #3d5a80; margin-top: 20px;">4. Self-Aware AI</h5>
                        <ul style="margin-left: 25px;">
                            <li><strong>Definition:</strong> Hypothetical AI that possesses consciousness, self-awareness, and sentience similar to humans.</li>
                            <li><strong>Characteristics:</strong>
                                <ul style="margin-left: 20px;">
                                    <li>Has consciousness and self-awareness</li>
                                    <li>Understands its own existence and internal states</li>
                                    <li>Can form its own emotions and desires</li>
                                    <li>Completely theoretical - does not exist</li>
                                </ul>
                            </li>
                            <li><strong>Example:</strong> No real examples exist. Science fiction examples include HAL 9000 (2001: A Space Odyssey), Skynet (Terminator), and JARVIS/Vision (Marvel).</li>
                        </ul>

                        <p style="margin-top: 20px; padding: 15px; background: #f0f9ff; border-radius: 8px;"><strong>Conclusion:</strong> Currently, most AI systems are Reactive or Limited Memory types. Theory of Mind AI is under active research, while Self-Aware AI remains a theoretical concept. As AI advances, we may progress through these levels of sophistication.</p>
                    </div>
                </div>

                <!-- Q4 - 8 Marks -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-question-circle"></i> Q4. Discuss the various applications of AI in different domains. Also mention the advantages and limitations of AI. [8 Marks]</div>
                    <span class="marks-badge eight">8 MARKS</span>

                    <div style="background: white; padding: 25px; border-radius: 12px; margin-top: 15px; border: 2px solid #7c3aed;">
                        <h5 style="color: #5b21b6; margin-bottom: 15px;">MODEL ANSWER:</h5>

                        <p><strong>Introduction:</strong> Artificial Intelligence has transformed numerous industries by automating complex tasks and enabling intelligent decision-making.</p>

                        <h5 style="color: #3d5a80; margin-top: 20px;">Applications of AI in Different Domains:</h5>

                        <table style="width: 100%; margin: 15px 0;">
                            <tr>
                                <th>Domain</th>
                                <th>Applications</th>
                            </tr>
                            <tr>
                                <td><strong>Healthcare</strong></td>
                                <td>Disease diagnosis (IBM Watson), Medical image analysis (X-ray, MRI interpretation), Drug discovery, Virtual health assistants, Robotic surgery</td>
                            </tr>
                            <tr>
                                <td><strong>Finance</strong></td>
                                <td>Fraud detection, Algorithmic trading, Credit scoring, Risk assessment, Chatbots for customer service</td>
                            </tr>
                            <tr>
                                <td><strong>Transportation</strong></td>
                                <td>Self-driving cars (Tesla, Waymo), Traffic prediction, Route optimization (Google Maps), Autonomous drones</td>
                            </tr>
                            <tr>
                                <td><strong>E-commerce & Retail</strong></td>
                                <td>Product recommendations (Amazon, Netflix), Inventory management, Personalized marketing, Chatbots</td>
                            </tr>
                            <tr>
                                <td><strong>Manufacturing</strong></td>
                                <td>Predictive maintenance, Quality control, Robotic assembly lines, Supply chain optimization</td>
                            </tr>
                            <tr>
                                <td><strong>Education</strong></td>
                                <td>Adaptive learning platforms, Automated grading, Intelligent tutoring systems, Plagiarism detection</td>
                            </tr>
                        </table>

                        <h5 style="color: #22c55e; margin-top: 25px;">Advantages of AI:</h5>
                        <ol style="margin-left: 25px;">
                            <li><strong>Increased Efficiency:</strong> AI processes data and performs tasks much faster than humans</li>
                            <li><strong>Reduced Human Error:</strong> Consistent and accurate results without fatigue</li>
                            <li><strong>24/7 Availability:</strong> AI systems can work continuously without breaks</li>
                            <li><strong>Handling Big Data:</strong> Can process and analyze massive datasets efficiently</li>
                            <li><strong>Dangerous Task Execution:</strong> Can work in hazardous environments (mining, space exploration)</li>
                            <li><strong>Cost Reduction:</strong> Automation reduces labor costs in the long term</li>
                        </ol>

                        <h5 style="color: #ef4444; margin-top: 25px;">Limitations of AI:</h5>
                        <ol style="margin-left: 25px;">
                            <li><strong>High Development Cost:</strong> Creating and maintaining AI systems is expensive</li>
                            <li><strong>Job Displacement:</strong> Automation may replace human workers in various sectors</li>
                            <li><strong>Lack of Creativity:</strong> AI cannot think creatively or outside its training data</li>
                            <li><strong>No Emotional Intelligence:</strong> Cannot truly understand human emotions</li>
                            <li><strong>Ethical Concerns:</strong> Issues of privacy, bias in algorithms, and misuse</li>
                            <li><strong>Dependency Risk:</strong> Over-reliance on AI systems can be dangerous if they fail</li>
                        </ol>

                        <p style="margin-top: 20px; padding: 15px; background: #f0f9ff; border-radius: 8px;"><strong>Conclusion:</strong> While AI offers tremendous benefits across industries, its limitations must be carefully considered. A balanced approach combining AI capabilities with human oversight is essential for responsible AI deployment.</p>
                    </div>
                </div>

                <!-- ========== PROBLEM REPRESENTATION - ANSWERS ========== -->
                <h3><i class="fas fa-puzzle-piece"></i>2. Problem Representation - Model Answers</h3>

                <!-- Q1 - 4 Marks -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-question-circle"></i> Q1. What are the components of a well-defined problem in AI? Explain each briefly. [4 Marks]</div>
                    <span class="marks-badge four">4 MARKS</span>

                    <div style="background: white; padding: 25px; border-radius: 12px; margin-top: 15px; border: 2px solid #7c3aed;">
                        <h5 style="color: #5b21b6; margin-bottom: 15px;">MODEL ANSWER:</h5>

                        <p>A well-defined problem in AI has five essential components:</p>

                        <ol style="margin-left: 25px; margin-top: 15px;">
                            <li style="margin: 12px 0;">
                                <strong>Initial State:</strong> The starting condition or configuration from which the problem-solving process begins. It describes "where we are now."
                                <br><em>Example: In 8-puzzle, the initial arrangement of tiles on the board.</em>
                            </li>
                            <li style="margin: 12px 0;">
                                <strong>Goal State (Goal Test):</strong> The desired end condition that defines success. It can be a single state or a set of states satisfying certain criteria.
                                <br><em>Example: Tiles arranged in order 1-8 with blank in center.</em>
                            </li>
                            <li style="margin: 12px 0;">
                                <strong>Actions/Operators:</strong> The set of possible moves or operations that can transform one state into another. These define "what we can do."
                                <br><em>Example: Move blank UP, DOWN, LEFT, or RIGHT.</em>
                            </li>
                            <li style="margin: 12px 0;">
                                <strong>Path Cost Function:</strong> A function that assigns a numeric cost to each path, helping evaluate solution quality.
                                <br><em>Example: Each move costs 1; total cost = number of moves.</em>
                            </li>
                            <li style="margin: 12px 0;">
                                <strong>State Space:</strong> The set of all possible states reachable from the initial state by any sequence of actions.
                                <br><em>Example: All 181,440 possible configurations of the 8-puzzle.</em>
                            </li>
                        </ol>
                    </div>
                </div>

                <!-- Q2 - 8 Marks -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-question-circle"></i> Q2. Formulate the 8-Puzzle problem as a well-defined AI problem. Define all components clearly. [8 Marks]</div>
                    <span class="marks-badge eight">8 MARKS</span>

                    <div style="background: white; padding: 25px; border-radius: 12px; margin-top: 15px; border: 2px solid #7c3aed;">
                        <h5 style="color: #5b21b6; margin-bottom: 15px;">MODEL ANSWER:</h5>

                        <p><strong>Problem Description:</strong></p>
                        <p>The 8-puzzle consists of a 33 board with 8 numbered tiles (1-8) and one blank space. Tiles can slide into the blank space. The goal is to reach a specified goal configuration from any given initial configuration.</p>

                        <div style="display: flex; justify-content: space-around; margin: 20px 0; flex-wrap: wrap; gap: 20px;">
                            <div style="text-align: center; padding: 15px; background: #f0f0f0; border-radius: 8px;">
                                <strong>Initial State (Example)</strong>
                                <pre style="font-family: monospace; margin-top: 10px;">
| 2 | 8 | 3 |
| 1 | 6 | 4 |
| 7 | _ | 5 |</pre>
                            </div>
                            <div style="text-align: center; padding: 15px; background: #dcfce7; border-radius: 8px;">
                                <strong>Goal State</strong>
                                <pre style="font-family: monospace; margin-top: 10px;">
| 1 | 2 | 3 |
| 8 | _ | 4 |
| 7 | 6 | 5 |</pre>
                            </div>
                        </div>

                        <h5 style="color: #3d5a80; margin-top: 20px;">Problem Formulation:</h5>

                        <ol style="margin-left: 25px;">
                            <li style="margin: 15px 0;">
                                <strong>Initial State:</strong>
                                <p>Any valid arrangement of the 8 tiles and blank space on the 33 board. Represented as a 33 matrix or a string of 9 characters.</p>
                            </li>
                            <li style="margin: 15px 0;">
                                <strong>Goal State:</strong>
                                <p>A specific target arrangement, typically: 1, 2, 3, 8, blank, 4, 7, 6, 5 (reading left-to-right, top-to-bottom). Goal test checks if current state matches this configuration.</p>
                            </li>
                            <li style="margin: 15px 0;">
                                <strong>Actions/Operators:</strong>
                                <p>Four possible moves (depending on blank position):</p>
                                <ul style="margin-left: 20px;">
                                    <li>Move blank UP (swap with tile above)</li>
                                    <li>Move blank DOWN (swap with tile below)</li>
                                    <li>Move blank LEFT (swap with tile on left)</li>
                                    <li>Move blank RIGHT (swap with tile on right)</li>
                                </ul>
                                <p><em>Note: Not all moves are valid from every position (e.g., can't move UP if blank is in top row)</em></p>
                            </li>
                            <li style="margin: 15px 0;">
                                <strong>Path Cost Function:</strong>
                                <p>Each move has a cost of 1. Total path cost = number of moves taken from initial state to goal state. The objective is to minimize this cost.</p>
                            </li>
                            <li style="margin: 15px 0;">
                                <strong>State Space:</strong>
                                <ul style="margin-left: 20px;">
                                    <li>Total possible arrangements: 9! = 362,880</li>
                                    <li>Only half are reachable from any given state: 9!/2 = 181,440</li>
                                    <li>Branching factor: 2-4 (average  3)</li>
                                </ul>
                            </li>
                        </ol>

                        <h5 style="color: #3d5a80; margin-top: 20px;">Solution Characteristics:</h5>
                        <ul style="margin-left: 25px;">
                            <li><strong>Optimal Solution:</strong> The sequence of moves with minimum cost</li>
                            <li><strong>Solvability:</strong> Not all initial states are solvable; depends on inversion count</li>
                            <li><strong>Common Heuristics:</strong> Misplaced tiles count, Manhattan distance</li>
                        </ul>
                    </div>
                </div>

                <!-- Q3 - 8 Marks -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-question-circle"></i> Q3. Explain the Water Jug Problem with its state space representation. Provide a solution path. [8 Marks]</div>
                    <span class="marks-badge eight">8 MARKS</span>

                    <div style="background: white; padding: 25px; border-radius: 12px; margin-top: 15px; border: 2px solid #7c3aed;">
                        <h5 style="color: #5b21b6; margin-bottom: 15px;">MODEL ANSWER:</h5>

                        <p><strong>Problem Statement:</strong></p>
                        <p>Given two jugs - one with 4-liter capacity and another with 3-liter capacity - measure exactly 2 liters of water. There is an unlimited water supply and no measuring marks on the jugs.</p>

                        <h5 style="color: #3d5a80; margin-top: 20px;">Problem Formulation:</h5>

                        <ul style="margin-left: 25px;">
                            <li><strong>State Representation:</strong> (x, y) where x = water in 4L jug (0  x  4), y = water in 3L jug (0  y  3)</li>
                            <li><strong>Initial State:</strong> (0, 0) - both jugs empty</li>
                            <li><strong>Goal State:</strong> (2, n) - 4-liter jug contains exactly 2 liters (n can be any value)</li>
                        </ul>

                        <h5 style="color: #3d5a80; margin-top: 20px;">Production Rules (Operators):</h5>

                        <table style="width: 100%; margin: 15px 0; font-size: 0.95em;">
                            <tr><th>Rule</th><th>Condition</th><th>Action</th><th>New State</th></tr>
                            <tr><td>R1</td><td>x < 4</td><td>Fill 4L jug</td><td>(4, y)</td></tr>
                            <tr><td>R2</td><td>y < 3</td><td>Fill 3L jug</td><td>(x, 3)</td></tr>
                            <tr><td>R3</td><td>x > 0</td><td>Empty 4L jug</td><td>(0, y)</td></tr>
                            <tr><td>R4</td><td>y > 0</td><td>Empty 3L jug</td><td>(x, 0)</td></tr>
                            <tr><td>R5</td><td>x+y  4, y > 0</td><td>Pour 3L  4L until full</td><td>(4, y-(4-x))</td></tr>
                            <tr><td>R6</td><td>x+y  3, x > 0</td><td>Pour 4L  3L until full</td><td>(x-(3-y), 3)</td></tr>
                            <tr><td>R7</td><td>x+y  4, y > 0</td><td>Pour all from 3L  4L</td><td>(x+y, 0)</td></tr>
                            <tr><td>R8</td><td>x+y  3, x > 0</td><td>Pour all from 4L  3L</td><td>(0, x+y)</td></tr>
                        </table>

                        <h5 style="color: #3d5a80; margin-top: 20px;">Solution Path:</h5>

                        <table style="width: 100%; margin: 15px 0;">
                            <tr><th>Step</th><th>Rule Applied</th><th>Action</th><th>4L Jug (x)</th><th>3L Jug (y)</th></tr>
                            <tr><td>0</td><td>-</td><td>Initial State</td><td>0</td><td>0</td></tr>
                            <tr><td>1</td><td>R1</td><td>Fill 4-liter jug</td><td>4</td><td>0</td></tr>
                            <tr><td>2</td><td>R6</td><td>Pour from 4L to 3L jug</td><td>1</td><td>3</td></tr>
                            <tr><td>3</td><td>R4</td><td>Empty 3-liter jug</td><td>1</td><td>0</td></tr>
                            <tr><td>4</td><td>R8</td><td>Pour from 4L to 3L jug</td><td>0</td><td>1</td></tr>
                            <tr><td>5</td><td>R1</td><td>Fill 4-liter jug</td><td>4</td><td>1</td></tr>
                            <tr style="background: #dcfce7;"><td>6</td><td>R6</td><td>Pour from 4L to 3L jug</td><td><strong>2</strong></td><td>3</td></tr>
                        </table>

                        <p style="margin-top: 15px; padding: 15px; background: #f0f9ff; border-radius: 8px;"><strong>Result:</strong> Goal state (2, 3) achieved in 6 steps. The 4-liter jug now contains exactly 2 liters of water.</p>

                        <h5 style="color: #3d5a80; margin-top: 20px;">State Space Diagram (Partial):</h5>
                        <pre style="background: #f0f0f0; padding: 15px; border-radius: 8px; font-family: monospace;">
(0,0)  (4,0)  (1,3)  (1,0)  (0,1)  (4,1)  (2,3) 
   
 (0,3)  (3,0)  (3,3)  (4,2)  ...
                        </pre>
                    </div>
                </div>

                <!-- ========== STATE SPACE SEARCH - ANSWERS ========== -->
                <h3><i class="fas fa-project-diagram"></i>3. State Space Search - Model Answers</h3>

                <!-- Q1 - 4 Marks -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-question-circle"></i> Q1. Define state space. What are the four criteria used to measure search algorithm performance? [4 Marks]</div>
                    <span class="marks-badge four">4 MARKS</span>

                    <div style="background: white; padding: 25px; border-radius: 12px; margin-top: 15px; border: 2px solid #7c3aed;">
                        <h5 style="color: #5b21b6; margin-bottom: 15px;">MODEL ANSWER:</h5>

                        <p><strong>State Space Definition:</strong></p>
                        <p style="margin: 10px 0 20px 0;">State Space is a mathematical representation of a problem consisting of all possible configurations (states) that the system can be in. It is typically represented as a graph where nodes represent states and edges represent actions/operators that transform one state to another.</p>

                        <p><strong>Four Criteria for Measuring Search Algorithm Performance:</strong></p>

                        <ol style="margin-left: 25px; margin-top: 15px;">
                            <li style="margin: 12px 0;">
                                <strong>Completeness:</strong> Is the algorithm guaranteed to find a solution if one exists?
                                <br><em>A complete algorithm will always find a solution in finite time if the problem is solvable.</em>
                            </li>
                            <li style="margin: 12px 0;">
                                <strong>Optimality:</strong> Does the algorithm find the best (lowest cost) solution among all possible solutions?
                                <br><em>An optimal algorithm guarantees the solution with minimum path cost.</em>
                            </li>
                            <li style="margin: 12px 0;">
                                <strong>Time Complexity:</strong> How long does it take to find a solution? (measured in number of nodes generated/expanded)
                                <br><em>Usually expressed as O(b^d) where b=branching factor, d=depth.</em>
                            </li>
                            <li style="margin: 12px 0;">
                                <strong>Space Complexity:</strong> How much memory is required during the search process?
                                <br><em>Measured as maximum number of nodes stored in memory simultaneously.</em>
                            </li>
                        </ol>
                    </div>
                </div>

                <!-- Q2 - 4 Marks -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-question-circle"></i> Q2. Differentiate between uninformed and informed search strategies. [4 Marks]</div>
                    <span class="marks-badge four">4 MARKS</span>

                    <div style="background: white; padding: 25px; border-radius: 12px; margin-top: 15px; border: 2px solid #7c3aed;">
                        <h5 style="color: #5b21b6; margin-bottom: 15px;">MODEL ANSWER:</h5>

                        <table style="width: 100%; margin-top: 15px;">
                            <thead>
                                <tr>
                                    <th>Aspect</th>
                                    <th>Uninformed Search (Blind)</th>
                                    <th>Informed Search (Heuristic)</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Definition</strong></td>
                                    <td>Search without any domain-specific knowledge beyond problem definition</td>
                                    <td>Search using additional information (heuristics) to guide toward goal</td>
                                </tr>
                                <tr>
                                    <td><strong>Knowledge Used</strong></td>
                                    <td>Only knows how to generate successors and identify goal</td>
                                    <td>Uses heuristic function h(n) to estimate distance to goal</td>
                                </tr>
                                <tr>
                                    <td><strong>Efficiency</strong></td>
                                    <td>Less efficient; explores systematically without direction</td>
                                    <td>More efficient; focuses on promising paths</td>
                                </tr>
                                <tr>
                                    <td><strong>Examples</strong></td>
                                    <td>BFS, DFS, Uniform Cost Search, Iterative Deepening</td>
                                    <td>Greedy Best-First, A*, Hill Climbing, AO*</td>
                                </tr>
                                <tr>
                                    <td><strong>Analogy</strong></td>
                                    <td>Finding way in dark room - explore systematically</td>
                                    <td>Using compass - have guidance toward destination</td>
                                </tr>
                            </tbody>
                        </table>

                        <p style="margin-top: 15px;"><strong>Key Insight:</strong> Informed search can dramatically reduce search time by avoiding unpromising paths, but requires a good heuristic function that is domain-specific.</p>
                    </div>
                </div>

                <!-- ========== BLIND SEARCH - ANSWERS ========== -->
                <h3><i class="fas fa-eye-slash"></i>4. Blind Search - Model Answers</h3>

                <!-- Q1 - 4 Marks -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-question-circle"></i> Q1. What is Blind Search? List its characteristics. [4 Marks]</div>
                    <span class="marks-badge four">4 MARKS</span>

                    <div style="background: white; padding: 25px; border-radius: 12px; margin-top: 15px; border: 2px solid #7c3aed;">
                        <h5 style="color: #5b21b6; margin-bottom: 15px;">MODEL ANSWER:</h5>

                        <p><strong>Definition:</strong></p>
                        <p style="margin: 10px 0 20px 0;">Blind Search (Uninformed Search) refers to search strategies that have no additional information about states beyond the problem definition. These algorithms can only generate successors and distinguish goal states from non-goal states, without knowing which non-goal state is closer to the goal.</p>

                        <p><strong>Characteristics of Blind Search:</strong></p>
                        <ol style="margin-left: 25px;">
                            <li style="margin: 10px 0;"><strong>No Domain Knowledge:</strong> Does not use any problem-specific information to guide search</li>
                            <li style="margin: 10px 0;"><strong>Systematic Exploration:</strong> Explores state space in a fixed, predetermined order</li>
                            <li style="margin: 10px 0;"><strong>Cannot Estimate Distance:</strong> Has no way to judge how far current state is from goal</li>
                            <li style="margin: 10px 0;"><strong>Fixed Successor Generation:</strong> Generates successors without prioritization</li>
                            <li style="margin: 10px 0;"><strong>Complete (usually):</strong> Guarantees finding solution if one exists (in finite spaces)</li>
                            <li style="margin: 10px 0;"><strong>May Be Inefficient:</strong> Can explore many unnecessary states</li>
                        </ol>

                        <p style="margin-top: 15px;"><strong>Examples:</strong> BFS, DFS, Uniform Cost Search, Depth-Limited Search, Iterative Deepening DFS</p>
                    </div>
                </div>

                <!-- Q2 - 4 Marks -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-question-circle"></i> Q2. Explain the BFS algorithm with its time and space complexity. [4 Marks]</div>
                    <span class="marks-badge four">4 MARKS</span>

                    <div style="background: white; padding: 25px; border-radius: 12px; margin-top: 15px; border: 2px solid #7c3aed;">
                        <h5 style="color: #5b21b6; margin-bottom: 15px;">MODEL ANSWER:</h5>

                        <p><strong>Breadth-First Search (BFS):</strong></p>
                        <p style="margin: 10px 0;">BFS is a search algorithm that explores all nodes at the current depth level before moving to nodes at the next depth level. It uses a FIFO (First-In-First-Out) queue data structure.</p>

                        <p><strong>Algorithm Steps:</strong></p>
                        <ol style="margin-left: 25px;">
                            <li>Initialize queue with start node</li>
                            <li>Remove front node from queue</li>
                            <li>If goal, return success with solution path</li>
                            <li>Else, add all unvisited children to rear of queue</li>
                            <li>Repeat until goal found or queue empty</li>
                        </ol>

                        <p style="margin-top: 15px;"><strong>Complexity Analysis:</strong></p>
                        <ul style="margin-left: 25px;">
                            <li><strong>Time Complexity: O(b<sup>d</sup>)</strong> - where b = branching factor, d = depth of solution</li>
                            <li><strong>Space Complexity: O(b<sup>d</sup>)</strong> - stores all nodes at current level in queue</li>
                        </ul>

                        <p style="margin-top: 15px;"><strong>Properties:</strong></p>
                        <ul style="margin-left: 25px;">
                            <li><strong>Complete:</strong> Yes (if branching factor is finite)</li>
                            <li><strong>Optimal:</strong> Yes (when all step costs are equal)</li>
                        </ul>
                    </div>
                </div>

                <!-- Q3 - 4 Marks -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-question-circle"></i> Q3. Explain the DFS algorithm. State its advantages and disadvantages. [4 Marks]</div>
                    <span class="marks-badge four">4 MARKS</span>

                    <div style="background: white; padding: 25px; border-radius: 12px; margin-top: 15px; border: 2px solid #7c3aed;">
                        <h5 style="color: #5b21b6; margin-bottom: 15px;">MODEL ANSWER:</h5>

                        <p><strong>Depth-First Search (DFS):</strong></p>
                        <p style="margin: 10px 0;">DFS is a search algorithm that explores as far as possible along each branch before backtracking. It uses a LIFO (Last-In-First-Out) stack data structure or recursion.</p>

                        <p><strong>Algorithm Steps:</strong></p>
                        <ol style="margin-left: 25px;">
                            <li>Push start node onto stack</li>
                            <li>Pop top node from stack</li>
                            <li>If goal, return success</li>
                            <li>Else, push all unvisited children onto stack</li>
                            <li>Repeat until goal found or stack empty</li>
                        </ol>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                            <div style="background: #dcfce7; padding: 15px; border-radius: 8px;">
                                <strong style="color: #166534;">Advantages:</strong>
                                <ul style="margin-left: 15px; margin-top: 10px;">
                                    <li>Low memory: O(bm)</li>
                                    <li>Fast for deep solutions</li>
                                    <li>Simple implementation</li>
                                </ul>
                            </div>
                            <div style="background: #fee2e2; padding: 15px; border-radius: 8px;">
                                <strong style="color: #991b1b;">Disadvantages:</strong>
                                <ul style="margin-left: 15px; margin-top: 10px;">
                                    <li>Not complete (infinite paths)</li>
                                    <li>Not optimal</li>
                                    <li>May go very deep unnecessarily</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Q4 - 8 Marks -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-question-circle"></i> Q4. Compare and contrast BFS and DFS with respect to data structure, completeness, optimality, time complexity, and space complexity. [8 Marks]</div>
                    <span class="marks-badge eight">8 MARKS</span>

                    <div style="background: white; padding: 25px; border-radius: 12px; margin-top: 15px; border: 2px solid #7c3aed;">
                        <h5 style="color: #5b21b6; margin-bottom: 15px;">MODEL ANSWER:</h5>

                        <p><strong>Introduction:</strong> BFS and DFS are two fundamental uninformed search strategies with contrasting approaches to exploring the state space.</p>

                        <h5 style="color: #3d5a80; margin-top: 20px;">Comprehensive Comparison:</h5>

                        <table style="width: 100%; margin: 15px 0;">
                            <thead>
                                <tr>
                                    <th>Aspect</th>
                                    <th>BFS (Breadth-First)</th>
                                    <th>DFS (Depth-First)</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Data Structure</strong></td>
                                    <td>Queue (FIFO - First In First Out)</td>
                                    <td>Stack (LIFO - Last In First Out)</td>
                                </tr>
                                <tr>
                                    <td><strong>Exploration Strategy</strong></td>
                                    <td>Level by level (horizontal)</td>
                                    <td>Path by path (vertical)</td>
                                </tr>
                                <tr>
                                    <td><strong>Completeness</strong></td>
                                    <td><span style="color: green;"> Yes</span> (finite branching factor)</td>
                                    <td><span style="color: red;"> No</span> (may get stuck in infinite paths)</td>
                                </tr>
                                <tr>
                                    <td><strong>Optimality</strong></td>
                                    <td><span style="color: green;"> Yes</span> (if all costs equal)</td>
                                    <td><span style="color: red;"> No</span> (may find longer path first)</td>
                                </tr>
                                <tr>
                                    <td><strong>Time Complexity</strong></td>
                                    <td>O(b<sup>d</sup>) where d = solution depth</td>
                                    <td>O(b<sup>m</sup>) where m = max depth</td>
                                </tr>
                                <tr>
                                    <td><strong>Space Complexity</strong></td>
                                    <td>O(b<sup>d</sup>) - High (stores entire level)</td>
                                    <td>O(bm) - Low (stores single path)</td>
                                </tr>
                                <tr>
                                    <td><strong>Memory Usage</strong></td>
                                    <td>Very high (exponential)</td>
                                    <td>Low (linear in depth)</td>
                                </tr>
                                <tr>
                                    <td><strong>Best For</strong></td>
                                    <td>Shallow solutions, shortest path needed</td>
                                    <td>Deep solutions, memory constraints</td>
                                </tr>
                            </tbody>
                        </table>

                        <h5 style="color: #3d5a80; margin-top: 20px;">Visual Comparison:</h5>
                        <div style="display: flex; justify-content: space-around; margin: 15px 0; flex-wrap: wrap; gap: 20px;">
                            <div style="text-align: center; padding: 15px; background: #dbeafe; border-radius: 8px;">
                                <strong>BFS Exploration Order</strong>
                                <pre style="font-family: monospace; margin-top: 10px;">
    1
   / \
  2   3      Visits: 1,2,3,4,5,6,7
 / \ / \
4  5 6  7</pre>
                            </div>
                            <div style="text-align: center; padding: 15px; background: #fef3c7; border-radius: 8px;">
                                <strong>DFS Exploration Order</strong>
                                <pre style="font-family: monospace; margin-top: 10px;">
    1
   / \
  2   3      Visits: 1,2,4,5,3,6,7
 / \ / \
4  5 6  7</pre>
                            </div>
                        </div>

                        <h5 style="color: #3d5a80; margin-top: 20px;">When to Use Each:</h5>
                        <ul style="margin-left: 25px;">
                            <li><strong>Use BFS when:</strong> Optimal solution required, solution is shallow, memory is not constrained</li>
                            <li><strong>Use DFS when:</strong> Memory is limited, solution is deep, any solution is acceptable (not necessarily optimal)</li>
                        </ul>

                        <p style="margin-top: 15px; padding: 15px; background: #f0f9ff; border-radius: 8px;"><strong>Conclusion:</strong> BFS guarantees optimal solutions but requires more memory. DFS is memory-efficient but may not find the best solution. The choice depends on problem characteristics and resource constraints.</p>
                    </div>
                </div>

                <!-- Q5 - 8 Marks -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-question-circle"></i> Q5. Apply BFS and DFS to the following graph. Show the order of node expansion for both. (AG is the goal) [8 Marks]</div>
                    <span class="marks-badge eight">8 MARKS</span>

                    <div style="background: white; padding: 25px; border-radius: 12px; margin-top: 15px; border: 2px solid #7c3aed;">
                        <h5 style="color: #5b21b6; margin-bottom: 15px;">MODEL ANSWER:</h5>

                        <p><strong>Given Graph:</strong></p>
                        <pre style="background: #f0f0f0; padding: 15px; border-radius: 8px; font-family: monospace;">
        A (Start)
       / \
      B   C
     / \   \
    D   E   F
         \
          G (Goal)
                        </pre>

                        <h5 style="color: #3d5a80; margin-top: 25px;">BFS Solution:</h5>
                        <p><strong>Data Structure:</strong> Queue (FIFO)</p>

                        <table style="width: 100%; margin: 15px 0; font-size: 0.95em;">
                            <tr><th>Step</th><th>Current Node</th><th>Queue (after expansion)</th><th>Visited</th></tr>
                            <tr><td>1</td><td>A</td><td>[B, C]</td><td>{A}</td></tr>
                            <tr><td>2</td><td>B</td><td>[C, D, E]</td><td>{A, B}</td></tr>
                            <tr><td>3</td><td>C</td><td>[D, E, F]</td><td>{A, B, C}</td></tr>
                            <tr><td>4</td><td>D</td><td>[E, F]</td><td>{A, B, C, D}</td></tr>
                            <tr><td>5</td><td>E</td><td>[F, G]</td><td>{A, B, C, D, E}</td></tr>
                            <tr><td>6</td><td>F</td><td>[G]</td><td>{A, B, C, D, E, F}</td></tr>
                            <tr style="background: #dcfce7;"><td>7</td><td>G</td><td>Goal Found!</td><td>{A, B, C, D, E, F, G}</td></tr>
                        </table>

                        <p><strong>BFS Traversal Order:</strong> A  B  C  D  E  F  G</p>
                        <p><strong>Solution Path:</strong> A  B  E  G (found at depth 3)</p>

                        <h5 style="color: #3d5a80; margin-top: 25px;">DFS Solution:</h5>
                        <p><strong>Data Structure:</strong> Stack (LIFO)</p>

                        <table style="width: 100%; margin: 15px 0; font-size: 0.95em;">
                            <tr><th>Step</th><th>Current Node</th><th>Stack (after expansion)</th><th>Visited</th></tr>
                            <tr><td>1</td><td>A</td><td>[C, B]</td><td>{A}</td></tr>
                            <tr><td>2</td><td>B</td><td>[C, E, D]</td><td>{A, B}</td></tr>
                            <tr><td>3</td><td>D</td><td>[C, E]</td><td>{A, B, D}</td></tr>
                            <tr><td>4</td><td>E</td><td>[C, G]</td><td>{A, B, D, E}</td></tr>
                            <tr style="background: #dcfce7;"><td>5</td><td>G</td><td>Goal Found!</td><td>{A, B, D, E, G}</td></tr>
                        </table>

                        <p><strong>DFS Traversal Order:</strong> A  B  D  E  G</p>
                        <p><strong>Solution Path:</strong> A  B  E  G</p>

                        <h5 style="color: #3d5a80; margin-top: 25px;">Comparison of Results:</h5>
                        <table style="width: 100%; margin: 15px 0;">
                            <tr><th>Metric</th><th>BFS</th><th>DFS</th></tr>
                            <tr><td>Nodes Expanded</td><td>7</td><td>5</td></tr>
                            <tr><td>Solution Found</td><td>Yes</td><td>Yes</td></tr>
                            <tr><td>Path Length</td><td>3</td><td>3</td></tr>
                            <tr><td>Optimal</td><td>Yes</td><td>Yes (in this case)</td></tr>
                        </table>

                        <p style="padding: 15px; background: #f0f9ff; border-radius: 8px;"><strong>Note:</strong> In this example, both found the same path. However, BFS is guaranteed to find the shortest path, while DFS found it by chance. In other graphs, DFS might find a longer path first.</p>
                    </div>
                </div>

                <!-- ========== INFORMED SEARCH - ANSWERS ========== -->
                <h3><i class="fas fa-lightbulb"></i>5. Informed Search - Model Answers</h3>

                <!-- Q1 - 4 Marks -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-question-circle"></i> Q1. What is a heuristic function? Explain admissible and consistent heuristics. [4 Marks]</div>
                    <span class="marks-badge four">4 MARKS</span>

                    <div style="background: white; padding: 25px; border-radius: 12px; margin-top: 15px; border: 2px solid #7c3aed;">
                        <h5 style="color: #5b21b6; margin-bottom: 15px;">MODEL ANSWER:</h5>

                        <p><strong>Heuristic Function:</strong></p>
                        <p style="margin: 10px 0 20px 0;">A heuristic function h(n) is an estimate of the cost from node n to the goal. It provides problem-specific knowledge to guide search toward the goal more efficiently. Properties: h(n)  0 for all nodes, and h(goal) = 0.</p>

                        <p><strong>Admissible Heuristic:</strong></p>
                        <ul style="margin-left: 25px; margin-bottom: 15px;">
                            <li><strong>Definition:</strong> A heuristic is admissible if it <u>never overestimates</u> the true cost to reach the goal</li>
                            <li><strong>Condition:</strong> h(n)  h*(n) for all nodes, where h*(n) is the actual cost</li>
                            <li><strong>Importance:</strong> Guarantees A* will find optimal solution</li>
                            <li><strong>Example:</strong> Straight-line distance is admissible for road navigation (can't be shorter than straight line)</li>
                        </ul>

                        <p><strong>Consistent (Monotonic) Heuristic:</strong></p>
                        <ul style="margin-left: 25px;">
                            <li><strong>Definition:</strong> A heuristic is consistent if it satisfies the triangle inequality</li>
                            <li><strong>Condition:</strong> h(n)  c(n, a, n') + h(n') for all nodes n and successors n'</li>
                            <li><strong>Meaning:</strong> Estimated cost from n is  cost to reach n' plus estimated cost from n'</li>
                            <li><strong>Importance:</strong> Ensures f(n) values are non-decreasing along any path; every consistent heuristic is also admissible</li>
                        </ul>
                    </div>
                </div>

                <!-- Q2 - 4 Marks -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-question-circle"></i> Q2. Explain Hill Climbing search. What are its limitations? [4 Marks]</div>
                    <span class="marks-badge four">4 MARKS</span>

                    <div style="background: white; padding: 25px; border-radius: 12px; margin-top: 15px; border: 2px solid #7c3aed;">
                        <h5 style="color: #5b21b6; margin-bottom: 15px;">MODEL ANSWER:</h5>

                        <p><strong>Hill Climbing Search:</strong></p>
                        <p style="margin: 10px 0;">Hill Climbing is a local search algorithm that continuously moves toward increasing value (or decreasing cost). It's called "hill climbing" because it's like climbing a hill in fog - you can only see your immediate surroundings and always move upward.</p>

                        <p><strong>Algorithm:</strong></p>
                        <ol style="margin-left: 25px;">
                            <li>Start with initial state (current)</li>
                            <li>Generate all neighbors of current state</li>
                            <li>If best neighbor is better than current, move to it</li>
                            <li>Repeat until no neighbor is better (local optimum reached)</li>
                        </ol>

                        <p style="margin-top: 15px;"><strong>Limitations (Problems):</strong></p>
                        <ol style="margin-left: 25px;">
                            <li style="margin: 10px 0;"><strong>Local Maximum:</strong> A peak that is not the global maximum. The algorithm gets stuck thinking it has reached the best solution when a better one exists elsewhere.</li>
                            <li style="margin: 10px 0;"><strong>Plateau (Flat Maximum):</strong> A flat region where all neighbors have equal value. The algorithm cannot determine which direction to move and may wander aimlessly or stop.</li>
                            <li style="margin: 10px 0;"><strong>Ridge:</strong> A narrow elevated path where movement in any single direction goes downhill, but a sequence of moves in different directions could lead upward.</li>
                        </ol>

                        <p style="margin-top: 15px;"><strong>Solutions:</strong> Random restart, Simulated annealing, Stochastic hill climbing, allowing sideways moves</p>
                    </div>
                </div>

                <!-- ========== A* AND AO* - ANSWERS ========== -->
                <h3><i class="fas fa-star"></i>6. A* and AO* Search - Model Answers</h3>

                <!-- Q1 - 4 Marks -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-question-circle"></i> Q1. Write the evaluation function of A* algorithm. When is A* optimal and complete? [4 Marks]</div>
                    <span class="marks-badge four">4 MARKS</span>

                    <div style="background: white; padding: 25px; border-radius: 12px; margin-top: 15px; border: 2px solid #7c3aed;">
                        <h5 style="color: #5b21b6; margin-bottom: 15px;">MODEL ANSWER:</h5>

                        <p><strong>A* Evaluation Function:</strong></p>
                        <div style="background: #f0f0f0; padding: 20px; border-radius: 8px; text-align: center; margin: 15px 0; font-size: 1.3em;">
                            <strong>f(n) = g(n) + h(n)</strong>
                        </div>

                        <p>Where:</p>
                        <ul style="margin-left: 25px;">
                            <li><strong>f(n):</strong> Estimated total cost of path through node n to goal</li>
                            <li><strong>g(n):</strong> Actual cost from start node to current node n (known, computed)</li>
                            <li><strong>h(n):</strong> Estimated cost from node n to goal (heuristic estimate)</li>
                        </ul>

                        <p style="margin-top: 20px;"><strong>When is A* Complete?</strong></p>
                        <p>A* is complete (guaranteed to find a solution if one exists) when:</p>
                        <ul style="margin-left: 25px;">
                            <li>Branching factor b is finite</li>
                            <li>Every action has cost   (some small positive constant)</li>
                        </ul>

                        <p style="margin-top: 15px;"><strong>When is A* Optimal?</strong></p>
                        <p>A* is optimal (finds the lowest-cost solution) when:</p>
                        <ul style="margin-left: 25px;">
                            <li>The heuristic h(n) is <strong>admissible</strong> (never overestimates true cost)</li>
                            <li>For graph search: h(n) should also be <strong>consistent</strong> (monotonic)</li>
                        </ul>
                    </div>
                </div>

                <!-- Q2 - 4 Marks -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-question-circle"></i> Q2. Differentiate between A* and AO* algorithms. [4 Marks]</div>
                    <span class="marks-badge four">4 MARKS</span>

                    <div style="background: white; padding: 25px; border-radius: 12px; margin-top: 15px; border: 2px solid #7c3aed;">
                        <h5 style="color: #5b21b6; margin-bottom: 15px;">MODEL ANSWER:</h5>

                        <table style="width: 100%; margin-top: 15px;">
                            <thead>
                                <tr>
                                    <th>Aspect</th>
                                    <th>A* Algorithm</th>
                                    <th>AO* Algorithm</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Graph Type</strong></td>
                                    <td>OR graphs (single solution path)</td>
                                    <td>AND-OR graphs (solution graph/tree)</td>
                                </tr>
                                <tr>
                                    <td><strong>Node Types</strong></td>
                                    <td>Only OR nodes (choose one path)</td>
                                    <td>Both AND nodes (solve all) and OR nodes (choose one)</td>
                                </tr>
                                <tr>
                                    <td><strong>Solution</strong></td>
                                    <td>Single optimal path from start to goal</td>
                                    <td>Solution graph containing multiple paths</td>
                                </tr>
                                <tr>
                                    <td><strong>Cost Calculation</strong></td>
                                    <td>f(n) = g(n) + h(n)</td>
                                    <td>OR: min of children; AND: sum of children</td>
                                </tr>
                                <tr>
                                    <td><strong>Use Cases</strong></td>
                                    <td>Pathfinding, navigation, puzzles</td>
                                    <td>Planning, problem decomposition, theorem proving</td>
                                </tr>
                                <tr>
                                    <td><strong>Complexity</strong></td>
                                    <td>Simpler implementation</td>
                                    <td>More complex due to AND-OR handling</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Q3 - 8 Marks -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-question-circle"></i> Q3. Explain A* search algorithm with its properties. Solve a given problem using A*. [8 Marks]</div>
                    <span class="marks-badge eight">8 MARKS</span>

                    <div style="background: white; padding: 25px; border-radius: 12px; margin-top: 15px; border: 2px solid #7c3aed;">
                        <h5 style="color: #5b21b6; margin-bottom: 15px;">MODEL ANSWER:</h5>

                        <p><strong>A* Search Algorithm:</strong></p>
                        <p>A* is the most widely-used informed search algorithm that combines the cost to reach a node with the estimated cost to the goal, ensuring optimal solutions.</p>

                        <p><strong>Evaluation Function:</strong> f(n) = g(n) + h(n)</p>

                        <p style="margin-top: 15px;"><strong>Algorithm Steps:</strong></p>
                        <ol style="margin-left: 25px;">
                            <li>Initialize OPEN list with start node (f = h(start))</li>
                            <li>Initialize CLOSED list as empty</li>
                            <li>While OPEN is not empty:
                                <ul style="margin-left: 20px;">
                                    <li>Remove node n with lowest f(n) from OPEN</li>
                                    <li>If n is goal, return solution path</li>
                                    <li>Add n to CLOSED</li>
                                    <li>For each successor s of n:
                                        <ul style="margin-left: 20px;">
                                            <li>Calculate g(s) = g(n) + cost(n,s)</li>
                                            <li>If s not in OPEN or CLOSED, or new g is better, update and add to OPEN</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li>If OPEN is empty, return failure</li>
                        </ol>

                        <p style="margin-top: 20px;"><strong>Properties of A*:</strong></p>
                        <ul style="margin-left: 25px;">
                            <li><strong>Complete:</strong> Yes (if b is finite and costs  )</li>
                            <li><strong>Optimal:</strong> Yes (if h is admissible)</li>
                            <li><strong>Time Complexity:</strong> O(b^d) - exponential</li>
                            <li><strong>Space Complexity:</strong> O(b^d) - keeps all nodes in memory</li>
                        </ul>

                        <h5 style="color: #3d5a80; margin-top: 25px;">Example Problem: Find shortest path from S to G</h5>

                        <pre style="background: #f0f0f0; padding: 15px; border-radius: 8px; font-family: monospace;">
Graph with costs:        Heuristic h(n):
    S --3-- A            S: 7
    |       |            A: 5
    4       2            B: 4
    |       |            C: 2
    B --1-- C --3-- G    G: 0
                        </pre>

                        <p><strong>A* Execution:</strong></p>

                        <table style="width: 100%; margin: 15px 0; font-size: 0.9em;">
                            <tr><th>Step</th><th>OPEN (node: f=g+h)</th><th>Selected</th><th>CLOSED</th></tr>
                            <tr><td>1</td><td>S: 0+7=7</td><td>S</td><td>{}</td></tr>
                            <tr><td>2</td><td>A: 3+5=8, B: 4+4=8</td><td>A (or B)</td><td>{S}</td></tr>
                            <tr><td>3</td><td>B: 8, C: 5+2=7</td><td>C</td><td>{S, A}</td></tr>
                            <tr><td>4</td><td>B: 8, G: 8+0=8</td><td>B</td><td>{S, A, C}</td></tr>
                            <tr><td>5</td><td>G: 8, C via B: 6+2=8</td><td>G</td><td>{S, A, C, B}</td></tr>
                        </table>

                        <p><strong>Optimal Path:</strong> S  A  C  G with cost = 3 + 2 + 3 = 8</p>
                    </div>
                </div>

                <!-- ========== GAME TREES - ANSWERS ========== -->
                <h3><i class="fas fa-gamepad"></i>7. Game Trees - Model Answers</h3>

                <!-- Q1 - 4 Marks -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-question-circle"></i> Q1. What is a game tree? Explain MAX and MIN nodes. [4 Marks]</div>
                    <span class="marks-badge four">4 MARKS</span>

                    <div style="background: white; padding: 25px; border-radius: 12px; margin-top: 15px; border: 2px solid #7c3aed;">
                        <h5 style="color: #5b21b6; margin-bottom: 15px;">MODEL ANSWER:</h5>

                        <p><strong>Game Tree:</strong></p>
                        <p style="margin: 10px 0;">A game tree is a tree structure that represents all possible moves and counter-moves in a two-player game from a given position. Each node represents a game state, edges represent possible moves, and leaf nodes represent terminal states (game over).</p>

                        <p style="margin-top: 15px;"><strong>MAX Nodes:</strong></p>
                        <ul style="margin-left: 25px;">
                            <li>Represent the AI player's turn (our side)</li>
                            <li>Goal: Maximize the game value/utility</li>
                            <li>At MAX nodes, we choose the move with highest value among children</li>
                            <li>Usually shown at even levels (0, 2, 4...)</li>
                        </ul>

                        <p style="margin-top: 15px;"><strong>MIN Nodes:</strong></p>
                        <ul style="margin-left: 25px;">
                            <li>Represent the opponent's turn</li>
                            <li>Goal: Minimize the game value (from MAX's perspective)</li>
                            <li>At MIN nodes, opponent chooses the move with lowest value</li>
                            <li>Usually shown at odd levels (1, 3, 5...)</li>
                        </ul>

                        <pre style="background: #f0f0f0; padding: 15px; border-radius: 8px; font-family: monospace; margin-top: 15px;">
    MAX (Level 0)      Our turn: choose max
       / \
    MIN   MIN          Opponent: chooses min
   / \   / \
  3   5 2   8          Terminal values
                        </pre>
                    </div>
                </div>

                <!-- ========== MINIMAX - ANSWERS ========== -->
                <h3><i class="fas fa-chess"></i>8. Minimax Algorithm - Model Answers</h3>

                <!-- Q1 - 4 Marks -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-question-circle"></i> Q1. Explain the Minimax algorithm with its properties. [4 Marks]</div>
                    <span class="marks-badge four">4 MARKS</span>

                    <div style="background: white; padding: 25px; border-radius: 12px; margin-top: 15px; border: 2px solid #7c3aed;">
                        <h5 style="color: #5b21b6; margin-bottom: 15px;">MODEL ANSWER:</h5>

                        <p><strong>Minimax Algorithm:</strong></p>
                        <p style="margin: 10px 0;">Minimax is a decision-making algorithm for two-player zero-sum games. It finds the optimal move by assuming both players play optimally - MAX tries to maximize the score while MIN tries to minimize it.</p>

                        <p><strong>Working Principle:</strong></p>
                        <ul style="margin-left: 25px;">
                            <li>At terminal nodes: return utility value</li>
                            <li>At MAX nodes: return maximum of children's values</li>
                            <li>At MIN nodes: return minimum of children's values</li>
                            <li>Propagate values from leaves to root</li>
                        </ul>

                        <p style="margin-top: 15px;"><strong>Properties:</strong></p>
                        <table style="width: 100%; margin: 10px 0;">
                            <tr><td><strong>Complete:</strong></td><td>Yes (if tree is finite)</td></tr>
                            <tr><td><strong>Optimal:</strong></td><td>Yes (against optimal opponent)</td></tr>
                            <tr><td><strong>Time Complexity:</strong></td><td>O(b<sup>m</sup>) where b=branching factor, m=depth</td></tr>
                            <tr><td><strong>Space Complexity:</strong></td><td>O(bm) for DFS implementation</td></tr>
                        </table>
                    </div>
                </div>

                <!-- Q2 - 8 Marks -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-question-circle"></i> Q2. Apply the Minimax algorithm to the following game tree and find the optimal move for MAX. [8 Marks]</div>
                    <span class="marks-badge eight">8 MARKS</span>

                    <div style="background: white; padding: 25px; border-radius: 12px; margin-top: 15px; border: 2px solid #7c3aed;">
                        <h5 style="color: #5b21b6; margin-bottom: 15px;">MODEL ANSWER:</h5>

                        <p><strong>Given Game Tree:</strong></p>
                        <pre style="background: #f0f0f0; padding: 15px; border-radius: 8px; font-family: monospace;">
                MAX (A)
              /        \
          MIN (B)      MIN (C)
          /   \        /   \
      MAX(D) MAX(E)  MAX(F) MAX(G)
       /\     /\      /\     /\
      3  5   6  9    1  2   0  -1
                        </pre>

                        <h5 style="color: #3d5a80; margin-top: 20px;">Step-by-Step Solution:</h5>

                        <p><strong>Step 1: Evaluate leaf nodes</strong></p>
                        <p>Terminal values are already given: 3, 5, 6, 9, 1, 2, 0, -1</p>

                        <p style="margin-top: 15px;"><strong>Step 2: Calculate MAX nodes (D, E, F, G)</strong></p>
                        <ul style="margin-left: 25px;">
                            <li>D = max(3, 5) = <strong>5</strong></li>
                            <li>E = max(6, 9) = <strong>9</strong></li>
                            <li>F = max(1, 2) = <strong>2</strong></li>
                            <li>G = max(0, -1) = <strong>0</strong></li>
                        </ul>

                        <p style="margin-top: 15px;"><strong>Step 3: Calculate MIN nodes (B, C)</strong></p>
                        <ul style="margin-left: 25px;">
                            <li>B = min(5, 9) = <strong>5</strong></li>
                            <li>C = min(2, 0) = <strong>0</strong></li>
                        </ul>

                        <p style="margin-top: 15px;"><strong>Step 4: Calculate root MAX node (A)</strong></p>
                        <ul style="margin-left: 25px;">
                            <li>A = max(5, 0) = <strong>5</strong></li>
                        </ul>

                        <p><strong>Final Tree with Values:</strong></p>
                        <pre style="background: #dcfce7; padding: 15px; border-radius: 8px; font-family: monospace;">
                MAX (A) = 5
              /            \
          MIN (B)=5      MIN (C)=0
          /     \        /      \
      MAX(D)=5 MAX(E)=9 MAX(F)=2 MAX(G)=0
       /\       /\       /\       /\
      3  5     6  9     1  2     0  -1
                        </pre>

                        <p style="margin-top: 15px; padding: 15px; background: #dbeafe; border-radius: 8px;">
                            <strong>Optimal Move:</strong> MAX should choose the left branch (to node B)<br>
                            <strong>Minimax Value:</strong> 5<br>
                            <strong>Reasoning:</strong> Going left gives guaranteed value of 5, while going right gives only 0
                        </p>
                    </div>
                </div>

                <!-- ========== ALPHA-BETA - ANSWERS ========== -->
                <h3><i class="fas fa-cut"></i>9. Alpha-Beta Pruning - Model Answers</h3>

                <!-- Q1 - 4 Marks -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-question-circle"></i> Q1. What is Alpha-Beta pruning? Define alpha and beta values. [4 Marks]</div>
                    <span class="marks-badge four">4 MARKS</span>

                    <div style="background: white; padding: 25px; border-radius: 12px; margin-top: 15px; border: 2px solid #7c3aed;">
                        <h5 style="color: #5b21b6; margin-bottom: 15px;">MODEL ANSWER:</h5>

                        <p><strong>Alpha-Beta Pruning:</strong></p>
                        <p style="margin: 10px 0;">Alpha-Beta pruning is an optimization technique for the Minimax algorithm that eliminates branches in the game tree which cannot possibly affect the final decision. It reduces the number of nodes evaluated without changing the result.</p>

                        <p style="margin-top: 15px;"><strong>Alpha () Value:</strong></p>
                        <ul style="margin-left: 25px;">
                            <li>The best (highest) value that MAX can guarantee so far</li>
                            <li>Represents MAX's lower bound on the final value</li>
                            <li>Initialized to -</li>
                            <li>Updated at MAX nodes:  = max(, value of child)</li>
                        </ul>

                        <p style="margin-top: 15px;"><strong>Beta () Value:</strong></p>
                        <ul style="margin-left: 25px;">
                            <li>The best (lowest) value that MIN can guarantee so far</li>
                            <li>Represents MIN's upper bound on the final value</li>
                            <li>Initialized to +</li>
                            <li>Updated at MIN nodes:  = min(, value of child)</li>
                        </ul>

                        <p style="margin-top: 15px;"><strong>Pruning Condition:</strong></p>
                        <p style="margin-left: 25px;">Prune remaining children when <strong>  </strong></p>
                        <ul style="margin-left: 25px;">
                            <li>At MAX node: prune if    (beta cutoff)</li>
                            <li>At MIN node: prune if    (alpha cutoff)</li>
                        </ul>
                    </div>
                </div>

                <!-- Q3 - 8 Marks -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-question-circle"></i> Q3. Explain Alpha-Beta pruning algorithm. Apply it to a game tree and show which nodes are pruned. [8 Marks]</div>
                    <span class="marks-badge eight">8 MARKS</span>

                    <div style="background: white; padding: 25px; border-radius: 12px; margin-top: 15px; border: 2px solid #7c3aed;">
                        <h5 style="color: #5b21b6; margin-bottom: 15px;">MODEL ANSWER:</h5>

                        <p><strong>Alpha-Beta Pruning Algorithm:</strong></p>
                        <ol style="margin-left: 25px;">
                            <li>Initialize  = -,  = +</li>
                            <li>At MAX node: for each child, compute value; update  = max(, value); if   , prune remaining</li>
                            <li>At MIN node: for each child, compute value; update  = min(, value); if   , prune remaining</li>
                            <li>Pass  and  to children during recursion</li>
                        </ol>

                        <p style="margin-top: 20px;"><strong>Given Game Tree:</strong></p>
                        <pre style="background: #f0f0f0; padding: 15px; border-radius: 8px; font-family: monospace;">
                MAX (A)
              /        \
          MIN (B)      MIN (C)
          /   \        /   \
         3     5      2     9
                        </pre>

                        <h5 style="color: #3d5a80; margin-top: 20px;">Step-by-Step Execution:</h5>

                        <table style="width: 100%; margin: 15px 0; font-size: 0.95em;">
                            <tr><th>Step</th><th>Node</th><th>Action</th><th></th><th></th><th>Result</th></tr>
                            <tr><td>1</td><td>A (MAX)</td><td>Start, go to B</td><td>-</td><td>+</td><td>-</td></tr>
                            <tr><td>2</td><td>B (MIN)</td><td>Evaluate child 3</td><td>-</td><td>+</td><td> = min(, 3) = 3</td></tr>
                            <tr><td>3</td><td>B (MIN)</td><td>Evaluate child 5</td><td>-</td><td>3</td><td> = min(3, 5) = 3</td></tr>
                            <tr><td>4</td><td>B (MIN)</td><td>Return to A</td><td>-</td><td>3</td><td>B value = 3</td></tr>
                            <tr><td>5</td><td>A (MAX)</td><td>Update </td><td>3</td><td>+</td><td> = max(-, 3) = 3</td></tr>
                            <tr><td>6</td><td>C (MIN)</td><td>Evaluate child 2</td><td>3</td><td>+</td><td> = min(, 2) = 2</td></tr>
                            <tr style="background: #fee2e2;"><td>7</td><td>C (MIN)</td><td>Check: (3)  (2)?</td><td>3</td><td>2</td><td><strong>YES! PRUNE node 9!</strong></td></tr>
                            <tr><td>8</td><td>C (MIN)</td><td>Return to A</td><td>3</td><td>2</td><td>C value = 2</td></tr>
                            <tr><td>9</td><td>A (MAX)</td><td>Final: max(3, 2)</td><td>3</td><td>-</td><td><strong>Choose B, value = 3</strong></td></tr>
                        </table>

                        <p><strong>Pruned Nodes:</strong></p>
                        <pre style="background: #dcfce7; padding: 15px; border-radius: 8px; font-family: monospace;">
                MAX (A) = 3
              /            \
          MIN (B)=3      MIN (C)=2
          /   \          /    \
         3     5        2     9   PRUNED!
                        </pre>

                        <p style="margin-top: 15px;"><strong>Explanation of Pruning:</strong></p>
                        <ul style="margin-left: 25px;">
                            <li>After exploring B, MAX knows it can get at least 3 ( = 3)</li>
                            <li>At C, after seeing child 2, MIN will choose value  2 ( = 2)</li>
                            <li>Since (3)  (2), MAX will never choose C (it gives  2, but MAX has 3)</li>
                            <li>Therefore, no need to explore remaining children of C (node 9)</li>
                        </ul>

                        <p style="margin-top: 15px; padding: 15px; background: #f0f9ff; border-radius: 8px;">
                            <strong>Result:</strong> Same as Minimax (value = 3, choose left) but with fewer node evaluations!<br>
                            <strong>Nodes saved:</strong> 1 (node with value 9 was never evaluated)
                        </p>
                    </div>
                </div>

                <!-- Q4 - 8 Marks -->
                <div class="exam-box">
                    <div class="exam-title"><i class="fas fa-question-circle"></i> Q4. Compare Minimax and Alpha-Beta Pruning. When and why is Alpha-Beta preferred? [8 Marks]</div>
                    <span class="marks-badge eight">8 MARKS</span>

                    <div style="background: white; padding: 25px; border-radius: 12px; margin-top: 15px; border: 2px solid #7c3aed;">
                        <h5 style="color: #5b21b6; margin-bottom: 15px;">MODEL ANSWER:</h5>

                        <p><strong>Introduction:</strong> Both Minimax and Alpha-Beta are algorithms for decision-making in two-player games. Alpha-Beta is an optimized version of Minimax that produces identical results with less computation.</p>

                        <h5 style="color: #3d5a80; margin-top: 20px;">Comparison:</h5>

                        <table style="width: 100%; margin: 15px 0;">
                            <thead>
                                <tr>
                                    <th>Aspect</th>
                                    <th>Minimax</th>
                                    <th>Alpha-Beta Pruning</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Basic Approach</strong></td>
                                    <td>Explores entire game tree</td>
                                    <td>Prunes branches that cannot affect result</td>
                                </tr>
                                <tr>
                                    <td><strong>Additional Parameters</strong></td>
                                    <td>None</td>
                                    <td> (MAX's best),  (MIN's best)</td>
                                </tr>
                                <tr>
                                    <td><strong>Time Complexity</strong></td>
                                    <td>O(b<sup>m</sup>) - always</td>
                                    <td>Best: O(b<sup>m/2</sup>), Worst: O(b<sup>m</sup>)</td>
                                </tr>
                                <tr>
                                    <td><strong>Nodes Evaluated</strong></td>
                                    <td>All nodes in tree</td>
                                    <td>Only necessary nodes</td>
                                </tr>
                                <tr>
                                    <td><strong>Result</strong></td>
                                    <td>Optimal move</td>
                                    <td>Same optimal move</td>
                                </tr>
                                <tr>
                                    <td><strong>Move Ordering Impact</strong></td>
                                    <td>No impact</td>
                                    <td>Significant (better ordering = more pruning)</td>
                                </tr>
                                <tr>
                                    <td><strong>Effective Depth</strong></td>
                                    <td>Limited by time</td>
                                    <td>Can search ~2 deeper in same time</td>
                                </tr>
                            </tbody>
                        </table>

                        <h5 style="color: #3d5a80; margin-top: 20px;">When is Alpha-Beta Preferred?</h5>
                        <ol style="margin-left: 25px;">
                            <li><strong>Large Game Trees:</strong> When the game has many possible moves (high branching factor), Alpha-Beta dramatically reduces computation</li>
                            <li><strong>Real-time Games:</strong> When decisions must be made quickly, Alpha-Beta allows deeper search in the same time</li>
                            <li><strong>Complex Games:</strong> Games like Chess (b35) or Go (b250) are impractical without pruning</li>
                            <li><strong>Tournament Play:</strong> Competitive AI needs to search as deep as possible within time limits</li>
                        </ol>

                        <h5 style="color: #3d5a80; margin-top: 20px;">Why is Alpha-Beta Preferred?</h5>
                        <ul style="margin-left: 25px;">
                            <li><strong>Same Result:</strong> Guaranteed to produce identical result as Minimax</li>
                            <li><strong>Significant Speedup:</strong> With good move ordering, can search twice as deep</li>
                            <li><strong>No Disadvantage:</strong> Never performs worse than Minimax</li>
                            <li><strong>Easy Enhancement:</strong> Simple addition of ,  parameters to Minimax</li>
                            <li><strong>Industry Standard:</strong> Used in all competitive game-playing programs</li>
                        </ul>

                        <p style="margin-top: 20px; padding: 15px; background: #f0f9ff; border-radius: 8px;"><strong>Conclusion:</strong> Alpha-Beta pruning is universally preferred over plain Minimax for any non-trivial game. It provides the same optimal result while significantly reducing computation, enabling deeper and stronger game-playing AI.</p>
                    </div>
                </div>

            </section>

            <!-- ==================== SUMMARY SECTION ==================== -->
            <section id="summary">
                <h2><i class="fas fa-clipboard-list"></i>Unit Summary: Quick Revision</h2>

                <div class="summary-box">
                    <h4><i class="fas fa-brain"></i> Complete Unit Overview</h4>
                    <table style="width: 100%; color: white; margin-top: 15px;">
                        <tr style="background: rgba(255,255,255,0.1);">
                            <th style="padding: 12px; border: 1px solid rgba(255,255,255,0.2);">Topic</th>
                            <th style="padding: 12px; border: 1px solid rgba(255,255,255,0.2);">Key Concepts</th>
                            <th style="padding: 12px; border: 1px solid rgba(255,255,255,0.2);">Remember</th>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Introduction to AI</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Types, Goals, Applications</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">4 types by functionality</td>
                        </tr>
                        <tr style="background: rgba(255,255,255,0.05);">
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Problem Representation</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">5 Components</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Initial, Goal, Actions, Cost, Space</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">State Space</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Graph/Tree, Metrics</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Complete, Optimal, Time, Space</td>
                        </tr>
                        <tr style="background: rgba(255,255,255,0.05);">
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">BFS</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Queue, Level-by-level</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Complete , Optimal , Space O(b<sup>d</sup>)</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">DFS</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Stack, Depth-first</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Complete , Optimal , Space O(bm)</td>
                        </tr>
                        <tr style="background: rgba(255,255,255,0.05);">
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Heuristics</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">h(n), Admissible, Consistent</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Never overestimate for optimal</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Hill Climbing</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Local search, Greedy</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Local maxima, Plateau, Ridge</td>
                        </tr>
                        <tr style="background: rgba(255,255,255,0.05);">
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Best-First Search</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">f(n), Priority Queue</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Greedy: f(n) = h(n)</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">A* Search</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">f(n) = g(n) + h(n)</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Complete , Optimal  (admissible h)</td>
                        </tr>
                        <tr style="background: rgba(255,255,255,0.05);">
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">AO*</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">AND-OR graphs</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Solution graphs, not paths</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Game Trees</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">MAX/MIN, Evaluation</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Adversarial search</td>
                        </tr>
                        <tr style="background: rgba(255,255,255,0.05);">
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Minimax</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Optimal game play</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">O(b<sup>m</sup>) time</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Alpha-Beta</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Pruning optimization</td>
                            <td style="padding: 10px; border: 1px solid rgba(255,255,255,0.2);">Prune when   </td>
                        </tr>
                    </table>
                </div>

                <div class="key-points" style="margin-top: 30px;">
                    <h4><i class="fas fa-lightbulb"></i> Key Formulas to Remember</h4>
                    <ul>
                        <li><strong>A* Evaluation:</strong> f(n) = g(n) + h(n)</li>
                        <li><strong>Admissible Heuristic:</strong> h(n)  h*(n) (never overestimates)</li>
                        <li><strong>BFS Complexity:</strong> Time = O(b<sup>d</sup>), Space = O(b<sup>d</sup>)</li>
                        <li><strong>DFS Complexity:</strong> Time = O(b<sup>m</sup>), Space = O(bm)</li>
                        <li><strong>Alpha-Beta Best Case:</strong> O(b<sup>m/2</sup>) - can search twice as deep</li>
                        <li><strong>Pruning Condition:</strong> Cut off when   </li>
                    </ul>
                </div>

                <div class="tip-box" style="margin-top: 30px; background: linear-gradient(135deg, #1e3a5f, #2d4a6f); color: white; border-left-color: #ffd700;">
                    <h4 style="color: #ffd700;"><i class="fas fa-graduation-cap"></i> Exam Strategy Tips</h4>
                    <ul style="margin-top: 15px;">
                        <li><strong>For 4-mark questions:</strong> Give definition + 2-3 key points + brief example if asked</li>
                        <li><strong>For 8-mark questions:</strong> Definition + Algorithm/Steps + Diagram + Example + Pros/Cons or Comparison</li>
                        <li><strong>Always draw diagrams</strong> for tree traversals, state spaces, and game trees</li>
                        <li><strong>Show working</strong> for numerical problems (A*, Alpha-Beta)</li>
                        <li><strong>Compare when asked:</strong> Use tables with clear parameters</li>
                        <li><strong>Include real-world examples</strong> to demonstrate understanding</li>
                    </ul>
                </div>
            </section>

        </div>

        <footer>
            <p><i class="fas fa-brain"></i> Artificial Intelligence - Unit 1: Overview & Search Techniques</p>
            <p style="margin-top: 10px;">Comprehensive Theoretical Coursework | CO1: Problem Representation & AI Search</p>
            <p style="margin-top: 15px; font-size: 0.9em;">Designed for Exam Preparation - Theory Focus</p>
        </footer>
    </div>

    <script>
        // Smooth scrolling for navigation
        document.querySelectorAll('a.nav-tab').forEach(anchor => {
            anchor.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({ behavior: 'smooth' });
                }

                // Update active tab
                document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
                this.classList.add('active');
            });
        });

        // Update active tab on scroll
        window.addEventListener('scroll', function() {
            const sections = document.querySelectorAll('section');
            const navTabs = document.querySelectorAll('.nav-tab');

            let currentSection = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop - 100;
                if (window.pageYOffset >= sectionTop) {
                    currentSection = section.getAttribute('id');
                }
            });

            navTabs.forEach(tab => {
                tab.classList.remove('active');
                if (tab.getAttribute('href') === '#' + currentSection) {
                    tab.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>
