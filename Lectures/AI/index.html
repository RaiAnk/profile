<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit 1: AI Overview & Search Techniques | Artificial Intelligence</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Screen reader only - for accessibility */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #1e3a5f 0%, #0d1b2a 100%);
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 25px 80px rgba(0,0,0,0.4);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #1e3a5f 0%, #3d5a80 50%, #98c1d9 100%);
            color: white;
            padding: 50px 40px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: pulse 4s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 0.3; }
        }

        header h1 {
            font-size: 2.8em;
            margin-bottom: 10px;
            position: relative;
            z-index: 1;
        }

        header h1 i {
            margin-right: 15px;
        }

        header p {
            font-size: 1.3em;
            opacity: 0.95;
            position: relative;
            z-index: 1;
        }

        .course-info {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
            position: relative;
            z-index: 1;
        }

        .course-badge {
            background: rgba(255,255,255,0.2);
            padding: 8px 20px;
            border-radius: 25px;
            font-size: 0.95em;
            backdrop-filter: blur(5px);
        }

        .content {
            padding: 50px;
        }

        /* Course Outcome Box */
        .co-box {
            background: linear-gradient(135deg, #e8f4f8 0%, #d1e8f0 100%);
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 40px;
            border-left: 6px solid #1e3a5f;
            box-shadow: 0 4px 15px rgba(30,58,95,0.15);
        }

        .co-box h2 {
            color: #1e3a5f;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .co-box h2 i {
            margin-right: 10px;
        }

        .co-box p {
            font-size: 1.1em;
            color: #2c3e50;
        }

        .co-box .outcome-tag {
            display: inline-block;
            background: #1e3a5f;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        /* Overview Box */
        .overview-box {
            background: #f8fafc;
            padding: 35px;
            border-radius: 15px;
            margin-bottom: 45px;
            border-left: 6px solid #3d5a80;
        }

        .overview-box h2 {
            color: #1e3a5f;
            margin-bottom: 25px;
            font-size: 2em;
        }

        .overview-box h2 i {
            margin-right: 12px;
        }

        .big-picture {
            background: white;
            padding: 25px;
            border-radius: 12px;
            margin: 20px 0;
            box-shadow: 0 3px 10px rgba(0,0,0,0.08);
        }

        .big-picture h3 {
            color: #3d5a80;
            margin-bottom: 15px;
            border: none;
        }

        /* Navigation Tabs */
        .nav-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            background: #1e3a5f;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 40px;
        }

        .nav-tab {
            padding: 12px 20px;
            background: rgba(255,255,255,0.1);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.95em;
            border: none;
        }

        .nav-tab:hover, .nav-tab.active {
            background: #98c1d9;
            color: #1e3a5f;
            transform: translateY(-2px);
        }

        .nav-tab i {
            margin-right: 8px;
        }

        /* Section Styling */
        section {
            margin-bottom: 60px;
            scroll-margin-top: 20px;
        }

        h2 {
            color: #1e3a5f;
            font-size: 2.2em;
            margin-bottom: 25px;
            padding-bottom: 12px;
            border-bottom: 4px solid #3d5a80;
            display: flex;
            align-items: center;
        }

        h2 i {
            margin-right: 15px;
            color: #3d5a80;
        }

        h3 {
            color: #3d5a80;
            font-size: 1.6em;
            margin-top: 35px;
            margin-bottom: 20px;
        }

        h3 i {
            margin-right: 10px;
        }

        h4 {
            color: #4a6fa5;
            font-size: 1.3em;
            margin-top: 25px;
            margin-bottom: 15px;
        }

        h4 i {
            margin-right: 8px;
        }

        /* Definition Box */
        .definition {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 5px solid #1976d2;
            position: relative;
        }

        .definition::before {
            content: 'DEFINITION';
            position: absolute;
            top: -12px;
            left: 20px;
            background: #1976d2;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 0.75em;
            font-weight: bold;
        }

        .definition strong {
            color: #0d47a1;
        }

        .definition i {
            margin-right: 10px;
            color: #1976d2;
        }

        /* What Why When How Box */
        .wwwh-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .wwwh-item {
            padding: 25px;
            border-radius: 12px;
            transition: transform 0.3s ease;
        }

        .wwwh-item:hover {
            transform: translateY(-5px);
        }

        .wwwh-item.what {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border-left: 5px solid #4caf50;
        }

        .wwwh-item.why {
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
            border-left: 5px solid #ff9800;
        }

        .wwwh-item.when {
            background: linear-gradient(135deg, #fce4ec 0%, #f8bbd9 100%);
            border-left: 5px solid #e91e63;
        }

        .wwwh-item.how {
            background: linear-gradient(135deg, #e1f5fe 0%, #b3e5fc 100%);
            border-left: 5px solid #03a9f4;
        }

        .wwwh-item h4 {
            color: #333;
            margin-top: 0;
            margin-bottom: 10px;
        }

        /* Simple Explanation Box */
        .simple-explanation {
            background: linear-gradient(135deg, #fffde7 0%, #fff9c4 100%);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 5px solid #fbc02d;
        }

        .simple-explanation-title {
            color: #f57f17;
            font-weight: bold;
            font-size: 1.2em;
            margin-bottom: 12px;
        }

        .simple-explanation-title i {
            margin-right: 10px;
        }

        /* Example Box */
        .example {
            background: linear-gradient(135deg, #fff8e1 0%, #ffecb3 100%);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 5px solid #ff8f00;
        }

        .example-title {
            color: #e65100;
            font-weight: bold;
            font-size: 1.15em;
            margin-bottom: 12px;
        }

        .example-title i {
            margin-right: 10px;
        }

        .example-level {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: bold;
            margin-left: 10px;
        }

        .example-level.basic {
            background: #c8e6c9;
            color: #2e7d32;
        }

        .example-level.industry {
            background: #bbdefb;
            color: #1565c0;
        }

        .example-level.advanced {
            background: #e1bee7;
            color: #7b1fa2;
        }

        /* Code Block */
        .code-container {
            position: relative;
            margin: 25px 0;
        }

        .code-block {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            color: #e2e8f0;
            padding: 25px;
            border-radius: 12px;
            overflow-x: auto;
            font-family: 'Fira Code', 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.8;
            white-space: pre-wrap;
            word-wrap: break-word;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .code-header {
            background: #334155;
            padding: 10px 20px;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .code-lang {
            color: #94a3b8;
            font-size: 0.85em;
            text-transform: uppercase;
        }

        .copy-button {
            background: #3d5a80;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
        }

        .copy-button:hover {
            background: #98c1d9;
            color: #1e3a5f;
            transform: scale(1.05);
        }

        .copy-button.copied {
            background: #10b981;
        }

        .code-block .comment { color: #6b7280; }
        .code-block .keyword { color: #c084fc; }
        .code-block .string { color: #86efac; }
        .code-block .function { color: #fbbf24; }
        .code-block .number { color: #60a5fa; }
        .code-block .class { color: #f472b6; }

        /* Algorithm Box */
        .algorithm-box {
            background: linear-gradient(135deg, #f3e5f5 0%, #e1bee7 100%);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 5px solid #9c27b0;
        }

        .algorithm-title {
            color: #6a1b9a;
            font-weight: bold;
            font-size: 1.2em;
            margin-bottom: 15px;
        }

        .algorithm-title i {
            margin-right: 10px;
        }

        .algorithm-steps {
            counter-reset: step-counter;
            list-style: none;
            padding-left: 0;
        }

        .algorithm-steps li {
            counter-increment: step-counter;
            margin: 15px 0;
            padding-left: 50px;
            position: relative;
        }

        .algorithm-steps li::before {
            content: counter(step-counter);
            position: absolute;
            left: 0;
            top: 0;
            background: #9c27b0;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9em;
        }

        /* Complexity Box */
        .complexity-box {
            background: linear-gradient(135deg, #e0f2f1 0%, #b2dfdb 100%);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .complexity-item {
            text-align: center;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        .complexity-item .label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
        }

        .complexity-item .value {
            font-size: 1.4em;
            font-weight: bold;
            color: #00695c;
            font-family: 'Fira Code', monospace;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border-radius: 12px;
            overflow: hidden;
        }

        th {
            background: linear-gradient(135deg, #1e3a5f 0%, #3d5a80 100%);
            color: white;
            padding: 18px 15px;
            text-align: left;
            font-weight: 600;
        }

        td {
            padding: 15px;
            border-bottom: 1px solid #e5e7eb;
        }

        tr:nth-child(even) {
            background: #f8fafc;
        }

        tr:hover {
            background: #e8f4f8;
        }

        /* Case Study Box */
        .case-study {
            background: linear-gradient(135deg, #fce4ec 0%, #f8bbd9 100%);
            padding: 30px;
            border-radius: 15px;
            margin: 30px 0;
            border-left: 6px solid #c2185b;
        }

        .case-study-title {
            color: #880e4f;
            font-weight: bold;
            font-size: 1.3em;
            margin-bottom: 15px;
        }

        .case-study-title i {
            margin-right: 10px;
        }

        /* Chart Container */
        .chart-container {
            background: white;
            padding: 25px;
            border-radius: 12px;
            margin: 30px 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .chart-title {
            text-align: center;
            color: #1e3a5f;
            margin-bottom: 20px;
            font-size: 1.2em;
        }

        /* Tree Visualization */
        .tree-container {
            background: #f8fafc;
            padding: 30px;
            border-radius: 12px;
            margin: 25px 0;
            overflow-x: auto;
        }

        .tree-visual {
            text-align: center;
            font-family: 'Fira Code', monospace;
        }

        .tree-node {
            display: inline-block;
            padding: 10px 20px;
            background: #3d5a80;
            color: white;
            border-radius: 25px;
            margin: 5px;
            font-weight: bold;
        }

        .tree-node.goal {
            background: #10b981;
        }

        .tree-node.current {
            background: #f59e0b;
            animation: blink 1s infinite;
        }

        .tree-node.visited {
            background: #6b7280;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Highlight */
        .highlight {
            background: linear-gradient(135deg, #fef08a 0%, #fde047 100%);
            padding: 2px 8px;
            border-radius: 4px;
        }

        /* Key Points */
        .key-points {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
        }

        .key-points h4 {
            color: #1565c0;
            margin-top: 0;
        }

        .key-points ul {
            margin-left: 25px;
        }

        .key-points li {
            margin: 12px 0;
        }

        .key-points li::marker {
            color: #1976d2;
        }

        /* Tip Box */
        .tip-box {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            border-left: 5px solid #10b981;
        }

        .tip-box strong {
            color: #047857;
        }

        .tip-box i {
            margin-right: 10px;
            color: #10b981;
        }

        /* Warning Box */
        .warning-box {
            background: linear-gradient(135deg, #fef2f2 0%, #fecaca 100%);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            border-left: 5px solid #ef4444;
        }

        .warning-box i {
            margin-right: 10px;
            color: #ef4444;
        }

        /* Assignment Box */
        .assignment-box {
            background: linear-gradient(135deg, #ede9fe 0%, #ddd6fe 100%);
            padding: 30px;
            border-radius: 15px;
            margin: 30px 0;
            border-left: 6px solid #7c3aed;
        }

        .assignment-title {
            color: #5b21b6;
            font-weight: bold;
            font-size: 1.3em;
            margin-bottom: 15px;
        }

        .assignment-title i {
            margin-right: 10px;
        }

        .assignment-level {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .assignment-level.easy {
            background: #c8e6c9;
            color: #2e7d32;
        }

        .assignment-level.medium {
            background: #fff3e0;
            color: #e65100;
        }

        .assignment-level.hard {
            background: #fce4ec;
            color: #c2185b;
        }

        /* Solution Toggle */
        .solution-toggle {
            background: #7c3aed;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 15px;
            transition: all 0.3s ease;
        }

        .solution-toggle:hover {
            background: #6d28d9;
            transform: translateY(-2px);
        }

        .solution-content {
            display: none;
            margin-top: 20px;
            padding: 20px;
            background: white;
            border-radius: 10px;
            border: 2px solid #7c3aed;
        }

        .solution-content.show {
            display: block;
        }

        /* Q&A Box */
        .qa-box {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            padding: 25px;
            border-radius: 15px;
            margin: 25px 0;
            border: 2px solid #0ea5e9;
        }

        .qa-box h4 {
            color: #0369a1;
            margin-top: 0;
        }

        .question {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #0ea5e9;
        }

        .question strong {
            color: #0369a1;
        }

        .answer {
            padding-left: 20px;
            margin-top: 10px;
            color: #334155;
        }

        /* Comparison Grid */
        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .comparison-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border-top: 5px solid #3d5a80;
            transition: transform 0.3s ease;
        }

        .comparison-card:hover {
            transform: translateY(-5px);
        }

        .comparison-card h4 {
            margin-top: 0;
            color: #1e3a5f;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 2px solid #e5e7eb;
        }

        /* Footer */
        footer {
            background: linear-gradient(135deg, #1e3a5f 0%, #0d1b2a 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        footer p {
            opacity: 0.9;
        }

        /* State Space Diagram */
        .state-space-diagram {
            background: #f8fafc;
            padding: 30px;
            border-radius: 12px;
            margin: 25px 0;
            text-align: center;
        }

        .state-node {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #3d5a80;
            color: white;
            font-weight: bold;
            margin: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        .state-node.start {
            background: #10b981;
        }

        .state-node.goal {
            background: #f59e0b;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .content {
                padding: 25px;
            }

            h2 {
                font-size: 1.6em;
            }

            .wwwh-grid {
                grid-template-columns: 1fr;
            }

            .comparison-grid {
                grid-template-columns: 1fr;
            }

            .nav-tabs {
                flex-direction: column;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .container {
                box-shadow: none;
            }

            .nav-tabs {
                display: none;
            }

            .copy-button {
                display: none;
            }
        }

        /* Real-World Analogy Box */
        .analogy-box {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            padding: 30px;
            border-radius: 16px;
            margin: 30px 0;
            border-left: 6px solid #f59e0b;
            box-shadow: 0 4px 20px rgba(245, 158, 11, 0.2);
        }

        .analogy-box .analogy-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            color: #92400e;
            font-size: 1.4em;
            font-weight: bold;
        }

        .analogy-box .analogy-header i {
            font-size: 1.5em;
        }

        .analogy-box .analogy-scenario {
            background: rgba(255,255,255,0.8);
            padding: 20px;
            border-radius: 12px;
            margin: 15px 0;
        }

        .analogy-box .analogy-scenario h5 {
            color: #b45309;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        /* Day-to-Day Connection Box */
        .daily-life-box {
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            padding: 30px;
            border-radius: 16px;
            margin: 30px 0;
            border-left: 6px solid #3b82f6;
        }

        .daily-life-box .daily-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            color: #1d4ed8;
            font-size: 1.3em;
            font-weight: bold;
        }

        .daily-life-box .daily-example {
            background: white;
            padding: 20px;
            border-radius: 12px;
            margin: 15px 0;
            border-left: 4px solid #60a5fa;
        }

        .daily-life-box .daily-example h5 {
            color: #2563eb;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Step-by-Step Walkthrough Box */
        .walkthrough-box {
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
            padding: 30px;
            border-radius: 16px;
            margin: 30px 0;
            border: 2px solid #22c55e;
        }

        .walkthrough-box .walkthrough-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            color: #15803d;
            font-size: 1.3em;
            font-weight: bold;
        }

        .walkthrough-box .step {
            background: white;
            padding: 20px;
            border-radius: 12px;
            margin: 15px 0;
            border-left: 5px solid #22c55e;
            position: relative;
        }

        .walkthrough-box .step-number {
            position: absolute;
            left: -25px;
            top: 20px;
            background: #22c55e;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.1em;
        }

        .walkthrough-box .step h5 {
            color: #166534;
            margin-bottom: 10px;
            padding-left: 25px;
        }

        .walkthrough-box .step p {
            padding-left: 25px;
        }

        /* Chew & Feed Explanation Box */
        .chew-feed-box {
            background: linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%);
            padding: 30px;
            border-radius: 16px;
            margin: 30px 0;
            border-left: 6px solid #ec4899;
        }

        .chew-feed-box .cf-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            color: #be185d;
            font-size: 1.3em;
            font-weight: bold;
        }

        .chew-feed-box .simple-terms {
            background: white;
            padding: 20px;
            border-radius: 12px;
            margin: 15px 0;
        }

        .chew-feed-box .simple-terms h5 {
            color: #db2777;
            margin-bottom: 15px;
        }

        .chew-feed-box .term-explain {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 15px;
            margin: 10px 0;
            align-items: start;
        }

        .chew-feed-box .term-explain .term {
            background: #ec4899;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            white-space: nowrap;
        }

        /* Comprehensive Solution Box */
        .comprehensive-solution {
            background: linear-gradient(135deg, #ede9fe 0%, #ddd6fe 100%);
            padding: 30px;
            border-radius: 16px;
            margin: 25px 0;
            border: 2px solid #8b5cf6;
        }

        .comprehensive-solution .solution-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            color: #6d28d9;
            font-size: 1.3em;
            font-weight: bold;
        }

        .comprehensive-solution .solution-step {
            background: white;
            padding: 20px;
            border-radius: 12px;
            margin: 15px 0;
            border-left: 4px solid #8b5cf6;
        }

        .comprehensive-solution .solution-step h5 {
            color: #7c3aed;
            margin-bottom: 10px;
        }

        .comprehensive-solution .calculation {
            background: #f5f3ff;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: 'Fira Code', monospace;
        }

        .comprehensive-solution .insight {
            background: #fef3c7;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #f59e0b;
        }

        /* Why It Matters Box */
        .why-matters-box {
            background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
            padding: 25px;
            border-radius: 16px;
            margin: 25px 0;
            border-left: 6px solid #ef4444;
        }

        .why-matters-box .why-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            color: #b91c1c;
            font-size: 1.2em;
            font-weight: bold;
        }

        .why-matters-box ul {
            margin-left: 25px;
        }

        .why-matters-box li {
            margin: 10px 0;
            color: #991b1b;
        }

        /* Think Like This Box */
        .think-like-box {
            background: linear-gradient(135deg, #e0e7ff 0%, #c7d2fe 100%);
            padding: 25px;
            border-radius: 16px;
            margin: 25px 0;
            border-left: 6px solid #6366f1;
        }

        .think-like-box .think-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            color: #4338ca;
            font-size: 1.2em;
            font-weight: bold;
        }

        .think-like-box .thought-bubble {
            background: white;
            padding: 20px;
            border-radius: 20px;
            margin: 15px 0;
            position: relative;
            box-shadow: 0 2px 10px rgba(99, 102, 241, 0.2);
        }

        .think-like-box .thought-bubble::before {
            content: '"';
            position: absolute;
            top: -15px;
            left: 20px;
            font-size: 2em;
            color: #6366f1;
            font-family: Georgia, serif;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-brain"></i>Artificial Intelligence</h1>
            <p>Unit 1: Overview & Search Techniques</p>
            <div class="course-info">
                <span class="course-badge"><i class="fas fa-book"></i> CO1: Problem Representation & AI Search</span>
                <span class="course-badge"><i class="fas fa-clock"></i> Comprehensive Module</span>
                <span class="course-badge"><i class="fas fa-code"></i> Python Implementation</span>
            </div>
        </header>

        <div class="content">
            <!-- Course Outcome Box -->
            <div class="co-box">
                <span class="outcome-tag"><i class="fas fa-bullseye"></i> Course Outcome 1 (CO1)</span>
                <h2><i class="fas fa-target"></i>Learning Objective</h2>
                <p><strong>CO1:</strong> Represent any well-defined problem and can apply AI Searching techniques to solve a problem.</p>
                <div style="margin-top: 15px; display: flex; flex-wrap: wrap; gap: 10px;">
                    <span style="background: #3d5a80; color: white; padding: 5px 12px; border-radius: 15px; font-size: 0.85em;">Problem Formulation</span>
                    <span style="background: #3d5a80; color: white; padding: 5px 12px; border-radius: 15px; font-size: 0.85em;">State Space Representation</span>
                    <span style="background: #3d5a80; color: white; padding: 5px 12px; border-radius: 15px; font-size: 0.85em;">Search Algorithms</span>
                    <span style="background: #3d5a80; color: white; padding: 5px 12px; border-radius: 15px; font-size: 0.85em;">Optimization</span>
                </div>
            </div>

            <!-- Prerequisites Box -->
            <div class="tip-box" style="background: linear-gradient(135deg, #1e3a5f 0%, #2d4a6f 100%); color: white; border-left: 5px solid #22c55e;">
                <h4 style="color: #22c55e; margin-bottom: 15px;"><i class="fas fa-tools"></i> Prerequisites & Setup</h4>
                <p style="margin-bottom: 15px;">Before running the code examples in this module, ensure you have Python 3.7+ installed and the following packages:</p>

                <div style="background: #0f172a; padding: 15px; border-radius: 8px; font-family: 'Fira Code', monospace; margin-bottom: 15px;">
                    <code style="color: #86efac;"># Install required packages</code><br>
                    <code style="color: #f8fafc;">pip install numpy matplotlib</code><br><br>
                    <code style="color: #86efac;"># For Chess AI case study (optional)</code><br>
                    <code style="color: #f8fafc;">pip install python-chess</code><br><br>
                    <code style="color: #86efac;"># For visualization animations (optional)</code><br>
                    <code style="color: #f8fafc;">pip install pillow</code>
                </div>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 6px;">
                        <strong><i class="fas fa-cube"></i> numpy</strong>
                        <p style="font-size: 0.85em; margin: 5px 0 0 0;">Mathematical operations, array handling</p>
                    </div>
                    <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 6px;">
                        <strong><i class="fas fa-chart-line"></i> matplotlib</strong>
                        <p style="font-size: 0.85em; margin: 5px 0 0 0;">Visualization, graphs, animations</p>
                    </div>
                    <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 6px;">
                        <strong><i class="fas fa-chess"></i> python-chess</strong>
                        <p style="font-size: 0.85em; margin: 5px 0 0 0;">Chess move validation, board state</p>
                    </div>
                    <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 6px;">
                        <strong><i class="fas fa-image"></i> pillow</strong>
                        <p style="font-size: 0.85em; margin: 5px 0 0 0;">Image processing, GIF creation</p>
                    </div>
                </div>

                <p style="margin-top: 15px; font-size: 0.9em; color: #94a3b8;">
                    <i class="fas fa-info-circle"></i> <strong>Note:</strong> Core algorithms (DFS, BFS, A*, Mini-Max) use only Python standard library.
                    External packages are only needed for visualizations and advanced case studies.
                </p>
            </div>

            <!-- Navigation Tabs -->
            <div class="nav-tabs">
                <button class="nav-tab active" onclick="scrollToSection('intro')"><i class="fas fa-rocket"></i>Introduction to AI</button>
                <button class="nav-tab" onclick="scrollToSection('problem')"><i class="fas fa-puzzle-piece"></i>Problem Representation</button>
                <button class="nav-tab" onclick="scrollToSection('blind')"><i class="fas fa-eye-slash"></i>Blind Search</button>
                <button class="nav-tab" onclick="scrollToSection('informed')"><i class="fas fa-lightbulb"></i>Informed Search</button>
                <button class="nav-tab" onclick="scrollToSection('astar')"><i class="fas fa-star"></i>A* & AO*</button>
                <button class="nav-tab" onclick="scrollToSection('game')"><i class="fas fa-gamepad"></i>Game Trees</button>
                <button class="nav-tab" onclick="scrollToSection('assignments')"><i class="fas fa-tasks"></i>Assignments</button>
            </div>

            <!-- ==================== SECTION 1: INTRODUCTION TO AI ==================== -->
            <section id="intro">
                <h2><i class="fas fa-robot"></i>1. Introduction to Artificial Intelligence</h2>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>Artificial Intelligence (AI)</strong> is the science and engineering of creating intelligent machines and computer programs that can simulate human-like cognitive functions such as learning, reasoning, problem-solving, perception, and language understanding.</p>
                </div>

                <div class="wwwh-grid">
                    <div class="wwwh-item what">
                        <h4><i class="fas fa-question-circle"></i>WHAT is AI?</h4>
                        <p>AI is the capability of machines to imitate intelligent human behavior. It encompasses machine learning, natural language processing, computer vision, robotics, and expert systems.</p>
                    </div>
                    <div class="wwwh-item why">
                        <h4><i class="fas fa-lightbulb"></i>WHY is AI Important?</h4>
                        <p>AI automates complex tasks, enhances decision-making, discovers patterns in massive datasets, and solves problems that are computationally infeasible for humans.</p>
                    </div>
                    <div class="wwwh-item when">
                        <h4><i class="fas fa-clock"></i>WHEN to Use AI?</h4>
                        <p>Use AI when dealing with large-scale data, pattern recognition, optimization problems, autonomous systems, or when human-like reasoning is needed at scale.</p>
                    </div>
                    <div class="wwwh-item how">
                        <h4><i class="fas fa-cogs"></i>HOW Does AI Work?</h4>
                        <p>AI works through algorithms that learn from data (ML), search through solution spaces, represent knowledge, and make decisions using rules or learned patterns.</p>
                    </div>
                </div>

                <h3><i class="fas fa-history"></i>Brief History & Evolution of AI</h3>

                <div class="chart-container">
                    <div class="chart-title"><i class="fas fa-chart-line"></i> AI Evolution Timeline & Investment Growth</div>
                    <canvas id="aiTimelineChart" height="100"></canvas>
                </div>

                <!-- Detailed AI Timeline with Milestones -->
                <div class="walkthrough-box" style="margin-top:30px;">
                    <div class="walkthrough-header">
                        <i class="fas fa-landmark"></i> Key Milestones in AI History & Investment
                    </div>

                    <div class="step">
                        <div class="step-number" style="background:#6b7280;">1</div>
                        <h5>1950s - The Birth of AI ($0.1B)</h5>
                        <p><strong>1950:</strong> Alan Turing publishes "Computing Machinery and Intelligence" - proposes the Turing Test</p>
                        <p><strong>1956:</strong> Dartmouth Conference - John McCarthy coins the term "Artificial Intelligence"</p>
                        <p><strong>1957:</strong> Frank Rosenblatt invents the Perceptron (first neural network)</p>
                        <p style="color:#666; margin-top:5px;"><em>Investment: Mostly government/military research grants</em></p>
                    </div>

                    <div class="step">
                        <div class="step-number" style="background:#6b7280;">2</div>
                        <h5>1960s-70s - Early Promise & First AI Winter ($0.5-1B)</h5>
                        <p><strong>1966:</strong> ELIZA chatbot created at MIT - first conversational AI</p>
                        <p><strong>1969:</strong> Shakey the Robot - first mobile robot with AI reasoning</p>
                        <p><strong>1974-80:</strong> First "AI Winter" - funding cuts due to unmet expectations</p>
                        <p style="color:#666; margin-top:5px;"><em>Investment: DARPA, university research</em></p>
                    </div>

                    <div class="step">
                        <div class="step-number" style="background:#f59e0b;">3</div>
                        <h5>1980s - Expert Systems Boom ($2-5B)</h5>
                        <p><strong>1980:</strong> XCON expert system saves DEC $40M/year in computer configuration</p>
                        <p><strong>1986:</strong> Backpropagation algorithm revives neural networks (Rumelhart, Hinton)</p>
                        <p><strong>1987:</strong> Second AI Winter begins - expert systems prove too expensive</p>
                        <p style="color:#666; margin-top:5px;"><em>Companies: Symbolics, Lisp Machines Inc., IntelliCorp raised ~$1B combined</em></p>
                    </div>

                    <div class="step">
                        <div class="step-number" style="background:#3b82f6;">4</div>
                        <h5>1990s - Statistical AI & Chess ($5-10B)</h5>
                        <p><strong>1997:</strong> IBM Deep Blue defeats world chess champion Garry Kasparov</p>
                        <p><strong>1997:</strong> LSTM networks invented - foundation for modern language AI</p>
                        <p><strong>1998:</strong> Google founded - uses AI for search ranking (PageRank)</p>
                        <p style="color:#666; margin-top:5px;"><em>Google's IPO (2004): $23B valuation based on AI-powered search</em></p>
                    </div>

                    <div class="step">
                        <div class="step-number" style="background:#22c55e;">5</div>
                        <h5>2000s - Machine Learning Rise ($10-30B)</h5>
                        <p><strong>2006:</strong> Geoffrey Hinton's deep learning breakthrough at U of Toronto</p>
                        <p><strong>2007:</strong> Netflix Prize - $1M competition accelerates recommendation AI</p>
                        <p><strong>2009:</strong> Google starts self-driving car project (now Waymo)</p>
                        <p style="color:#666; margin-top:5px;"><em>Facebook (2012 IPO): $104B | Using AI for news feed, ads targeting</em></p>
                    </div>

                    <div class="step">
                        <div class="step-number" style="background:#8b5cf6;">6</div>
                        <h5>2010s - Deep Learning Revolution ($30-100B)</h5>
                        <p><strong>2011:</strong> IBM Watson wins Jeopardy! against human champions</p>
                        <p><strong>2012:</strong> AlexNet wins ImageNet - deep learning proves superior</p>
                        <p><strong>2014:</strong> Google acquires DeepMind for $500M</p>
                        <p><strong>2016:</strong> AlphaGo defeats world Go champion Lee Sedol</p>
                        <p><strong>2017:</strong> Transformer architecture invented (basis for GPT, BERT)</p>
                        <p style="color:#666; margin-top:5px;"><em>NVIDIA market cap grows from $10B to $150B on AI chip demand</em></p>
                    </div>

                    <div class="step">
                        <div class="step-number" style="background:#ec4899;">7</div>
                        <h5>2020s - Generative AI Explosion ($100-200B+)</h5>
                        <p><strong>2020:</strong> GPT-3 released - 175B parameters, human-like text</p>
                        <p><strong>2022:</strong> ChatGPT launches - fastest growing app ever (100M users in 2 months)</p>
                        <p><strong>2023:</strong> OpenAI valued at $86B | Microsoft invests $10B</p>
                        <p><strong>2024:</strong> NVIDIA becomes world's most valuable company ($3.3 Trillion)</p>
                        <p style="color:#666; margin-top:5px;"><em>Global AI market projected: $1.8 Trillion by 2030 (Bloomberg)</em></p>
                    </div>
                </div>

                <!-- Investment Summary Table -->
                <div class="chart-container" style="margin-top:20px;">
                    <div class="chart-title"><i class="fas fa-dollar-sign"></i> AI Investment by Sector (2023-2024)</div>
                    <table style="width:100%; margin-top:15px;">
                        <thead>
                            <tr>
                                <th>Company/Sector</th>
                                <th>AI Investment</th>
                                <th>Key AI Product</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td><strong>Microsoft</strong></td><td>$13B (OpenAI partnership)</td><td>Copilot, Azure AI</td></tr>
                            <tr><td><strong>Google/Alphabet</strong></td><td>$10B+ annually</td><td>Gemini, Search AI, DeepMind</td></tr>
                            <tr><td><strong>Amazon</strong></td><td>$8B+ annually</td><td>Alexa, AWS AI Services</td></tr>
                            <tr><td><strong>Meta</strong></td><td>$5B+ annually</td><td>LLaMA, AI for Feeds/Ads</td></tr>
                            <tr><td><strong>Tesla</strong></td><td>$3B+ annually</td><td>Full Self-Driving (FSD)</td></tr>
                            <tr style="background:#fef3c7;"><td><strong>TOTAL (Top 50 companies)</strong></td><td><strong>$150B+ in 2024</strong></td><td>Projected $300B by 2027</td></tr>
                        </tbody>
                    </table>
                </div>

                <h3><i class="fas fa-layer-group"></i>Types of AI Systems</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Description</th>
                            <th>Capability</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Reactive Machines</strong></td>
                            <td>No memory, responds to current input only</td>
                            <td>Task-specific responses</td>
                            <td>IBM Deep Blue (Chess)</td>
                        </tr>
                        <tr>
                            <td><strong>Limited Memory</strong></td>
                            <td>Uses past data to make decisions</td>
                            <td>Learning from historical data</td>
                            <td>Self-driving cars, ChatGPT</td>
                        </tr>
                        <tr>
                            <td><strong>Theory of Mind</strong></td>
                            <td>Understands emotions, beliefs (In Research)</td>
                            <td>Social intelligence</td>
                            <td>Advanced social robots</td>
                        </tr>
                        <tr>
                            <td><strong>Self-Aware AI</strong></td>
                            <td>Has consciousness (Hypothetical)</td>
                            <td>Human-like awareness</td>
                            <td>Sci-Fi concept (not yet achieved)</td>
                        </tr>
                    </tbody>
                </table>

                <div class="simple-explanation">
                    <div class="simple-explanation-title">
                        <i class="fas fa-lightbulb"></i>Think of AI Like This
                    </div>
                    <p>Imagine teaching a child to play chess:</p>
                    <ul style="margin: 15px 0 0 25px;">
                        <li><strong>Rules-based AI:</strong> You give them a rulebook - "If opponent does X, you do Y"</li>
                        <li><strong>Learning AI:</strong> They play 1000 games and figure out patterns themselves</li>
                        <li><strong>Search-based AI:</strong> They think ahead - "If I move here, they'll move there, then I can..."</li>
                    </ul>
                    <p style="margin-top: 15px;">This unit focuses on <span class="highlight">Search-based AI</span> - teaching computers to explore possibilities and find solutions!</p>
                </div>

                <!-- AI Search Techniques Taxonomy Diagram -->
                <h3><i class="fas fa-sitemap"></i>Taxonomy of AI Search Techniques</h3>

                <div class="chart-container" style="background: linear-gradient(135deg, #1e3a5f 0%, #0d1b2a 100%); padding: 30px; border-radius: 16px;">
                    <div class="chart-title" style="color: white; margin-bottom: 20px;">
                        <i class="fas fa-project-diagram"></i> Complete Hierarchy of Search Algorithms Covered in This Unit
                    </div>

                    <!-- Visual Taxonomy Tree -->
                    <div style="background: white; border-radius: 12px; padding: 30px; overflow-x: auto;">
                        <div style="text-align: center; min-width: 900px;">
                            <!-- Level 0: Root -->
                            <div style="display: inline-block; background: linear-gradient(135deg, #1e3a5f, #3d5a80); color: white; padding: 15px 40px; border-radius: 30px; font-weight: bold; font-size: 1.3em; box-shadow: 0 4px 15px rgba(0,0,0,0.3);">
                                AI SEARCH TECHNIQUES
                            </div>

                            <!-- Connector Lines Level 0->1 -->
                            <div style="display: flex; justify-content: center; margin: 10px 0;">
                                <div style="width: 2px; height: 30px; background: #3d5a80;"></div>
                            </div>
                            <div style="display: flex; justify-content: center; gap: 300px; position: relative;">
                                <div style="position: absolute; top: 0; left: 25%; right: 25%; height: 2px; background: #3d5a80;"></div>
                            </div>

                            <!-- Level 1: Main Categories -->
                            <div style="display: flex; justify-content: space-around; margin: 30px 0; gap: 20px;">
                                <!-- Uninformed Search -->
                                <div style="flex: 1; max-width: 280px;">
                                    <div style="background: linear-gradient(135deg, #7c3aed, #a855f7); color: white; padding: 12px 20px; border-radius: 20px; font-weight: bold; text-align: center;">
                                        <i class="fas fa-eye-slash"></i> UNINFORMED (Blind)
                                    </div>
                                    <div style="border-left: 2px solid #7c3aed; margin-left: 50%; height: 20px;"></div>
                                    <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                                        <div style="background: #ede9fe; border: 2px solid #7c3aed; padding: 8px 15px; border-radius: 8px; font-size: 0.9em; margin: 5px;">
                                            <strong>DFS</strong><br><span style="color:#666; font-size:0.8em;">Stack (LIFO)</span>
                                        </div>
                                        <div style="background: #ede9fe; border: 2px solid #7c3aed; padding: 8px 15px; border-radius: 8px; font-size: 0.9em; margin: 5px;">
                                            <strong>BFS</strong><br><span style="color:#666; font-size:0.8em;">Queue (FIFO)</span>
                                        </div>
                                        <div style="background: #ede9fe; border: 2px solid #7c3aed; padding: 8px 15px; border-radius: 8px; font-size: 0.9em; margin: 5px;">
                                            <strong>UCS</strong><br><span style="color:#666; font-size:0.8em;">Priority Queue</span>
                                        </div>
                                        <div style="background: #ede9fe; border: 2px solid #7c3aed; padding: 8px 15px; border-radius: 8px; font-size: 0.9em; margin: 5px;">
                                            <strong>DLS/IDDFS</strong><br><span style="color:#666; font-size:0.8em;">Depth Limited</span>
                                        </div>
                                    </div>
                                </div>

                                <!-- Informed Search -->
                                <div style="flex: 1; max-width: 280px;">
                                    <div style="background: linear-gradient(135deg, #22c55e, #16a34a); color: white; padding: 12px 20px; border-radius: 20px; font-weight: bold; text-align: center;">
                                        <i class="fas fa-lightbulb"></i> INFORMED (Heuristic)
                                    </div>
                                    <div style="border-left: 2px solid #22c55e; margin-left: 50%; height: 20px;"></div>
                                    <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                                        <div style="background: #dcfce7; border: 2px solid #22c55e; padding: 8px 15px; border-radius: 8px; font-size: 0.9em; margin: 5px;">
                                            <strong>Greedy Best-First</strong><br><span style="color:#666; font-size:0.8em;">Uses h(n) only</span>
                                        </div>
                                        <div style="background: #bbf7d0; border: 2px solid #16a34a; padding: 8px 15px; border-radius: 8px; font-size: 0.9em; margin: 5px; box-shadow: 0 2px 8px rgba(34,197,94,0.3);">
                                            <strong>A* Search</strong><br><span style="color:#666; font-size:0.8em;">f(n)=g(n)+h(n)</span>
                                        </div>
                                        <div style="background: #dcfce7; border: 2px solid #22c55e; padding: 8px 15px; border-radius: 8px; font-size: 0.9em; margin: 5px;">
                                            <strong>IDA*</strong><br><span style="color:#666; font-size:0.8em;">Iterative Deepening</span>
                                        </div>
                                    </div>
                                </div>

                                <!-- Local Search -->
                                <div style="flex: 1; max-width: 280px;">
                                    <div style="background: linear-gradient(135deg, #f59e0b, #d97706); color: white; padding: 12px 20px; border-radius: 20px; font-weight: bold; text-align: center;">
                                        <i class="fas fa-mountain"></i> LOCAL SEARCH
                                    </div>
                                    <div style="border-left: 2px solid #f59e0b; margin-left: 50%; height: 20px;"></div>
                                    <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                                        <div style="background: #fef3c7; border: 2px solid #f59e0b; padding: 8px 15px; border-radius: 8px; font-size: 0.9em; margin: 5px;">
                                            <strong>Hill Climbing</strong><br><span style="color:#666; font-size:0.8em;">Greedy Local</span>
                                        </div>
                                        <div style="background: #fef3c7; border: 2px solid #f59e0b; padding: 8px 15px; border-radius: 8px; font-size: 0.9em; margin: 5px;">
                                            <strong>Simulated Annealing</strong><br><span style="color:#666; font-size:0.8em;">With randomness</span>
                                        </div>
                                        <div style="background: #fef3c7; border: 2px solid #f59e0b; padding: 8px 15px; border-radius: 8px; font-size: 0.9em; margin: 5px;">
                                            <strong>Genetic Algorithms</strong><br><span style="color:#666; font-size:0.8em;">Population-based</span>
                                        </div>
                                    </div>
                                </div>

                                <!-- Adversarial Search -->
                                <div style="flex: 1; max-width: 280px;">
                                    <div style="background: linear-gradient(135deg, #ef4444, #dc2626); color: white; padding: 12px 20px; border-radius: 20px; font-weight: bold; text-align: center;">
                                        <i class="fas fa-chess"></i> ADVERSARIAL (Games)
                                    </div>
                                    <div style="border-left: 2px solid #ef4444; margin-left: 50%; height: 20px;"></div>
                                    <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                                        <div style="background: #fee2e2; border: 2px solid #ef4444; padding: 8px 15px; border-radius: 8px; font-size: 0.9em; margin: 5px;">
                                            <strong>Mini-Max</strong><br><span style="color:#666; font-size:0.8em;">MAX vs MIN</span>
                                        </div>
                                        <div style="background: #fecaca; border: 2px solid #dc2626; padding: 8px 15px; border-radius: 8px; font-size: 0.9em; margin: 5px; box-shadow: 0 2px 8px rgba(239,68,68,0.3);">
                                            <strong>Alpha-Beta</strong><br><span style="color:#666; font-size:0.8em;">Pruning optimization</span>
                                        </div>
                                        <div style="background: #fee2e2; border: 2px solid #ef4444; padding: 8px 15px; border-radius: 8px; font-size: 0.9em; margin: 5px;">
                                            <strong>MCTS</strong><br><span style="color:#666; font-size:0.8em;">Monte Carlo Tree</span>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Special Categories Row -->
                            <div style="margin-top: 30px; padding-top: 20px; border-top: 2px dashed #cbd5e1;">
                                <div style="display: flex; justify-content: center; gap: 40px;">
                                    <div style="text-align: center;">
                                        <div style="background: linear-gradient(135deg, #0ea5e9, #0284c7); color: white; padding: 10px 25px; border-radius: 15px; font-weight: bold; display: inline-block;">
                                            <i class="fas fa-puzzle-piece"></i> CSP (Constraint Satisfaction)
                                        </div>
                                        <div style="display: flex; gap: 10px; justify-content: center; margin-top: 10px;">
                                            <span style="background: #e0f2fe; border: 2px solid #0ea5e9; padding: 5px 12px; border-radius: 6px; font-size: 0.85em;">Backtracking</span>
                                            <span style="background: #e0f2fe; border: 2px solid #0ea5e9; padding: 5px 12px; border-radius: 6px; font-size: 0.85em;">Arc Consistency</span>
                                        </div>
                                    </div>
                                    <div style="text-align: center;">
                                        <div style="background: linear-gradient(135deg, #6366f1, #4f46e5); color: white; padding: 10px 25px; border-radius: 15px; font-weight: bold; display: inline-block;">
                                            <i class="fas fa-code-branch"></i> AND-OR Graphs
                                        </div>
                                        <div style="display: flex; gap: 10px; justify-content: center; margin-top: 10px;">
                                            <span style="background: #e0e7ff; border: 2px solid #6366f1; padding: 5px 12px; border-radius: 6px; font-size: 0.85em;">AO* Algorithm</span>
                                            <span style="background: #e0e7ff; border: 2px solid #6366f1; padding: 5px 12px; border-radius: 6px; font-size: 0.85em;">Problem Decomposition</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Legend -->
                    <div style="display: flex; justify-content: center; gap: 25px; margin-top: 20px; flex-wrap: wrap;">
                        <div style="color: white; font-size: 0.9em;"><span style="background:#7c3aed; padding:3px 10px; border-radius:4px;">Uninformed</span> No goal knowledge</div>
                        <div style="color: white; font-size: 0.9em;"><span style="background:#22c55e; padding:3px 10px; border-radius:4px;">Informed</span> Uses heuristics</div>
                        <div style="color: white; font-size: 0.9em;"><span style="background:#f59e0b; padding:3px 10px; border-radius:4px;">Local</span> Optimization focus</div>
                        <div style="color: white; font-size: 0.9em;"><span style="background:#ef4444; padding:3px 10px; border-radius:4px;">Adversarial</span> Competitive games</div>
                    </div>
                </div>

                <!-- Quick Reference Table -->
                <div style="margin-top: 20px; overflow-x: auto;">
                    <table>
                        <thead>
                            <tr style="background: linear-gradient(135deg, #1e3a5f, #3d5a80); color: white;">
                                <th>Algorithm</th>
                                <th>Category</th>
                                <th>Data Structure</th>
                                <th>Complete?</th>
                                <th>Optimal?</th>
                                <th>Best Use Case</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr style="background:#ede9fe;"><td><strong>DFS</strong></td><td>Uninformed</td><td>Stack</td><td>No*</td><td>No</td><td>Deep solutions, memory-limited</td></tr>
                            <tr style="background:#ede9fe;"><td><strong>BFS</strong></td><td>Uninformed</td><td>Queue</td><td>Yes</td><td>Yes**</td><td>Shortest path (unit cost)</td></tr>
                            <tr style="background:#dcfce7;"><td><strong>Greedy Best-First</strong></td><td>Informed</td><td>Priority Queue</td><td>No</td><td>No</td><td>Fast but suboptimal</td></tr>
                            <tr style="background:#bbf7d0;"><td><strong>A*</strong></td><td>Informed</td><td>Priority Queue</td><td>Yes</td><td>Yes</td><td>Optimal pathfinding</td></tr>
                            <tr style="background:#fef3c7;"><td><strong>Hill Climbing</strong></td><td>Local</td><td>Current state only</td><td>No</td><td>No</td><td>Optimization, low memory</td></tr>
                            <tr style="background:#fee2e2;"><td><strong>Mini-Max</strong></td><td>Adversarial</td><td>Game Tree</td><td>Yes</td><td>Yes</td><td>Perfect information games</td></tr>
                            <tr style="background:#fecaca;"><td><strong>Alpha-Beta</strong></td><td>Adversarial</td><td>Game Tree + Pruning</td><td>Yes</td><td>Yes</td><td>Same as Mini-Max, faster</td></tr>
                        </tbody>
                    </table>
                    <p style="font-size: 0.85em; color: #666; margin-top: 5px;">*Complete for finite graphs with cycle detection | **Optimal for uniform edge costs</p>
                </div>

                <!-- Example 1: Basic -->
                <div class="example">
                    <div class="example-title">
                        <i class="fas fa-flask"></i>Example 1: Simple AI Decision System
                        <span class="example-level basic">BASIC</span>
                    </div>
                    <p><strong>Scenario:</strong> Create a rule-based AI that recommends activities based on weather.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-lang"><i class="fab fa-python"></i> Python</span>
                        <button class="copy-button" onclick="copyCode(this)">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <div class="code-block"><span class="comment"># Simple Rule-Based AI System</span>
<span class="keyword">class</span> <span class="class">WeatherAdvisorAI</span>:
    <span class="string">"""A simple rule-based AI for activity recommendations"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        <span class="comment"># Knowledge base: weather conditions -> activities</span>
        self.rules = {
            <span class="string">'sunny'</span>: [<span class="string">'Go for a hike'</span>, <span class="string">'Have a picnic'</span>, <span class="string">'Play outdoor sports'</span>],
            <span class="string">'rainy'</span>: [<span class="string">'Read a book'</span>, <span class="string">'Watch movies'</span>, <span class="string">'Cook a new recipe'</span>],
            <span class="string">'snowy'</span>: [<span class="string">'Build a snowman'</span>, <span class="string">'Go skiing'</span>, <span class="string">'Drink hot cocoa'</span>],
            <span class="string">'cloudy'</span>: [<span class="string">'Visit a museum'</span>, <span class="string">'Go shopping'</span>, <span class="string">'Cafe hopping'</span>]
        }

    <span class="keyword">def</span> <span class="function">recommend</span>(self, weather):
        <span class="string">"""AI inference: Apply rules to get recommendation"""</span>
        weather = weather.lower()
        <span class="keyword">if</span> weather <span class="keyword">in</span> self.rules:
            <span class="keyword">return</span> self.rules[weather]
        <span class="keyword">return</span> [<span class="string">"Stay flexible - weather unknown!"</span>]

    <span class="keyword">def</span> <span class="function">explain_reasoning</span>(self, weather):
        <span class="string">"""Explainable AI: Show how decision was made"""</span>
        <span class="keyword">return</span> <span class="string">f"Rule applied: IF weather == '{weather}' THEN suggest {self.rules.get(weather.lower(), 'default')}"</span>

<span class="comment"># Usage</span>
advisor = WeatherAdvisorAI()
<span class="function">print</span>(<span class="string">"Weather: Sunny"</span>)
<span class="function">print</span>(<span class="string">"Recommendations:"</span>, advisor.recommend(<span class="string">'sunny'</span>))
<span class="function">print</span>(advisor.explain_reasoning(<span class="string">'sunny'</span>))

<span class="comment"># Output:</span>
<span class="comment"># Weather: Sunny</span>
<span class="comment"># Recommendations: ['Go for a hike', 'Have a picnic', 'Play outdoor sports']</span>
<span class="comment"># Rule applied: IF weather == 'sunny' THEN suggest ['Go for a hike', ...]</span></div>
                </div>

                <!-- Example 2: Industry -->
                <div class="example">
                    <div class="example-title">
                        <i class="fas fa-industry"></i>Example 2: AI in E-Commerce Product Recommendation
                        <span class="example-level industry">INDUSTRY</span>
                    </div>
                    <p><strong>Real-World Application:</strong> Amazon, Netflix, Spotify use AI to recommend products/content. Here's a simplified version.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-lang"><i class="fab fa-python"></i> Python</span>
                        <button class="copy-button" onclick="copyCode(this)">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <div class="code-block"><span class="comment"># Industry Example: Simple Collaborative Filtering</span>
<span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict

<span class="keyword">class</span> <span class="class">ProductRecommenderAI</span>:
    <span class="string">"""AI system for product recommendations (simplified collaborative filtering)"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        <span class="comment"># User purchase history database</span>
        self.user_purchases = {
            <span class="string">'user1'</span>: [<span class="string">'laptop'</span>, <span class="string">'mouse'</span>, <span class="string">'keyboard'</span>],
            <span class="string">'user2'</span>: [<span class="string">'laptop'</span>, <span class="string">'headphones'</span>, <span class="string">'webcam'</span>],
            <span class="string">'user3'</span>: [<span class="string">'phone'</span>, <span class="string">'case'</span>, <span class="string">'charger'</span>],
            <span class="string">'user4'</span>: [<span class="string">'laptop'</span>, <span class="string">'mouse'</span>, <span class="string">'monitor'</span>],
            <span class="string">'user5'</span>: [<span class="string">'phone'</span>, <span class="string">'earbuds'</span>, <span class="string">'case'</span>]
        }

    <span class="keyword">def</span> <span class="function">find_similar_users</span>(self, target_user):
        <span class="string">"""Find users with similar purchase patterns"""</span>
        target_items = <span class="function">set</span>(self.user_purchases.get(target_user, []))
        similarity_scores = {}

        <span class="keyword">for</span> user, items <span class="keyword">in</span> self.user_purchases.items():
            <span class="keyword">if</span> user != target_user:
                <span class="comment"># Jaccard similarity: intersection / union</span>
                common = target_items.intersection(<span class="function">set</span>(items))
                total = target_items.union(<span class="function">set</span>(items))
                similarity_scores[user] = <span class="function">len</span>(common) / <span class="function">len</span>(total) <span class="keyword">if</span> total <span class="keyword">else</span> <span class="number">0</span>

        <span class="keyword">return</span> <span class="function">sorted</span>(similarity_scores.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="keyword">True</span>)

    <span class="keyword">def</span> <span class="function">recommend</span>(self, target_user, n=<span class="number">3</span>):
        <span class="string">"""Recommend products based on similar users' purchases"""</span>
        target_items = <span class="function">set</span>(self.user_purchases.get(target_user, []))
        similar_users = self.find_similar_users(target_user)

        <span class="comment"># Collect items from similar users that target hasn't bought</span>
        recommendations = defaultdict(<span class="function">float</span>)
        <span class="keyword">for</span> user, similarity <span class="keyword">in</span> similar_users[:3]:  <span class="comment"># Top 3 similar users</span>
            <span class="keyword">for</span> item <span class="keyword">in</span> self.user_purchases[user]:
                <span class="keyword">if</span> item <span class="keyword">not in</span> target_items:
                    recommendations[item] += similarity

        <span class="comment"># Sort by recommendation score</span>
        <span class="keyword">return</span> <span class="function">sorted</span>(recommendations.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="keyword">True</span>)[:n]

<span class="comment"># Usage: Recommend for user1</span>
recommender = ProductRecommenderAI()
<span class="function">print</span>(<span class="string">"User1 purchased:"</span>, recommender.user_purchases[<span class="string">'user1'</span>])
<span class="function">print</span>(<span class="string">"Similar users:"</span>, recommender.find_similar_users(<span class="string">'user1'</span>))
<span class="function">print</span>(<span class="string">"Recommendations:"</span>, recommender.recommend(<span class="string">'user1'</span>))

<span class="comment"># Output:</span>
<span class="comment"># User1 purchased: ['laptop', 'mouse', 'keyboard']</span>
<span class="comment"># Similar users: [('user4', 0.4), ('user2', 0.25), ...]</span>
<span class="comment"># Recommendations: [('monitor', 0.4), ('headphones', 0.25), ('webcam', 0.25)]</span></div>
                </div>

                <div class="case-study">
                    <div class="case-study-title">
                        <i class="fas fa-building"></i>Case Study: Google Search - AI at Scale
                    </div>
                    <p><strong>Problem:</strong> Search billions of web pages and return relevant results in milliseconds.</p>
                    <p><strong>AI Techniques Used:</strong></p>
                    <ul style="margin: 15px 0 0 25px;">
                        <li><strong>PageRank Algorithm:</strong> Graph-based search to rank page importance</li>
                        <li><strong>Natural Language Processing:</strong> Understanding search intent</li>
                        <li><strong>Machine Learning:</strong> RankBrain learns from user behavior</li>
                        <li><strong>Knowledge Graphs:</strong> Structured representation of world knowledge</li>
                    </ul>
                    <p style="margin-top: 15px;"><strong>Result:</strong> 8.5 billion searches per day with sub-second response times!</p>

                    <!-- Detailed Breakdown -->
                    <div style="margin-top: 25px; background: #f0f9ff; padding: 20px; border-radius: 12px; border: 2px solid #0284c7;">
                        <h4 style="color: #0369a1; margin-bottom: 15px;"><i class="fas fa-project-diagram"></i> How PageRank Works - Step by Step</h4>

                        <!-- Architecture Diagram -->
                        <div style="background: #1e293b; color: #e2e8f0; padding: 20px; border-radius: 8px; font-family: monospace; font-size: 0.85em; overflow-x: auto;" role="img" aria-label="Google Search Architecture Diagram: Shows a user query flowing through Query Parser (NLP), then Index Lookup, then PageRank Sort. Below shows web pages as a graph with arrows indicating which pages link to which, demonstrating how more inbound links result in higher PageRank.">
                        <p class="sr-only" style="position: absolute; left: -10000px; width: 1px; height: 1px; overflow: hidden;">Diagram description: A flowchart showing Google search processing. User query enters Query Parser for intent understanding, then Index Lookup finds matching pages, and PageRank Sort ranks them by link importance. The web is visualized as a graph where pages with more incoming links have higher authority.</p>
<pre style="margin: 0;">

                        GOOGLE SEARCH ARCHITECTURE                            

                                                                              
   USER QUERY: "best pizza near me"                                          
                                                                             
                                                                             
                   
     Query Parser      Index Lookup    PageRank Sort          
     (NLP/Intent)         (Inverted Idx)        (Graph Walk)          
                   
                                                                          
                                                                          
   "pizza" + "near"        Find all pages         Rank by:                   
   + location context      containing terms       - Inbound links            
                                                  - Link quality             
                                                  - User signals             
                                                                              
      
                       WEB AS A GRAPH                                       
                                                                            
         [Pizza Blog][Best Pizza NYC][Food Review]           
                                                                         
                                                                         
              [Local Restaurant]                   
                                                                           
                                                                           
                      More inbound links = Higher PageRank                  
      
                                                                              
   RESULT: Ordered list of most relevant, authoritative pages                

</pre>
                        </div>

                        <!-- Working Code Example -->
                        <h5 style="color: #0369a1; margin: 20px 0 10px 0;"><i class="fas fa-code"></i> Simplified PageRank Implementation</h5>
                        <div class="code-container" style="margin: 0;">
                            <div class="code-header">
                                <span class="code-lang"><i class="fab fa-python"></i> Python - PageRank Algorithm</span>
                                <button class="copy-button" onclick="copyCode(this)">
                                    <i class="fas fa-copy"></i> Copy
                                </button>
                            </div>
                            <div class="code-block"><span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="keyword">def</span> <span class="function">pagerank</span>(graph, damping=<span class="number">0.85</span>, iterations=<span class="number">100</span>):
    <span class="string">"""
    PageRank Algorithm - How Google ranks web pages

    The CORE IDEA: A page is important if important pages link to it.
    Like academic citations - papers cited by important papers are important!

    Args:
        graph: dict mapping page -> list of pages it links TO
        damping: probability of following a link (vs random jump)
        iterations: number of times to refine rankings
    """</span>
    <span class="comment"># Step 1: Get all pages in the web</span>
    pages = <span class="function">list</span>(graph.keys())
    n = <span class="function">len</span>(pages)
    page_idx = {page: i <span class="keyword">for</span> i, page <span class="keyword">in</span> <span class="function">enumerate</span>(pages)}

    <span class="comment"># Step 2: Initialize - every page starts with equal importance</span>
    rank = np.ones(n) / n  <span class="comment"># Each page has 1/n importance</span>
    <span class="comment"># OUTPUT: rank = [0.2, 0.2, 0.2, 0.2, 0.2] for 5 pages</span>

    <span class="comment"># Step 3: Build transition matrix (who links to whom)</span>
    <span class="comment"># If page A links to B and C, it gives half its rank to each</span>
    M = np.zeros((n, n))
    <span class="keyword">for</span> page, links <span class="keyword">in</span> graph.items():
        <span class="keyword">if</span> links:  <span class="comment"># If page has outgoing links</span>
            <span class="keyword">for</span> linked_page <span class="keyword">in</span> links:
                <span class="keyword">if</span> linked_page <span class="keyword">in</span> page_idx:
                    <span class="comment"># Page gives (1/num_links) of its rank to each linked page</span>
                    M[page_idx[linked_page]][page_idx[page]] = <span class="number">1.0</span> / <span class="function">len</span>(links)

    <span class="comment"># Step 4: Iterate until ranks stabilize</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(iterations):
        <span class="comment"># New rank = damping * (rank from links) + (1-damping) * (random surfer)</span>
        new_rank = damping * M.dot(rank) + (<span class="number">1</span> - damping) / n

        <span class="comment"># Check if converged (ranks stopped changing)</span>
        <span class="keyword">if</span> np.allclose(rank, new_rank, atol=<span class="number">1e-8</span>):
            <span class="function">print</span>(<span class="string">f"Converged after {i+1} iterations"</span>)
            <span class="keyword">break</span>
        rank = new_rank

    <span class="comment"># Return sorted pages by importance</span>
    <span class="keyword">return</span> {pages[i]: rank[i] <span class="keyword">for</span> i <span class="keyword">in</span> np.argsort(rank)[::-<span class="number">1</span>]}

<span class="comment"># </span>
<span class="comment"># EXAMPLE: Mini web of 5 pages</span>
<span class="comment"># </span>
web_graph = {
    <span class="string">'Homepage'</span>: [<span class="string">'About'</span>, <span class="string">'Products'</span>, <span class="string">'Blog'</span>],
    <span class="string">'About'</span>: [<span class="string">'Homepage'</span>],
    <span class="string">'Products'</span>: [<span class="string">'Homepage'</span>, <span class="string">'Blog'</span>],
    <span class="string">'Blog'</span>: [<span class="string">'Homepage'</span>, <span class="string">'Products'</span>],
    <span class="string">'Contact'</span>: [<span class="string">'Homepage'</span>]  <span class="comment"># Only links to homepage (low authority)</span>
}

rankings = pagerank(web_graph)
<span class="function">print</span>(<span class="string">"\nPageRank Results:"</span>)
<span class="keyword">for</span> page, score <span class="keyword">in</span> rankings.items():
    bar = <span class="string">''</span> * <span class="function">int</span>(score * <span class="number">50</span>)
    <span class="function">print</span>(<span class="string">f"  {page:12} {score:.4f} {bar}"</span>)

<span class="comment"># OUTPUT:
# Converged after 23 iterations
#
# PageRank Results:
#   Homepage     0.3874 
#   Blog         0.1994 
#   Products     0.1994 
#   About        0.1136 
#   Contact      0.1002 
#
# INSIGHT: Homepage has highest rank because EVERYONE links to it!
# Blog and Products tie because they have similar link structures.</span></div>
                        </div>

                        <!-- Step-by-Step Explanation -->
                        <h5 style="color: #0369a1; margin: 20px 0 10px 0;"><i class="fas fa-list-ol"></i> Step-by-Step Walkthrough</h5>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                            <div style="background: white; padding: 15px; border-radius: 8px; border-left: 4px solid #3b82f6;">
                                <strong style="color: #1e40af;">Step 1: Build Web Graph</strong>
                                <p style="font-size: 0.9em; margin-top: 5px;">Crawl web pages and record which page links to which. This creates a directed graph with billions of nodes.</p>
                            </div>
                            <div style="background: white; padding: 15px; border-radius: 8px; border-left: 4px solid #10b981;">
                                <strong style="color: #065f46;">Step 2: Initialize Ranks</strong>
                                <p style="font-size: 0.9em; margin-top: 5px;">Give every page equal initial importance (1/N). We don't know who's important yet!</p>
                            </div>
                            <div style="background: white; padding: 15px; border-radius: 8px; border-left: 4px solid #f59e0b;">
                                <strong style="color: #92400e;">Step 3: Distribute Rank</strong>
                                <p style="font-size: 0.9em; margin-top: 5px;">Each page shares its rank with pages it links to. More outgoing links = less rank per link.</p>
                            </div>
                            <div style="background: white; padding: 15px; border-radius: 8px; border-left: 4px solid #ef4444;">
                                <strong style="color: #991b1b;">Step 4: Iterate</strong>
                                <p style="font-size: 0.9em; margin-top: 5px;">Repeat until ranks stabilize. Pages with many incoming links from important pages rise to top!</p>
                            </div>
                        </div>

                        <div style="background: #fef3c7; padding: 15px; border-radius: 8px; margin-top: 15px;">
                            <strong><i class="fas fa-lightbulb"></i> Key Insight:</strong> PageRank uses the structure of the web (who links to whom) as a "voting" system. Each link is a vote, and votes from important pages count more!
                        </div>

                        <!-- Practice Exercise for PageRank -->
                        <div style="background: #ecfdf5; padding: 20px; border-radius: 12px; margin-top: 20px; border: 2px dashed #10b981;">
                            <h5 style="color: #065f46; margin-bottom: 15px;"><i class="fas fa-pencil-alt"></i> Practice Exercise: PageRank</h5>

                            <p style="margin-bottom: 15px;"><strong>Exercise 1:</strong> Given the following web graph, calculate PageRank after 2 iterations (damping = 0.85):</p>
                            <pre style="background: #1e293b; color: #e2e8f0; padding: 15px; border-radius: 8px; font-family: monospace;">
    A  B  C
                 
    

    Links: AB, AC, BC, CA
                            </pre>

                            <details style="margin-top: 15px;">
                                <summary style="cursor: pointer; color: #065f46; font-weight: bold;"><i class="fas fa-eye"></i> Show Solution</summary>
                                <div style="margin-top: 10px; padding: 15px; background: white; border-radius: 8px;">
                                    <p><strong>Initial:</strong> rank_A = rank_B = rank_C = 1/3  0.333</p>
                                    <p><strong>Iteration 1:</strong></p>
                                    <ul>
                                        <li>A receives from C: 0.85  (0.333/1) + 0.15/3 = 0.333</li>
                                        <li>B receives from A: 0.85  (0.333/2) + 0.15/3 = 0.192</li>
                                        <li>C receives from A,B: 0.85  (0.333/2 + 0.333/1) + 0.15/3 = 0.475</li>
                                    </ul>
                                    <p><strong>Insight:</strong> C has highest rank because it receives links from both A and B!</p>
                                </div>
                            </details>

                            <p style="margin-top: 20px;"><strong>Exercise 2:</strong> Modify the Python code above to handle "dangling nodes" (pages with no outgoing links). What happens if we don't handle them?</p>

                            <details style="margin-top: 15px;">
                                <summary style="cursor: pointer; color: #065f46; font-weight: bold;"><i class="fas fa-eye"></i> Show Hint</summary>
                                <div style="margin-top: 10px; padding: 15px; background: white; border-radius: 8px;">
                                    <p><strong>Hint:</strong> Dangling nodes "absorb" rank without redistributing it. Solution: Make them link to all pages (uniform distribution) or redistribute their rank equally.</p>
                                    <pre style="background: #1e293b; color: #e2e8f0; padding: 10px; border-radius: 4px; font-size: 0.85em;">
# Handle dangling nodes
if not links:  # No outgoing links
    M[:, page_idx[page]] = 1.0 / n  # Distribute to all</pre>
                                </div>
                            </details>
                        </div>
                    </div>
                </div>

                <div class="qa-box">
                    <h4><i class="fas fa-question-circle"></i>CO1 Sample Questions - Introduction to AI</h4>

                    <div class="question">
                        <strong>Q1:</strong> Define Artificial Intelligence. What are the four main approaches to AI?
                        <div class="answer">
                            <strong>Answer:</strong> AI is the study of agents that receive percepts from the environment and perform actions. Four approaches:
                            <br>(1) <em>Acting humanly</em> - Turing Test approach
                            <br>(2) <em>Thinking humanly</em> - Cognitive modeling
                            <br>(3) <em>Thinking rationally</em> - Laws of thought/Logic
                            <br>(4) <em>Acting rationally</em> - Rational agent approach (most common in modern AI)
                        </div>
                    </div>

                    <div class="question">
                        <strong>Q2:</strong> Differentiate between Strong AI and Weak AI with examples.
                        <div class="answer">
                            <strong>Answer:</strong>
                            <br><strong>Weak AI (Narrow AI):</strong> Designed for specific tasks. Examples: Siri, Chess engines, spam filters.
                            <br><strong>Strong AI (General AI):</strong> Hypothetical AI with human-level intelligence across all domains. Can transfer learning across tasks. Currently doesn't exist.
                        </div>
                    </div>
                </div>
            </section>

            <!-- ==================== SECTION 2: PROBLEM REPRESENTATION ==================== -->
            <section id="problem">
                <h2><i class="fas fa-puzzle-piece"></i>2. Well-Defined Problem Representation & State Space</h2>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>Well-Defined Problem:</strong> A problem that can be formally described with a clear initial state, goal state, set of possible actions, and a way to determine when the goal is reached.</p>
                </div>

                <!-- Real-World Analogy -->
                <div class="analogy-box">
                    <div class="analogy-header">
                        <i class="fas fa-lightbulb"></i> Real-World Analogy: Planning Your Morning Routine
                    </div>
                    <p>Imagine you wake up at 7:00 AM and need to reach office by 9:00 AM. This everyday situation is actually a <strong>search problem</strong> that your brain solves automatically!</p>

                    <div class="analogy-scenario">
                        <h5>Breaking Down Your Morning as a Search Problem:</h5>
                        <table style="width:100%; margin-top:10px;">
                            <tr>
                                <td><strong>Initial State:</strong></td>
                                <td>You are in bed, not dressed, haven't eaten, at home</td>
                            </tr>
                            <tr>
                                <td><strong>Goal State:</strong></td>
                                <td>You are at office, dressed properly, have had breakfast</td>
                            </tr>
                            <tr>
                                <td><strong>Actions:</strong></td>
                                <td>Wake up, Brush teeth, Shower, Get dressed, Eat breakfast, Take bus/drive, Walk to office</td>
                            </tr>
                            <tr>
                                <td><strong>Constraints:</strong></td>
                                <td>Can't eat before waking up, can't drive before getting dressed, must reach before 9 AM</td>
                            </tr>
                            <tr>
                                <td><strong>Path Cost:</strong></td>
                                <td>Total time taken for all activities</td>
                            </tr>
                        </table>
                    </div>

                    <p style="margin-top:15px;"><strong>The Search:</strong> Your brain quickly evaluates different "paths" - Should you shower first or eat first? Take bus or drive? Each choice leads to a different sequence of states, and you pick the one that gets you to the goal (office by 9 AM) most efficiently!</p>
                </div>

                <!-- Chew & Feed Explanation -->
                <div class="chew-feed-box">
                    <div class="cf-header">
                        <i class="fas fa-utensils"></i> Breaking It Down: Simple Language Explanation
                    </div>

                    <div class="simple-terms">
                        <h5>Think of Problem Representation Like a Video Game:</h5>

                        <div class="term-explain">
                            <span class="term">State</span>
                            <span>A "screenshot" of your game at any moment. It captures EVERYTHING about where you are - your position, your health, items you have, enemies around you. In real life, a state is like a snapshot of your current situation.</span>
                        </div>

                        <div class="term-explain">
                            <span class="term">Initial State</span>
                            <span>The first screen when you start a new game. You're at level 1, starting position, with basic equipment. This is where you BEGIN your journey.</span>
                        </div>

                        <div class="term-explain">
                            <span class="term">Goal State</span>
                            <span>The "You Win!" screen. The final boss is defeated, the princess is saved, or you've completed the mission. This is what you're trying to ACHIEVE.</span>
                        </div>

                        <div class="term-explain">
                            <span class="term">Actions</span>
                            <span>The buttons you can press - Jump, Attack, Move Left, Move Right, Use Item. These are the CHOICES available to you at any moment.</span>
                        </div>

                        <div class="term-explain">
                            <span class="term">Transition</span>
                            <span>What happens when you press a button. Press "Jump" and your character moves from ground to air. One state CHANGES to another state.</span>
                        </div>

                        <div class="term-explain">
                            <span class="term">Path Cost</span>
                            <span>How much "effort" it takes - maybe time, money, energy, or game coins. The PRICE you pay to go from start to finish.</span>
                        </div>
                    </div>
                </div>

                <!-- Daily Life Connections -->
                <div class="daily-life-box">
                    <div class="daily-header">
                        <i class="fas fa-home"></i> How You Already Solve Search Problems Every Day
                    </div>

                    <div class="daily-example">
                        <h5><i class="fas fa-utensils"></i> Cooking a Meal</h5>
                        <p><strong>Initial State:</strong> Raw ingredients in kitchen</p>
                        <p><strong>Goal State:</strong> Cooked dish on table</p>
                        <p><strong>Actions:</strong> Chop vegetables, boil water, add spices, stir, serve</p>
                        <p><strong>Constraints:</strong> Must boil water before adding pasta, must chop before frying</p>
                        <p><strong>Search Problem:</strong> What order should I do things to cook fastest?</p>
                    </div>

                    <div class="daily-example">
                        <h5><i class="fas fa-shopping-cart"></i> Shopping at a Mall</h5>
                        <p><strong>Initial State:</strong> At mall entrance with shopping list</p>
                        <p><strong>Goal State:</strong> All items purchased, at exit</p>
                        <p><strong>Actions:</strong> Go to Store A, Buy item X, Move to Store B, etc.</p>
                        <p><strong>Path Cost:</strong> Total walking distance + time in queues</p>
                        <p><strong>Search Problem:</strong> What route through mall minimizes walking?</p>
                    </div>

                    <div class="daily-example">
                        <h5><i class="fas fa-graduation-cap"></i> Completing Your Degree</h5>
                        <p><strong>Initial State:</strong> Freshman with 0 credits</p>
                        <p><strong>Goal State:</strong> All required credits + degree requirements met</p>
                        <p><strong>Actions:</strong> Take Course A, Take Course B, Do Internship, Write Thesis</p>
                        <p><strong>Constraints:</strong> Prerequisites (must take Calculus 1 before Calculus 2)</p>
                        <p><strong>Search Problem:</strong> What course sequence gets me to graduation efficiently?</p>
                    </div>
                </div>

                <!-- Why It Matters -->
                <div class="why-matters-box">
                    <div class="why-header">
                        <i class="fas fa-exclamation-circle"></i> Why Problem Representation is CRUCIAL
                    </div>
                    <ul>
                        <li><strong>Wrong representation = Unsolvable problem.</strong> If you define the 8-puzzle with only 3 moves instead of 4, the computer will never find a solution even if one exists!</li>
                        <li><strong>Good representation = Fast solution.</strong> Representing a chess game with the right state structure can reduce search time from years to seconds.</li>
                        <li><strong>Real companies spend millions on this.</strong> Google Maps' success comes from how they represent road networks. Uber's efficiency comes from how they represent driver-rider matching.</li>
                        <li><strong>It's the foundation of AI.</strong> Before any fancy algorithm runs, the problem must be properly defined. Garbage in = Garbage out!</li>
                    </ul>
                </div>

                <div class="wwwh-grid">
                    <div class="wwwh-item what">
                        <h4><i class="fas fa-question-circle"></i>WHAT is Problem Representation?</h4>
                        <p>Converting a real-world problem into a formal structure with states, actions, transitions, and goals that an AI system can process and solve.</p>
                    </div>
                    <div class="wwwh-item why">
                        <h4><i class="fas fa-lightbulb"></i>WHY is it Important?</h4>
                        <p>Proper representation determines if a problem is solvable, which algorithms apply, and how efficient the solution will be. Bad representation = unsolvable!</p>
                    </div>
                    <div class="wwwh-item when">
                        <h4><i class="fas fa-clock"></i>WHEN to Use State Space?</h4>
                        <p>When problems can be decomposed into discrete states and transitions - puzzles, path finding, planning, games, scheduling.</p>
                    </div>
                    <div class="wwwh-item how">
                        <h4><i class="fas fa-cogs"></i>HOW to Define a Problem?</h4>
                        <p>Define: (1) Initial state, (2) Actions/Operators, (3) Transition model, (4) Goal test, (5) Path cost function.</p>
                    </div>
                </div>

                <h3><i class="fas fa-sitemap"></i>Components of a Well-Defined Problem</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Component</th>
                            <th>Description</th>
                            <th>8-Puzzle Example</th>
                            <th>Route Finding Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Initial State</strong></td>
                            <td>Starting configuration</td>
                            <td>Scrambled puzzle configuration</td>
                            <td>Starting city (e.g., Arad)</td>
                        </tr>
                        <tr>
                            <td><strong>Actions</strong></td>
                            <td>Possible moves/operations</td>
                            <td>{Move blank: UP, DOWN, LEFT, RIGHT}</td>
                            <td>{Go to adjacent city}</td>
                        </tr>
                        <tr>
                            <td><strong>Transition Model</strong></td>
                            <td>Result of applying action</td>
                            <td>RESULT(state, action) = new puzzle state</td>
                            <td>RESULT(Arad, Go-Sibiu) = Sibiu</td>
                        </tr>
                        <tr>
                            <td><strong>Goal Test</strong></td>
                            <td>Check if goal reached</td>
                            <td>Is puzzle in sorted order?</td>
                            <td>Is current city = Bucharest?</td>
                        </tr>
                        <tr>
                            <td><strong>Path Cost</strong></td>
                            <td>Cost of solution path</td>
                            <td>Number of moves</td>
                            <td>Total distance traveled</td>
                        </tr>
                    </tbody>
                </table>

                <h3><i class="fas fa-project-diagram"></i>State Space Representation</h3>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>State Space:</strong> The set of all possible states reachable from the initial state by any sequence of actions. It can be represented as a graph where nodes are states and edges are actions/transitions.</p>
                </div>

                <div class="state-space-diagram">
                    <h4 style="margin-bottom: 20px;">State Space Graph Visualization</h4>
                    <canvas id="stateSpaceCanvas" width="700" height="300"></canvas>
                    <p style="margin-top: 15px; color: #666;">Green = Start State, Yellow = Goal State, Blue = Intermediate States</p>
                </div>

                <!-- Example 1: Basic 8-Puzzle -->
                <div class="example">
                    <div class="example-title">
                        <i class="fas fa-flask"></i>Example 1: 8-Puzzle Problem Formulation
                        <span class="example-level basic">BASIC</span>
                    </div>
                    <p><strong>Problem:</strong> Define the 8-puzzle as a well-defined search problem.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-lang"><i class="fab fa-python"></i> Python</span>
                        <button class="copy-button" onclick="copyCode(this)">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <div class="code-block"><span class="comment"># 8-Puzzle Problem Representation</span>
<span class="keyword">class</span> <span class="class">EightPuzzle</span>:
    <span class="string">"""
    8-Puzzle Problem Formulation

    Goal State:         Initial State (example):
    1 2 3               2 8 3
    4 5 6               1 6 4
    7 8 _               7 _ 5
    """</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self, initial_state):
        <span class="comment"># State: 3x3 tuple of tuples (immutable for hashing)</span>
        self.initial_state = <span class="function">tuple</span>(<span class="function">tuple</span>(row) <span class="keyword">for</span> row <span class="keyword">in</span> initial_state)
        self.goal_state = (
            (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),
            (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>),
            (<span class="number">7</span>, <span class="number">8</span>, <span class="number">0</span>)  <span class="comment"># 0 represents blank</span>
        )

    <span class="keyword">def</span> <span class="function">find_blank</span>(self, state):
        <span class="string">"""Find position of blank tile (0)"""</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(<span class="number">3</span>):
            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="function">range</span>(<span class="number">3</span>):
                <span class="keyword">if</span> state[i][j] == <span class="number">0</span>:
                    <span class="keyword">return</span> (i, j)

    <span class="keyword">def</span> <span class="function">actions</span>(self, state):
        <span class="string">"""Return list of valid actions from current state"""</span>
        row, col = self.find_blank(state)
        possible_actions = []

        <span class="keyword">if</span> row > <span class="number">0</span>: possible_actions.append(<span class="string">'UP'</span>)     <span class="comment"># Can move blank up</span>
        <span class="keyword">if</span> row < <span class="number">2</span>: possible_actions.append(<span class="string">'DOWN'</span>)   <span class="comment"># Can move blank down</span>
        <span class="keyword">if</span> col > <span class="number">0</span>: possible_actions.append(<span class="string">'LEFT'</span>)   <span class="comment"># Can move blank left</span>
        <span class="keyword">if</span> col < <span class="number">2</span>: possible_actions.append(<span class="string">'RIGHT'</span>)  <span class="comment"># Can move blank right</span>

        <span class="keyword">return</span> possible_actions

    <span class="keyword">def</span> <span class="function">result</span>(self, state, action):
        <span class="string">"""Apply action and return new state (Transition Model)"""</span>
        row, col = self.find_blank(state)
        new_row, new_col = row, col

        <span class="keyword">if</span> action == <span class="string">'UP'</span>:    new_row -= <span class="number">1</span>
        <span class="keyword">elif</span> action == <span class="string">'DOWN'</span>:  new_row += <span class="number">1</span>
        <span class="keyword">elif</span> action == <span class="string">'LEFT'</span>:  new_col -= <span class="number">1</span>
        <span class="keyword">elif</span> action == <span class="string">'RIGHT'</span>: new_col += <span class="number">1</span>

        <span class="comment"># Swap blank with target tile</span>
        state_list = [<span class="function">list</span>(r) <span class="keyword">for</span> r <span class="keyword">in</span> state]
        state_list[row][col], state_list[new_row][new_col] = \
            state_list[new_row][new_col], state_list[row][col]

        <span class="keyword">return</span> <span class="function">tuple</span>(<span class="function">tuple</span>(r) <span class="keyword">for</span> r <span class="keyword">in</span> state_list)

    <span class="keyword">def</span> <span class="function">goal_test</span>(self, state):
        <span class="string">"""Check if current state is goal state"""</span>
        <span class="keyword">return</span> state == self.goal_state

    <span class="keyword">def</span> <span class="function">path_cost</span>(self, path):
        <span class="string">"""Cost = number of moves"""</span>
        <span class="keyword">return</span> <span class="function">len</span>(path)

<span class="comment"># Demo: Problem formulation</span>
initial = [
    [<span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>],
    [<span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>],
    [<span class="number">7</span>, <span class="number">0</span>, <span class="number">5</span>]
]

puzzle = EightPuzzle(initial)
<span class="function">print</span>(<span class="string">"Initial State:"</span>, puzzle.initial_state)
<span class="function">print</span>(<span class="string">"Goal State:"</span>, puzzle.goal_state)
<span class="function">print</span>(<span class="string">"Valid Actions:"</span>, puzzle.actions(puzzle.initial_state))
<span class="function">print</span>(<span class="string">"Is Goal?"</span>, puzzle.goal_test(puzzle.initial_state))

<span class="comment"># Apply action and see result</span>
new_state = puzzle.result(puzzle.initial_state, <span class="string">'UP'</span>)
<span class="function">print</span>(<span class="string">"After UP:"</span>, new_state)</div>
                </div>

                <!-- Example 2: Industry - Route Planning -->
                <div class="example">
                    <div class="example-title">
                        <i class="fas fa-industry"></i>Example 2: GPS Navigation - Route Planning Problem
                        <span class="example-level industry">INDUSTRY</span>
                    </div>
                    <p><strong>Application:</strong> Google Maps, Uber, logistics companies use this formulation.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-lang"><i class="fab fa-python"></i> Python</span>
                        <button class="copy-button" onclick="copyCode(this)">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <div class="code-block"><span class="comment"># Route Planning Problem - GPS Navigation</span>
<span class="keyword">class</span> <span class="class">RoutePlanningProblem</span>:
    <span class="string">"""
    Real-world route planning problem formulation
    Used by: Google Maps, Uber, Logistics companies
    """</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self, start_city, goal_city):
        self.initial_state = start_city
        self.goal = goal_city

        <span class="comment"># Romania map - classic AI textbook example</span>
        <span class="comment"># Format: city -> [(neighbor, distance), ...]</span>
        self.graph = {
            <span class="string">'Arad'</span>: [(<span class="string">'Sibiu'</span>, <span class="number">140</span>), (<span class="string">'Timisoara'</span>, <span class="number">118</span>), (<span class="string">'Zerind'</span>, <span class="number">75</span>)],
            <span class="string">'Sibiu'</span>: [(<span class="string">'Arad'</span>, <span class="number">140</span>), (<span class="string">'Fagaras'</span>, <span class="number">99</span>), (<span class="string">'Oradea'</span>, <span class="number">151</span>), (<span class="string">'Rimnicu'</span>, <span class="number">80</span>)],
            <span class="string">'Timisoara'</span>: [(<span class="string">'Arad'</span>, <span class="number">118</span>), (<span class="string">'Lugoj'</span>, <span class="number">111</span>)],
            <span class="string">'Zerind'</span>: [(<span class="string">'Arad'</span>, <span class="number">75</span>), (<span class="string">'Oradea'</span>, <span class="number">71</span>)],
            <span class="string">'Fagaras'</span>: [(<span class="string">'Sibiu'</span>, <span class="number">99</span>), (<span class="string">'Bucharest'</span>, <span class="number">211</span>)],
            <span class="string">'Oradea'</span>: [(<span class="string">'Zerind'</span>, <span class="number">71</span>), (<span class="string">'Sibiu'</span>, <span class="number">151</span>)],
            <span class="string">'Rimnicu'</span>: [(<span class="string">'Sibiu'</span>, <span class="number">80</span>), (<span class="string">'Pitesti'</span>, <span class="number">97</span>), (<span class="string">'Craiova'</span>, <span class="number">146</span>)],
            <span class="string">'Lugoj'</span>: [(<span class="string">'Timisoara'</span>, <span class="number">111</span>), (<span class="string">'Mehadia'</span>, <span class="number">70</span>)],
            <span class="string">'Mehadia'</span>: [(<span class="string">'Lugoj'</span>, <span class="number">70</span>), (<span class="string">'Drobeta'</span>, <span class="number">75</span>)],
            <span class="string">'Drobeta'</span>: [(<span class="string">'Mehadia'</span>, <span class="number">75</span>), (<span class="string">'Craiova'</span>, <span class="number">120</span>)],
            <span class="string">'Craiova'</span>: [(<span class="string">'Drobeta'</span>, <span class="number">120</span>), (<span class="string">'Rimnicu'</span>, <span class="number">146</span>), (<span class="string">'Pitesti'</span>, <span class="number">138</span>)],
            <span class="string">'Pitesti'</span>: [(<span class="string">'Rimnicu'</span>, <span class="number">97</span>), (<span class="string">'Craiova'</span>, <span class="number">138</span>), (<span class="string">'Bucharest'</span>, <span class="number">101</span>)],
            <span class="string">'Bucharest'</span>: [(<span class="string">'Fagaras'</span>, <span class="number">211</span>), (<span class="string">'Pitesti'</span>, <span class="number">101</span>), (<span class="string">'Giurgiu'</span>, <span class="number">90</span>)],
            <span class="string">'Giurgiu'</span>: [(<span class="string">'Bucharest'</span>, <span class="number">90</span>)]
        }

        <span class="comment"># Straight-line distances to Bucharest (for heuristic)</span>
        self.heuristic = {
            <span class="string">'Arad'</span>: <span class="number">366</span>, <span class="string">'Bucharest'</span>: <span class="number">0</span>, <span class="string">'Craiova'</span>: <span class="number">160</span>,
            <span class="string">'Drobeta'</span>: <span class="number">242</span>, <span class="string">'Fagaras'</span>: <span class="number">176</span>, <span class="string">'Giurgiu'</span>: <span class="number">77</span>,
            <span class="string">'Lugoj'</span>: <span class="number">244</span>, <span class="string">'Mehadia'</span>: <span class="number">241</span>, <span class="string">'Oradea'</span>: <span class="number">380</span>,
            <span class="string">'Pitesti'</span>: <span class="number">100</span>, <span class="string">'Rimnicu'</span>: <span class="number">193</span>, <span class="string">'Sibiu'</span>: <span class="number">253</span>,
            <span class="string">'Timisoara'</span>: <span class="number">329</span>, <span class="string">'Zerind'</span>: <span class="number">374</span>
        }

    <span class="keyword">def</span> <span class="function">actions</span>(self, state):
        <span class="string">"""Return cities reachable from current city"""</span>
        <span class="keyword">return</span> [neighbor <span class="keyword">for</span> neighbor, _ <span class="keyword">in</span> self.graph.get(state, [])]

    <span class="keyword">def</span> <span class="function">result</span>(self, state, action):
        <span class="string">"""Moving to neighbor city"""</span>
        <span class="keyword">return</span> action  <span class="comment"># Action is the destination city</span>

    <span class="keyword">def</span> <span class="function">goal_test</span>(self, state):
        <span class="string">"""Are we at the destination?"""</span>
        <span class="keyword">return</span> state == self.goal

    <span class="keyword">def</span> <span class="function">step_cost</span>(self, state, action):
        <span class="string">"""Distance between cities"""</span>
        <span class="keyword">for</span> neighbor, cost <span class="keyword">in</span> self.graph.get(state, []):
            <span class="keyword">if</span> neighbor == action:
                <span class="keyword">return</span> cost
        <span class="keyword">return</span> <span class="function">float</span>(<span class="string">'inf'</span>)

    <span class="keyword">def</span> <span class="function">h</span>(self, state):
        <span class="string">"""Heuristic: straight-line distance to goal"""</span>
        <span class="keyword">return</span> self.heuristic.get(state, <span class="number">0</span>)

<span class="comment"># Demo</span>
problem = RoutePlanningProblem(<span class="string">'Arad'</span>, <span class="string">'Bucharest'</span>)
<span class="function">print</span>(<span class="string">"Start:"</span>, problem.initial_state)
<span class="function">print</span>(<span class="string">"Goal:"</span>, problem.goal)
<span class="function">print</span>(<span class="string">"From Arad can go to:"</span>, problem.actions(<span class="string">'Arad'</span>))
<span class="function">print</span>(<span class="string">"Heuristic h(Arad):"</span>, problem.h(<span class="string">'Arad'</span>), <span class="string">"km"</span>)</div>
                </div>

                <!-- Video Visualization for Route Planning -->
                <div class="chart-container" style="padding: 30px; background: linear-gradient(135deg, #1e3a5f 0%, #3d5a80 100%); border-radius: 20px; margin: 30px 0;">
                    <div class="chart-title" style="color: white; font-size: 1.5em; margin-bottom: 10px;">
                        <i class="fas fa-video"></i> A* Pathfinding Animation: Arad to Bucharest
                    </div>
                    <p style="text-align: center; color: #98c1d9; margin-bottom: 25px; font-size: 1.1em;">
                        Watch the A* algorithm find the optimal path step-by-step on the Romania Map
                    </p>

                    <!-- Video Player -->
                    <div style="display: flex; justify-content: center; margin-bottom: 20px;">
                        <video id="astarVideo" controls autoplay loop muted
                               style="max-width: 100%; width: 900px; border-radius: 15px; box-shadow: 0 10px 40px rgba(0,0,0,0.4);">
                            <source src="assets/videos/astar_pathfinding.mp4" type="video/mp4">
                            <img src="assets/videos/astar_pathfinding.gif" alt="A* Pathfinding Animation" style="max-width: 100%; border-radius: 15px;">
                        </video>
                    </div>

                    <!-- Step-by-Step Images Gallery -->
                    <div style="margin-top: 30px;">
                        <h4 style="color: white; text-align: center; margin-bottom: 20px;">
                            <i class="fas fa-images"></i> Step-by-Step Breakdown (Click to Enlarge)
                        </h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                            <div class="step-card" style="background: white; border-radius: 12px; padding: 10px; cursor: pointer;" onclick="showFullImage('assets/images/astar_step_0.png')">
                                <img src="assets/images/astar_step_0.png" alt="Step 0" style="width: 100%; border-radius: 8px;">
                                <p style="text-align: center; margin-top: 8px; font-weight: bold; color: #1e3a5f;">Step 0: Initialize</p>
                            </div>
                            <div class="step-card" style="background: white; border-radius: 12px; padding: 10px; cursor: pointer;" onclick="showFullImage('assets/images/astar_step_1.png')">
                                <img src="assets/images/astar_step_1.png" alt="Step 1" style="width: 100%; border-radius: 8px;">
                                <p style="text-align: center; margin-top: 8px; font-weight: bold; color: #1e3a5f;">Step 1: Expand Arad</p>
                            </div>
                            <div class="step-card" style="background: white; border-radius: 12px; padding: 10px; cursor: pointer;" onclick="showFullImage('assets/images/astar_step_2.png')">
                                <img src="assets/images/astar_step_2.png" alt="Step 2" style="width: 100%; border-radius: 8px;">
                                <p style="text-align: center; margin-top: 8px; font-weight: bold; color: #1e3a5f;">Step 2: Expand Sibiu</p>
                            </div>
                            <div class="step-card" style="background: white; border-radius: 12px; padding: 10px; cursor: pointer;" onclick="showFullImage('assets/images/astar_step_3.png')">
                                <img src="assets/images/astar_step_3.png" alt="Step 3" style="width: 100%; border-radius: 8px;">
                                <p style="text-align: center; margin-top: 8px; font-weight: bold; color: #1e3a5f;">Step 3: Expand Rimnicu</p>
                            </div>
                            <div class="step-card" style="background: white; border-radius: 12px; padding: 10px; cursor: pointer;" onclick="showFullImage('assets/images/astar_step_4.png')">
                                <img src="assets/images/astar_step_4.png" alt="Step 4" style="width: 100%; border-radius: 8px;">
                                <p style="text-align: center; margin-top: 8px; font-weight: bold; color: #1e3a5f;">Step 4: Expand Fagaras</p>
                            </div>
                            <div class="step-card" style="background: white; border-radius: 12px; padding: 10px; cursor: pointer;" onclick="showFullImage('assets/images/astar_step_5.png')">
                                <img src="assets/images/astar_step_5.png" alt="Step 5" style="width: 100%; border-radius: 8px;">
                                <p style="text-align: center; margin-top: 8px; font-weight: bold; color: #1e3a5f;">Step 5: Expand Pitesti</p>
                            </div>
                            <div class="step-card" style="background: white; border-radius: 12px; padding: 10px; cursor: pointer; grid-column: span 2;" onclick="showFullImage('assets/images/astar_step_6.png')">
                                <img src="assets/images/astar_step_6.png" alt="Step 6" style="width: 100%; border-radius: 8px;">
                                <p style="text-align: center; margin-top: 8px; font-weight: bold; color: #22c55e; font-size: 1.1em;">
                                    <i class="fas fa-check-circle"></i> Step 6: GOAL REACHED! Optimal Path = 418 km
                                </p>
                            </div>
                        </div>
                    </div>

                    <!-- Legend -->
                    <div style="display: flex; justify-content: center; gap: 25px; margin-top: 25px; flex-wrap: wrap;">
                        <div style="display: flex; align-items: center; gap: 8px; color: white;">
                            <div style="width: 18px; height: 18px; background: #10b981; border-radius: 50%;"></div>
                            <span>Start (Arad)</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px; color: white;">
                            <div style="width: 18px; height: 18px; background: #f59e0b; border-radius: 50%;"></div>
                            <span>Goal (Bucharest)</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px; color: white;">
                            <div style="width: 18px; height: 18px; background: #3b82f6; border-radius: 50%;"></div>
                            <span>Current Node</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px; color: white;">
                            <div style="width: 18px; height: 18px; background: #6b7280; border-radius: 50%;"></div>
                            <span>Visited</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px; color: white;">
                            <div style="width: 18px; height: 18px; background: #22c55e; border-radius: 50%;"></div>
                            <span>Optimal Path</span>
                        </div>
                    </div>
                </div>

                <!-- Image Modal for Full View -->
                <div id="imageModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 9999; justify-content: center; align-items: center; cursor: pointer;" onclick="closeImageModal()">
                    <img id="modalImage" style="max-width: 95%; max-height: 95%; border-radius: 10px;">
                </div>

                <!-- Example 3: Advanced - Constraint Satisfaction -->
                <div class="example">
                    <div class="example-title">
                        <i class="fas fa-rocket"></i>Example 3: Constraint Satisfaction - Scheduling Problem
                        <span class="example-level advanced">ADVANCED</span>
                    </div>
                    <p><strong>Application:</strong> University timetabling, airline crew scheduling, factory production.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-lang"><i class="fab fa-python"></i> Python</span>
                        <button class="copy-button" onclick="copyCode(this)">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <div class="code-block"><span class="comment"># Constraint Satisfaction Problem (CSP) - Class Scheduling</span>
<span class="keyword">class</span> <span class="class">ClassSchedulingCSP</span>:
    <span class="string">"""
    University Timetabling Problem
    Variables: Classes to schedule
    Domains: Available time slots
    Constraints: No room/professor conflicts
    """</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        <span class="comment"># Variables: Classes to schedule</span>
        self.classes = [<span class="string">'AI'</span>, <span class="string">'Database'</span>, <span class="string">'Networks'</span>, <span class="string">'OS'</span>]

        <span class="comment"># Domains: Time slots (simplified)</span>
        self.time_slots = [<span class="string">'Mon-9AM'</span>, <span class="string">'Mon-11AM'</span>, <span class="string">'Tue-9AM'</span>, <span class="string">'Tue-11AM'</span>]

        <span class="comment"># Rooms available</span>
        self.rooms = [<span class="string">'Room101'</span>, <span class="string">'Room102'</span>]

        <span class="comment"># Professor assignments</span>
        self.professors = {
            <span class="string">'AI'</span>: <span class="string">'Prof. Smith'</span>,
            <span class="string">'Database'</span>: <span class="string">'Prof. Smith'</span>,  <span class="comment"># Same professor!</span>
            <span class="string">'Networks'</span>: <span class="string">'Prof. Jones'</span>,
            <span class="string">'OS'</span>: <span class="string">'Prof. Jones'</span>
        }

        <span class="comment"># Current assignment (state)</span>
        self.assignment = {}

    <span class="keyword">def</span> <span class="function">is_consistent</span>(self, cls, slot, room):
        <span class="string">"""Check if assignment violates any constraints"""</span>

        <span class="keyword">for</span> other_cls, (other_slot, other_room) <span class="keyword">in</span> self.assignment.items():
            <span class="comment"># Constraint 1: No room double-booking</span>
            <span class="keyword">if</span> slot == other_slot <span class="keyword">and</span> room == other_room:
                <span class="keyword">return</span> <span class="keyword">False</span>

            <span class="comment"># Constraint 2: Professor can't teach two classes at same time</span>
            <span class="keyword">if</span> slot == other_slot:
                <span class="keyword">if</span> self.professors[cls] == self.professors[other_cls]:
                    <span class="keyword">return</span> <span class="keyword">False</span>

        <span class="keyword">return</span> <span class="keyword">True</span>

    <span class="keyword">def</span> <span class="function">get_domain</span>(self, cls):
        <span class="string">"""Get valid slot-room combinations for a class"""</span>
        valid = []
        <span class="keyword">for</span> slot <span class="keyword">in</span> self.time_slots:
            <span class="keyword">for</span> room <span class="keyword">in</span> self.rooms:
                <span class="keyword">if</span> self.is_consistent(cls, slot, room):
                    valid.append((slot, room))
        <span class="keyword">return</span> valid

    <span class="keyword">def</span> <span class="function">solve_backtracking</span>(self, idx=<span class="number">0</span>):
        <span class="string">"""Solve using backtracking search"""</span>
        <span class="keyword">if</span> idx == <span class="function">len</span>(self.classes):
            <span class="keyword">return</span> <span class="keyword">True</span>  <span class="comment"># All classes scheduled!</span>

        cls = self.classes[idx]
        <span class="keyword">for</span> slot, room <span class="keyword">in</span> self.get_domain(cls):
            self.assignment[cls] = (slot, room)

            <span class="keyword">if</span> self.solve_backtracking(idx + <span class="number">1</span>):
                <span class="keyword">return</span> <span class="keyword">True</span>

            <span class="keyword">del</span> self.assignment[cls]  <span class="comment"># Backtrack</span>

        <span class="keyword">return</span> <span class="keyword">False</span>

<span class="comment"># Solve the scheduling problem</span>
scheduler = ClassSchedulingCSP()
<span class="keyword">if</span> scheduler.solve_backtracking():
    <span class="function">print</span>(<span class="string">"Schedule found!"</span>)
    <span class="keyword">for</span> cls, (slot, room) <span class="keyword">in</span> scheduler.assignment.items():
        prof = scheduler.professors[cls]
        <span class="function">print</span>(<span class="string">f"  {cls}: {slot} in {room} ({prof})"</span>)
<span class="keyword">else</span>:
    <span class="function">print</span>(<span class="string">"No valid schedule exists!"</span>)

<span class="comment"># Output:
# Schedule found!
#   AI: Mon-9AM in Room101 (Prof. Smith)
#   Database: Mon-11AM in Room101 (Prof. Smith)
#   Networks: Mon-9AM in Room102 (Prof. Jones)
#   OS: Mon-11AM in Room102 (Prof. Jones)</span></div>
                </div>

                <!-- Video Visualization for CSP Scheduling -->
                <div class="chart-container" style="padding: 30px; background: linear-gradient(135deg, #7c3aed 0%, #5b21b6 100%); border-radius: 20px; margin: 30px 0;">
                    <div class="chart-title" style="color: white; font-size: 1.5em; margin-bottom: 10px;">
                        <i class="fas fa-video"></i> CSP Backtracking Animation: Class Scheduling
                    </div>
                    <p style="text-align: center; color: #c4b5fd; margin-bottom: 25px; font-size: 1.1em;">
                        Watch the backtracking algorithm solve the scheduling problem step-by-step
                    </p>

                    <!-- Video Player -->
                    <div style="display: flex; justify-content: center; margin-bottom: 20px;">
                        <video id="cspVideo" controls autoplay loop muted
                               style="max-width: 100%; width: 900px; border-radius: 15px; box-shadow: 0 10px 40px rgba(0,0,0,0.4);">
                            <source src="assets/videos/csp_scheduling.mp4" type="video/mp4">
                            <img src="assets/videos/csp_scheduling.gif" alt="CSP Scheduling Animation" style="max-width: 100%; border-radius: 15px;">
                        </video>
                    </div>

                    <!-- Step-by-Step Images Gallery -->
                    <div style="margin-top: 30px;">
                        <h4 style="color: white; text-align: center; margin-bottom: 20px;">
                            <i class="fas fa-images"></i> Backtracking Steps (Click to Enlarge)
                        </h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;">
                            <div class="step-card" style="background: white; border-radius: 10px; padding: 8px; cursor: pointer;" onclick="showFullImage('assets/images/csp_step_0.png')">
                                <img src="assets/images/csp_step_0.png" alt="Step 0" style="width: 100%; border-radius: 6px;">
                                <p style="text-align: center; margin-top: 6px; font-weight: bold; color: #5b21b6; font-size: 0.85em;">Step 0: Setup</p>
                            </div>
                            <div class="step-card" style="background: white; border-radius: 10px; padding: 8px; cursor: pointer;" onclick="showFullImage('assets/images/csp_step_1.png')">
                                <img src="assets/images/csp_step_1.png" alt="Step 1" style="width: 100%; border-radius: 6px;">
                                <p style="text-align: center; margin-top: 6px; font-weight: bold; color: #5b21b6; font-size: 0.85em;">Step 1: Assign AI</p>
                            </div>
                            <div class="step-card" style="background: white; border-radius: 10px; padding: 8px; cursor: pointer;" onclick="showFullImage('assets/images/csp_step_2.png')">
                                <img src="assets/images/csp_step_2.png" alt="Step 2" style="width: 100%; border-radius: 6px;">
                                <p style="text-align: center; margin-top: 6px; font-weight: bold; color: #ef4444; font-size: 0.85em;">Conflict! Room taken</p>
                            </div>
                            <div class="step-card" style="background: white; border-radius: 10px; padding: 8px; cursor: pointer;" onclick="showFullImage('assets/images/csp_step_3.png')">
                                <img src="assets/images/csp_step_3.png" alt="Step 3" style="width: 100%; border-radius: 6px;">
                                <p style="text-align: center; margin-top: 6px; font-weight: bold; color: #ef4444; font-size: 0.85em;">Conflict! Prof busy</p>
                            </div>
                            <div class="step-card" style="background: white; border-radius: 10px; padding: 8px; cursor: pointer;" onclick="showFullImage('assets/images/csp_step_4.png')">
                                <img src="assets/images/csp_step_4.png" alt="Step 4" style="width: 100%; border-radius: 6px;">
                                <p style="text-align: center; margin-top: 6px; font-weight: bold; color: #10b981; font-size: 0.85em;">Database Assigned</p>
                            </div>
                            <div class="step-card" style="background: white; border-radius: 10px; padding: 8px; cursor: pointer;" onclick="showFullImage('assets/images/csp_step_5.png')">
                                <img src="assets/images/csp_step_5.png" alt="Step 5" style="width: 100%; border-radius: 6px;">
                                <p style="text-align: center; margin-top: 6px; font-weight: bold; color: #10b981; font-size: 0.85em;">Networks Assigned</p>
                            </div>
                            <div class="step-card" style="background: white; border-radius: 10px; padding: 8px; cursor: pointer;" onclick="showFullImage('assets/images/csp_step_6.png')">
                                <img src="assets/images/csp_step_6.png" alt="Step 6" style="width: 100%; border-radius: 6px;">
                                <p style="text-align: center; margin-top: 6px; font-weight: bold; color: #ef4444; font-size: 0.85em;">Conflict! Room</p>
                            </div>
                            <div class="step-card" style="background: white; border-radius: 10px; padding: 8px; cursor: pointer;" onclick="showFullImage('assets/images/csp_step_7.png')">
                                <img src="assets/images/csp_step_7.png" alt="Step 7" style="width: 100%; border-radius: 6px;">
                                <p style="text-align: center; margin-top: 6px; font-weight: bold; color: #ef4444; font-size: 0.85em;">Conflict! Prof busy</p>
                            </div>
                            <div class="step-card" style="background: white; border-radius: 10px; padding: 8px; cursor: pointer;" onclick="showFullImage('assets/images/csp_step_8.png')">
                                <img src="assets/images/csp_step_8.png" alt="Step 8" style="width: 100%; border-radius: 6px;">
                                <p style="text-align: center; margin-top: 6px; font-weight: bold; color: #10b981; font-size: 0.85em;">OS Assigned</p>
                            </div>
                            <div class="step-card" style="background: white; border-radius: 10px; padding: 8px; cursor: pointer;" onclick="showFullImage('assets/images/csp_step_9.png')">
                                <img src="assets/images/csp_step_9.png" alt="Step 9" style="width: 100%; border-radius: 6px;">
                                <p style="text-align: center; margin-top: 6px; font-weight: bold; color: #22c55e; font-size: 0.85em;">SOLUTION FOUND!</p>
                            </div>
                        </div>
                    </div>

                    <!-- Legend -->
                    <div style="display: flex; justify-content: center; gap: 20px; margin-top: 25px; flex-wrap: wrap;">
                        <div style="display: flex; align-items: center; gap: 8px; color: white;">
                            <div style="width: 18px; height: 18px; background: #3b82f6; border-radius: 4px;"></div>
                            <span>AI (Prof. Smith)</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px; color: white;">
                            <div style="width: 18px; height: 18px; background: #10b981; border-radius: 4px;"></div>
                            <span>Database (Prof. Smith)</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px; color: white;">
                            <div style="width: 18px; height: 18px; background: #f59e0b; border-radius: 4px;"></div>
                            <span>Networks (Prof. Jones)</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px; color: white;">
                            <div style="width: 18px; height: 18px; background: #8b5cf6; border-radius: 4px;"></div>
                            <span>OS (Prof. Jones)</span>
                        </div>
                    </div>

                    <!-- Key Insight -->
                    <div style="margin-top: 25px; padding: 15px; background: rgba(255,255,255,0.15); border-radius: 10px; backdrop-filter: blur(5px);">
                        <p style="color: white; text-align: center; margin: 0;">
                            <i class="fas fa-lightbulb" style="color: #fbbf24;"></i>
                            <strong>Key Insight:</strong> Backtracking explores assignments, detects conflicts early, and backtracks to try alternatives. This CSP took 10 steps with 4 conflicts before finding a valid schedule!
                        </p>
                    </div>
                </div>

                <div class="qa-box">
                    <h4><i class="fas fa-question-circle"></i>CO1 Sample Questions - Problem Representation</h4>

                    <div class="question">
                        <strong>Q3:</strong> Define state space. List the components needed to formulate a search problem.
                        <div class="answer">
                            <strong>Answer:</strong> State space is the set of all states reachable from the initial state by any sequence of actions. Components:
                            <br>1. <strong>Initial State:</strong> s<sub>0</sub> where agent starts
                            <br>2. <strong>Actions(s):</strong> Set of actions applicable in state s
                            <br>3. <strong>Transition Model:</strong> RESULT(s, a)  s'
                            <br>4. <strong>Goal Test:</strong> Determines if state is a goal
                            <br>5. <strong>Path Cost:</strong> g(n) = sum of step costs
                        </div>
                    </div>

                    <div class="question">
                        <strong>Q4:</strong> Formulate the Water Jug Problem as a search problem. (4-gallon and 3-gallon jugs, goal: exactly 2 gallons in 4-gallon jug)
                        <div class="answer">
                            <strong>Answer:</strong>
                            <br><strong>State:</strong> (x, y) where x = water in 4-gal jug, y = water in 3-gal jug
                            <br><strong>Initial:</strong> (0, 0)
                            <br><strong>Goal:</strong> x = 2 (any y)
                            <br><strong>Actions:</strong> Fill 4-gal, Fill 3-gal, Empty 4-gal, Empty 3-gal, Pour 43, Pour 34
                            <br><strong>Transitions:</strong> (0,0)Fill4(4,0), (4,0)Pour43(1,3), etc.
                        </div>
                    </div>
                </div>
            </section>

            <!-- ==================== SECTION 3: BLIND SEARCH ==================== -->
            <section id="blind">
                <h2><i class="fas fa-eye-slash"></i>3. Blind (Uninformed) Search Techniques</h2>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>Blind Search (Uninformed Search):</strong> Search strategies that have no additional information about states beyond the problem definition. They can only generate successors and distinguish goal state from non-goal states.</p>
                </div>

                <div class="wwwh-grid">
                    <div class="wwwh-item what">
                        <h4><i class="fas fa-question-circle"></i>WHAT is Blind Search?</h4>
                        <p>Search algorithms that explore the state space systematically without using domain-specific knowledge (heuristics). They only use information in problem definition.</p>
                    </div>
                    <div class="wwwh-item why">
                        <h4><i class="fas fa-lightbulb"></i>WHY Use Blind Search?</h4>
                        <p>Guarantees completeness (finds solution if exists). Simple to implement. Useful when no heuristic is available or as a baseline.</p>
                    </div>
                    <div class="wwwh-item when">
                        <h4><i class="fas fa-clock"></i>WHEN to Use?</h4>
                        <p>Small state spaces, when optimal solution needed (BFS for unit costs), when no good heuristic exists, or for analyzing algorithm properties.</p>
                    </div>
                    <div class="wwwh-item how">
                        <h4><i class="fas fa-cogs"></i>HOW It Works?</h4>
                        <p>Systematically explore nodes using a frontier (queue/stack). Expand nodes, add children to frontier, repeat until goal found.</p>
                    </div>
                </div>

                <h3><i class="fas fa-arrow-down"></i>Depth-First Search (DFS)</h3>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>Depth-First Search:</strong> Explores as far as possible along each branch before backtracking. Uses a LIFO stack (or recursion) for the frontier.</p>
                </div>

                <!-- DFS Real-World Analogy -->
                <div class="analogy-box">
                    <div class="analogy-header">
                        <i class="fas fa-door-open"></i> Real-World Analogy: Exploring a Haunted House
                    </div>
                    <p>Imagine you're exploring a haunted house looking for a hidden treasure. DFS is like how a curious explorer would naturally search:</p>

                    <div class="analogy-scenario">
                        <h5>The DFS Explorer's Strategy:</h5>
                        <p><strong>Step 1:</strong> You enter the front door and see two corridors - LEFT and RIGHT.</p>
                        <p><strong>Step 2:</strong> You pick LEFT and walk all the way down until you hit a dead end or find rooms.</p>
                        <p><strong>Step 3:</strong> In each room, you go as DEEP as possible - if there's a closet, open it. If there's a basement door, go down!</p>
                        <p><strong>Step 4:</strong> Only when you've explored everything down that path, you BACKTRACK to the last junction and try the other direction.</p>
                        <p><strong>Step 5:</strong> Eventually you'll check every corner of the house!</p>
                    </div>

                    <p style="margin-top:15px; background:#fff; padding:15px; border-radius:8px;">
                        <strong>Key Insight:</strong> You're using a mental "stack" - remembering where you came from so you can backtrack. Just like the computer uses a stack data structure! The LAST place you noted is the FIRST place you backtrack to (LIFO - Last In, First Out).
                    </p>
                </div>

                <!-- Chew & Feed for DFS -->
                <div class="chew-feed-box">
                    <div class="cf-header">
                        <i class="fas fa-utensils"></i> Understanding DFS: The "Deep Dive" Approach
                    </div>

                    <div class="simple-terms">
                        <h5>DFS in Plain English:</h5>
                        <p><strong>"Go as deep as you can, then come back and try another path."</strong></p>

                        <div style="margin-top:15px;">
                            <p><strong>Think of it like reading a "Choose Your Own Adventure" book:</strong></p>
                            <ol style="margin-left:25px; margin-top:10px;">
                                <li>You start at page 1</li>
                                <li>The book says "To fight the dragon, go to page 45. To run away, go to page 23."</li>
                                <li>You choose page 45 (going DEEP into that story branch)</li>
                                <li>Page 45 leads to page 78, which leads to page 92...</li>
                                <li>Eventually you reach "THE END" (dead end or goal)</li>
                                <li>Now you go BACK and try page 23 to see that story</li>
                            </ol>
                        </div>
                    </div>

                    <div class="simple-terms" style="margin-top:15px;">
                        <h5>Why Use a Stack?</h5>
                        <p>A <strong>stack</strong> is like a pile of plates:</p>
                        <ul style="margin-left:25px;">
                            <li>You can only add plates on TOP (push)</li>
                            <li>You can only remove the TOP plate (pop)</li>
                            <li>The LAST plate you added is the FIRST one you remove</li>
                        </ul>
                        <p style="margin-top:10px;">This perfectly matches how DFS explores - the LAST path you discovered is the FIRST one you explore next!</p>
                    </div>
                </div>

                <!-- Daily Life DFS Examples -->
                <div class="daily-life-box">
                    <div class="daily-header">
                        <i class="fas fa-map-signs"></i> You Already Use DFS in Daily Life!
                    </div>

                    <div class="daily-example">
                        <h5><i class="fas fa-folder-tree"></i> Finding a File on Your Computer</h5>
                        <p>When you manually search for a file, you often use DFS:</p>
                        <p>Documents  Work  2024  January  (not here)  back to 2024  February  (found it!)</p>
                        <p><em>You went DEEP into January folder first, then backtracked to try February.</em></p>
                    </div>

                    <div class="daily-example">
                        <h5><i class="fas fa-puzzle-piece"></i> Solving a Maze</h5>
                        <p>When you trace a maze with your finger:</p>
                        <p>You follow one path until you hit a wall, then go back to the last fork and try another direction.</p>
                        <p><em>This is exactly DFS! The "wall rule" (always keep your hand on left/right wall) is a DFS variant.</em></p>
                    </div>

                    <div class="daily-example">
                        <h5><i class="fas fa-code-branch"></i> Debugging Code</h5>
                        <p>When you debug: main()  function1()  helper()  (bug not here)  back to function1()  function2()  (found bug!)</p>
                        <p><em>You trace deep into one call stack, then backtrack to try other branches.</em></p>
                    </div>
                </div>

                <!-- Think Like This -->
                <div class="think-like-box">
                    <div class="think-header">
                        <i class="fas fa-brain"></i> Think Like This When Using DFS
                    </div>
                    <div class="thought-bubble">
                        <p><strong>Question to ask yourself:</strong> "Have I fully explored this path before moving to the next one?"</p>
                        <p style="margin-top:10px;"><strong>DFS Mindset:</strong> "I'll commit fully to this direction. Only when I hit a dead end will I consider alternatives."</p>
                        <p style="margin-top:10px;"><strong>Good for:</strong> When you have deep solutions, limited memory, or when ANY solution is acceptable (not necessarily the shortest).</p>
                    </div>
                </div>

                <div class="algorithm-box">
                    <div class="algorithm-title">
                        <i class="fas fa-code"></i>DFS Algorithm Steps
                    </div>
                    <ol class="algorithm-steps">
                        <li>Initialize: Push start node onto stack</li>
                        <li>If stack is empty, return FAILURE (no solution)</li>
                        <li>Pop node from stack (current node)</li>
                        <li>If current is GOAL, return SUCCESS with path</li>
                        <li>Mark current as VISITED</li>
                        <li>Push all unvisited children onto stack</li>
                        <li>Go to step 2</li>
                    </ol>
                </div>

                <div class="complexity-box">
                    <div class="complexity-item">
                        <div class="label">Time Complexity</div>
                        <div class="value">O(b<sup>m</sup>)</div>
                    </div>
                    <div class="complexity-item">
                        <div class="label">Space Complexity</div>
                        <div class="value">O(bm)</div>
                    </div>
                    <div class="complexity-item">
                        <div class="label">Complete?</div>
                        <div class="value">No*</div>
                    </div>
                    <div class="complexity-item">
                        <div class="label">Optimal?</div>
                        <div class="value">No</div>
                    </div>
                </div>
                <p style="font-size: 0.9em; color: #666; margin-top: 10px;">*Complete for finite spaces with cycle detection. b = branching factor, m = maximum depth</p>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-lang"><i class="fab fa-python"></i> Python - DFS Implementation (Line-by-Line Explained)</span>
                        <button class="copy-button" onclick="copyCode(this)">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <div class="code-block"><span class="comment"># ============================================================</span>
<span class="comment"># DEPTH-FIRST SEARCH (DFS) - Complete Implementation</span>
<span class="comment"># ============================================================</span>

<span class="keyword">def</span> <span class="function">dfs</span>(graph, start, goal):
    <span class="comment"># LINE 1: Create a stack with starting node and its path</span>
    <span class="comment"># Stack stores tuples: (current_node, path_taken_to_reach_it)</span>
    <span class="comment"># Initially: stack = [('A', ['A'])]</span>
    stack = [(start, [start])]

    <span class="comment"># LINE 2: Create empty set to track visited nodes</span>
    <span class="comment"># Sets have O(1) lookup time - very fast to check "have we been here?"</span>
    <span class="comment"># Initially: visited = {} (empty set)</span>
    visited = <span class="function">set</span>()

    <span class="comment"># LINE 3: Counter to track how many nodes we explore</span>
    nodes_explored = <span class="number">0</span>

    <span class="comment"># LINE 4: Main loop - keep going while stack has nodes to explore</span>
    <span class="comment"># When stack becomes empty, we've explored everything reachable</span>
    <span class="keyword">while</span> stack:
        <span class="comment"># LINE 5: Pop the TOP element from stack (LIFO - Last In First Out)</span>
        <span class="comment"># This is what makes it "depth-first" - we explore most recent path</span>
        <span class="comment"># Example: stack.pop() removes and returns ('B', ['A', 'B'])</span>
        node, path = stack.pop()

        <span class="comment"># LINE 6: Increment counter each time we examine a node</span>
        nodes_explored += <span class="number">1</span>

        <span class="comment"># LINE 7: Goal test - did we find what we're looking for?</span>
        <span class="comment"># If yes, return the path immediately (don't explore further)</span>
        <span class="keyword">if</span> node == goal:
            <span class="function">print</span>(<span class="string">f"Goal found! Nodes explored: {nodes_explored}"</span>)
            <span class="keyword">return</span> path  <span class="comment"># SUCCESS! Return the path we took</span>

        <span class="comment"># LINE 8: Only process this node if we haven't visited it before</span>
        <span class="comment"># This prevents infinite loops in graphs with cycles</span>
        <span class="keyword">if</span> node <span class="keyword">not in</span> visited:
            <span class="comment"># LINE 9: Mark this node as visited</span>
            <span class="comment"># After this, visited = {'A'} (or {'A', 'B'}, etc.)</span>
            visited.add(node)

            <span class="comment"># LINE 10: Get all neighbors and add them to stack</span>
            <span class="comment"># reversed() ensures left-to-right exploration (optional)</span>
            <span class="comment"># graph.get(node, []) safely returns [] if node has no neighbors</span>
            <span class="keyword">for</span> neighbor <span class="keyword">in</span> <span class="function">reversed</span>(graph.get(node, [])):
                <span class="comment"># LINE 11: Only add unvisited neighbors to avoid redundant work</span>
                <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                    <span class="comment"># LINE 12: Push neighbor onto stack with extended path</span>
                    <span class="comment"># path + [neighbor] creates NEW list (doesn't modify original)</span>
                    <span class="comment"># Example: ['A'] + ['B'] = ['A', 'B']</span>
                    stack.append((neighbor, path + [neighbor]))

    <span class="comment"># LINE 13: If we exit the loop, stack is empty = no path exists</span>
    <span class="function">print</span>(<span class="string">f"Goal not found. Nodes explored: {nodes_explored}"</span>)
    <span class="keyword">return</span> <span class="keyword">None</span>  <span class="comment"># FAILURE - goal is unreachable</span>

<span class="comment"># ============================================================</span>
<span class="comment"># EXAMPLE: Tree Graph Structure</span>
<span class="comment"># ============================================================</span>
<span class="comment">#         A          (Level 0 - Root)</span>
<span class="comment">#        / \</span>
<span class="comment">#       B   C        (Level 1)</span>
<span class="comment">#      /|   |\</span>
<span class="comment">#     D E   F G      (Level 2)</span>
<span class="comment">#       |     |</span>
<span class="comment">#       H     I      (Level 3 - I is our goal)</span>
<span class="comment"># ============================================================</span>

graph = {
    <span class="string">'A'</span>: [<span class="string">'B'</span>, <span class="string">'C'</span>],   <span class="comment"># A connects to B and C</span>
    <span class="string">'B'</span>: [<span class="string">'D'</span>, <span class="string">'E'</span>],   <span class="comment"># B connects to D and E</span>
    <span class="string">'C'</span>: [<span class="string">'F'</span>, <span class="string">'G'</span>],   <span class="comment"># C connects to F and G</span>
    <span class="string">'D'</span>: [],          <span class="comment"># D is a leaf node (dead end)</span>
    <span class="string">'E'</span>: [<span class="string">'H'</span>],        <span class="comment"># E connects to H</span>
    <span class="string">'F'</span>: [],          <span class="comment"># F is a leaf node (dead end)</span>
    <span class="string">'G'</span>: [<span class="string">'I'</span>],        <span class="comment"># G connects to I (our goal!)</span>
    <span class="string">'H'</span>: [],          <span class="comment"># H is a leaf node</span>
    <span class="string">'I'</span>: []           <span class="comment"># I is the goal (leaf node)</span>
}

<span class="comment"># ============================================================</span>
<span class="comment"># EXECUTION TRACE - What happens at each step</span>
<span class="comment"># ============================================================</span>
<span class="function">print</span>(<span class="string">"Finding path from A to I using DFS:"</span>)
path = dfs(graph, <span class="string">'A'</span>, <span class="string">'I'</span>)
<span class="function">print</span>(<span class="string">"Path:"</span>, <span class="string">' -> '</span>.join(path) <span class="keyword">if</span> path <span class="keyword">else</span> <span class="string">"Not found"</span>)

<span class="comment"># ============================================================</span>
<span class="comment"># STEP-BY-STEP EXECUTION OUTPUT:</span>
<span class="comment"># ============================================================</span>
<span class="comment"># Step 1: stack = [('A', ['A'])], visited = {}</span>
<span class="comment"># Step 2: Pop A, explore it, push C then B</span>
<span class="comment">#         stack = [('C', ['A','C']), ('B', ['A','B'])], visited = {'A'}</span>
<span class="comment"># Step 3: Pop B (top of stack), push E then D</span>
<span class="comment">#         stack = [('C',...), ('E',...), ('D',...)], visited = {'A','B'}</span>
<span class="comment"># Step 4: Pop D, it's a dead end (no children)</span>
<span class="comment">#         stack = [('C',...), ('E',...)], visited = {'A','B','D'}</span>
<span class="comment"># Step 5: Pop E, push H</span>
<span class="comment">#         stack = [('C',...), ('H',...)], visited = {'A','B','D','E'}</span>
<span class="comment"># Step 6: Pop H, dead end</span>
<span class="comment">#         stack = [('C',...)], visited = {'A','B','D','E','H'}</span>
<span class="comment"># Step 7: Pop C, push G then F</span>
<span class="comment">#         stack = [('G',...), ('F',...)], visited = {'A','B','D','E','H','C'}</span>
<span class="comment"># Step 8: Pop F, dead end</span>
<span class="comment"># Step 9: Pop G, push I</span>
<span class="comment"># Step 10: Pop I  GOAL FOUND!</span>
<span class="comment"># </span>
<span class="comment"># Final Output:</span>
<span class="comment"># Finding path from A to I using DFS:</span>
<span class="comment"># Goal found! Nodes explored: 7</span>
<span class="comment"># Path: A -> B -> D -> E -> H -> C -> G -> I</span>
<span class="comment"># </span>
<span class="comment"># Note: Shortest path is A->C->G->I (only 4 nodes)</span>
<span class="comment"># But DFS found a longer path because it explored left (B) first!</span></div>
                </div>

                <!-- DFS Complexity Explanation -->
                <div class="chew-feed-box" style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);">
                    <div class="cf-header" style="color: #92400e;">
                        <i class="fas fa-calculator"></i> DFS Complexity Explained Simply
                    </div>

                    <div class="simple-terms">
                        <h5>Time Complexity: O(b<sup>m</sup>) - Why?</h5>
                        <div style="background: white; padding: 15px; border-radius: 8px; margin: 10px 0;">
                            <p><strong>b</strong> = branching factor (average number of children per node)</p>
                            <p><strong>m</strong> = maximum depth of the tree</p>
                            <p style="margin-top: 10px;"><strong>Simple Explanation:</strong></p>
                            <ul style="margin-left: 25px;">
                                <li><strong>Level 0:</strong> 1 node (root)</li>
                                <li><strong>Level 1:</strong> b nodes (each child of root)</li>
                                <li><strong>Level 2:</strong> b  b = b nodes</li>
                                <li><strong>Level 3:</strong> b  b  b = b nodes</li>
                                <li><strong>Level m:</strong> b<sup>m</sup> nodes</li>
                            </ul>
                            <p style="margin-top: 10px; background: #fef3c7; padding: 10px; border-radius: 4px;">
                                <strong>Example:</strong> If b=2, m=10  2<sup>10</sup> = 1,024 nodes in worst case
                            </p>
                        </div>
                    </div>

                    <div class="simple-terms" style="margin-top: 15px;">
                        <h5>Space Complexity: O(b  m) - Why?</h5>
                        <div style="background: white; padding: 15px; border-radius: 8px; margin: 10px 0;">
                            <p><strong>Key Insight:</strong> DFS only stores ONE path from root to current node!</p>
                            <ul style="margin-left: 25px;">
                                <li>At most <strong>m</strong> nodes deep (one path)</li>
                                <li>At each level, we store up to <strong>b</strong> siblings</li>
                                <li>Total: b + b + ... + b (m times) = <strong>b  m</strong></li>
                            </ul>
                            <p style="margin-top: 10px; background: #d1fae5; padding: 10px; border-radius: 4px;">
                                <strong>This is why DFS is memory-efficient!</strong> Unlike BFS which stores entire levels (b<sup>d</sup> nodes), DFS only stores one path at a time.
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Edge Case Handling -->
                <div class="tip-box" style="background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); border-left: 5px solid #ef4444; margin-top: 20px;">
                    <h4 style="color: #991b1b; margin-bottom: 15px;"><i class="fas fa-exclamation-triangle"></i> Edge Cases & Robust Implementation</h4>

                    <p style="margin-bottom: 15px;">Production-quality search algorithms must handle these edge cases:</p>

                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px;">
                        <div style="background: white; padding: 15px; border-radius: 8px;">
                            <strong style="color: #dc2626;"><i class="fas fa-repeat"></i> Cycle Detection</strong>
                            <p style="font-size: 0.9em; margin-top: 5px;">In graphs (not trees), nodes can be revisited. Always track visited nodes to prevent infinite loops.</p>
                            <pre style="background: #1e293b; color: #e2e8f0; padding: 8px; border-radius: 4px; font-size: 0.8em; margin-top: 8px;">
if neighbor in visited:
    continue  # Skip already-visited</pre>
                        </div>
                        <div style="background: white; padding: 15px; border-radius: 8px;">
                            <strong style="color: #dc2626;"><i class="fas fa-ban"></i> Disconnected Graphs</strong>
                            <p style="font-size: 0.9em; margin-top: 5px;">Goal may be unreachable from start. Always check for empty frontier.</p>
                            <pre style="background: #1e293b; color: #e2e8f0; padding: 8px; border-radius: 4px; font-size: 0.8em; margin-top: 8px;">
if not frontier:
    return None  # No path exists</pre>
                        </div>
                        <div style="background: white; padding: 15px; border-radius: 8px;">
                            <strong style="color: #dc2626;"><i class="fas fa-flag-checkered"></i> Goal = Start</strong>
                            <p style="font-size: 0.9em; margin-top: 5px;">Trivial case often overlooked. Check before searching.</p>
                            <pre style="background: #1e293b; color: #e2e8f0; padding: 8px; border-radius: 4px; font-size: 0.8em; margin-top: 8px;">
if start == goal:
    return [start]  # Path of length 0</pre>
                        </div>
                        <div style="background: white; padding: 15px; border-radius: 8px;">
                            <strong style="color: #dc2626;"><i class="fas fa-memory"></i> Depth Limit</strong>
                            <p style="font-size: 0.9em; margin-top: 5px;">Infinite/very deep trees can exhaust memory. Add depth limit for DFS.</p>
                            <pre style="background: #1e293b; color: #e2e8f0; padding: 8px; border-radius: 4px; font-size: 0.8em; margin-top: 8px;">
if depth > MAX_DEPTH:
    return None  # Limit reached</pre>
                        </div>
                    </div>

                    <div style="background: #fef3c7; padding: 12px; border-radius: 8px; margin-top: 15px;">
                        <strong><i class="fas fa-lightbulb"></i> Pro Tip:</strong> Always validate inputs: <code>if not graph or start not in graph: raise ValueError("Invalid graph")</code>
                    </div>
                </div>

                <!-- DFS Visualization Section -->
                <div class="visualization-section" style="margin: 40px 0; background: linear-gradient(135deg, #1e3a5f 0%, #7c3aed 100%); border-radius: 16px; padding: 30px;">
                    <h4 style="color: #fff; margin-bottom: 20px; text-align: center;">
                        <i class="fas fa-film"></i> DFS Algorithm Visualization
                    </h4>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; align-items: start;">
                        <!-- Video Player -->
                        <div style="background: #0f172a; border-radius: 12px; padding: 15px;">
                            <video id="dfsVideo" controls style="width: 100%; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                                <source src="assets/videos/dfs_search.mp4" type="video/mp4">
                                <source src="assets/videos/dfs_search.gif" type="image/gif">
                                Your browser does not support video playback.
                            </video>
                            <p style="color: #94a3b8; text-align: center; margin-top: 10px; font-size: 14px;">
                                <i class="fas fa-info-circle"></i> Click play to watch DFS traversal step-by-step
                            </p>
                        </div>

                        <!-- Step Images Gallery -->
                        <div style="background: rgba(255,255,255,0.1); border-radius: 12px; padding: 15px;">
                            <h5 style="color: #fef3c7; margin-bottom: 15px;"><i class="fas fa-images"></i> Step-by-Step Frames</h5>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; max-height: 300px; overflow-y: auto;">
                                <img src="assets/images/dfs_step_0.png" alt="DFS Step 0" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/dfs_step_1.png" alt="DFS Step 1" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/dfs_step_2.png" alt="DFS Step 2" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/dfs_step_3.png" alt="DFS Step 3" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/dfs_step_4.png" alt="DFS Step 4" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                            </div>
                        </div>
                    </div>

                    <!-- DFS Legend -->
                    <div style="margin-top: 20px; background: rgba(255,255,255,0.95); border-radius: 8px; padding: 15px;">
                        <div style="display: flex; flex-wrap: wrap; gap: 20px; justify-content: center;">
                            <span><span style="display:inline-block;width:16px;height:16px;background:#3b82f6;border-radius:50%;vertical-align:middle;"></span> Current Node</span>
                            <span><span style="display:inline-block;width:16px;height:16px;background:#6b7280;border-radius:50%;vertical-align:middle;"></span> Visited</span>
                            <span><span style="display:inline-block;width:16px;height:16px;background:#c4b5fd;border-radius:50%;vertical-align:middle;"></span> In Stack</span>
                            <span><span style="display:inline-block;width:16px;height:16px;background:#f59e0b;border-radius:50%;vertical-align:middle;"></span> Goal Node</span>
                            <span><span style="display:inline-block;width:16px;height:16px;background:#22c55e;border-radius:50%;vertical-align:middle;"></span> Goal Found</span>
                        </div>
                        <p style="text-align: center; margin-top: 10px; color: #1e3a5f; font-weight: 500;">
                            <i class="fas fa-layer-group"></i> DFS uses <strong>Stack (LIFO)</strong> - explores deep first, then backtracks
                        </p>
                    </div>
                </div>

                <h3><i class="fas fa-arrows-alt-h"></i>Breadth-First Search (BFS)</h3>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>Breadth-First Search:</strong> Explores all nodes at the current depth before moving to nodes at the next depth level. Uses a FIFO queue for the frontier.</p>
                </div>

                <!-- BFS Real-World Analogy -->
                <div class="analogy-box">
                    <div class="analogy-header">
                        <i class="fas fa-water"></i> Real-World Analogy: Ripples in a Pond
                    </div>
                    <p>Imagine you throw a stone into a calm pond. Watch how the ripples spread:</p>

                    <div class="analogy-scenario">
                        <h5>How BFS is Like Water Ripples:</h5>
                        <p><strong>The stone hits water:</strong> This is your starting point (initial state).</p>
                        <p><strong>First ripple:</strong> Water moves outward equally in ALL directions - 1 meter from center.</p>
                        <p><strong>Second ripple:</strong> Before going further in any direction, the water spreads to ALL points 2 meters away.</p>
                        <p><strong>Third ripple:</strong> Only after covering the 2-meter ring does it reach 3 meters.</p>
                        <p><strong>Pattern:</strong> Level 1 completes  Level 2 completes  Level 3 completes...</p>
                    </div>

                    <p style="margin-top:15px; background:#fff; padding:15px; border-radius:8px;">
                        <strong>Key Insight:</strong> The ripple reaches ALL nearby points before ANY far point. That's why BFS always finds the <em>shortest path</em> - it explores every 1-step solution before any 2-step solution, every 2-step before any 3-step, etc.
                    </p>
                </div>

                <!-- Chew & Feed for BFS -->
                <div class="chew-feed-box">
                    <div class="cf-header">
                        <i class="fas fa-utensils"></i> Understanding BFS: The "Layer by Layer" Approach
                    </div>

                    <div class="simple-terms">
                        <h5>BFS in Plain English:</h5>
                        <p><strong>"Check ALL your immediate options before going further out."</strong></p>

                        <div style="margin-top:15px;">
                            <p><strong>Think of it like finding a friend in a crowded mall:</strong></p>
                            <ol style="margin-left:25px; margin-top:10px;">
                                <li><strong>Level 0:</strong> Look around where you're standing right now</li>
                                <li><strong>Level 1:</strong> Walk to ALL adjacent stores and peek inside each one</li>
                                <li><strong>Level 2:</strong> Only after checking ALL adjacent stores, move to the NEXT ring of stores</li>
                                <li><strong>Level 3:</strong> Continue spreading outward layer by layer</li>
                                <li><strong>When found:</strong> You've taken the MINIMUM number of steps to reach them!</li>
                            </ol>
                        </div>
                    </div>

                    <div class="simple-terms" style="margin-top:15px;">
                        <h5>Why Use a Queue?</h5>
                        <p>A <strong>queue</strong> is like a line at a ticket counter:</p>
                        <ul style="margin-left:25px;">
                            <li>New people join at the BACK of the line</li>
                            <li>People leave from the FRONT of the line</li>
                            <li>The FIRST person who arrived is the FIRST to be served (FIFO)</li>
                        </ul>
                        <p style="margin-top:10px;">This ensures we process nodes in the order we discovered them - all level-1 nodes before level-2, all level-2 before level-3!</p>
                    </div>
                </div>

                <!-- Daily Life BFS Examples -->
                <div class="daily-life-box">
                    <div class="daily-header">
                        <i class="fas fa-broadcast-tower"></i> BFS in Your Daily Life
                    </div>

                    <div class="daily-example">
                        <h5><i class="fas fa-share-alt"></i> How Rumors Spread</h5>
                        <p>You tell a secret to 3 close friends (Level 1).</p>
                        <p>Each friend tells 3 of THEIR friends (Level 2 - 9 people).</p>
                        <p>Those tell 3 more each (Level 3 - 27 people).</p>
                        <p><em>The rumor spreads level-by-level, reaching nearby social circles before distant ones!</em></p>
                    </div>

                    <div class="daily-example">
                        <h5><i class="fas fa-virus"></i> How Diseases Spread</h5>
                        <p>Patient Zero infects close contacts first (Level 1).</p>
                        <p>Those contacts infect THEIR close contacts (Level 2).</p>
                        <p>Epidemiologists use BFS-like models to trace and contain outbreaks!</p>
                        <p><em>This is why "contact tracing" works - it follows the BFS pattern of infection.</em></p>
                    </div>

                    <div class="daily-example">
                        <h5><i class="fas fa-linkedin"></i> LinkedIn's "Degrees of Connection"</h5>
                        <p><strong>1st connections:</strong> People you directly know (Level 1)</p>
                        <p><strong>2nd connections:</strong> Friends of friends (Level 2)</p>
                        <p><strong>3rd connections:</strong> Friends of friends of friends (Level 3)</p>
                        <p><em>LinkedIn uses BFS to show you the SHORTEST social path to anyone!</em></p>
                    </div>
                </div>

                <!-- DFS vs BFS Mental Model -->
                <div class="think-like-box">
                    <div class="think-header">
                        <i class="fas fa-balance-scale"></i> DFS vs BFS: When to Use Which?
                    </div>
                    <div class="thought-bubble">
                        <table style="width:100%;">
                            <tr>
                                <th style="text-align:left; padding:10px; border-bottom:2px solid #6366f1;">Use DFS When...</th>
                                <th style="text-align:left; padding:10px; border-bottom:2px solid #6366f1;">Use BFS When...</th>
                            </tr>
                            <tr>
                                <td style="padding:10px;">Memory is limited (DFS uses less)</td>
                                <td style="padding:10px;">You need the SHORTEST path</td>
                            </tr>
                            <tr>
                                <td style="padding:10px;">Solution is deep in the tree</td>
                                <td style="padding:10px;">Solution is likely near the start</td>
                            </tr>
                            <tr>
                                <td style="padding:10px;">ANY solution is acceptable</td>
                                <td style="padding:10px;">The OPTIMAL solution matters</td>
                            </tr>
                            <tr>
                                <td style="padding:10px;">Exploring game trees, mazes</td>
                                <td style="padding:10px;">Finding shortest route, social networks</td>
                            </tr>
                        </table>
                    </div>
                </div>

                <div class="algorithm-box">
                    <div class="algorithm-title">
                        <i class="fas fa-code"></i>BFS Algorithm Steps
                    </div>
                    <ol class="algorithm-steps">
                        <li>Initialize: Enqueue start node into queue</li>
                        <li>If queue is empty, return FAILURE</li>
                        <li>Dequeue node from front (current node)</li>
                        <li>If current is GOAL, return SUCCESS with path</li>
                        <li>Mark current as VISITED</li>
                        <li>Enqueue all unvisited children at the rear</li>
                        <li>Go to step 2</li>
                    </ol>
                </div>

                <div class="complexity-box">
                    <div class="complexity-item">
                        <div class="label">Time Complexity</div>
                        <div class="value">O(b<sup>d</sup>)</div>
                    </div>
                    <div class="complexity-item">
                        <div class="label">Space Complexity</div>
                        <div class="value">O(b<sup>d</sup>)</div>
                    </div>
                    <div class="complexity-item">
                        <div class="label">Complete?</div>
                        <div class="value">Yes</div>
                    </div>
                    <div class="complexity-item">
                        <div class="label">Optimal?</div>
                        <div class="value">Yes*</div>
                    </div>
                </div>
                <p style="font-size: 0.9em; color: #666; margin-top: 10px;">*Optimal for unit step costs. b = branching factor, d = depth of shallowest goal</p>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-lang"><i class="fab fa-python"></i> Python - BFS Implementation (Line-by-Line Explained)</span>
                        <button class="copy-button" onclick="copyCode(this)">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <div class="code-block"><span class="comment"># ============================================================</span>
<span class="comment"># BREADTH-FIRST SEARCH (BFS) - Complete Implementation</span>
<span class="comment"># ============================================================</span>

<span class="keyword">from</span> collections <span class="keyword">import</span> deque  <span class="comment"># deque = "double-ended queue" (efficient for both ends)</span>

<span class="keyword">def</span> <span class="function">bfs</span>(graph, start, goal):
    <span class="comment"># LINE 1: Create a queue with starting node</span>
    <span class="comment"># deque is used because popleft() is O(1), regular list.pop(0) is O(n)</span>
    <span class="comment"># Initially: queue = deque([('A', ['A'])])</span>
    queue = deque([(start, [start])])

    <span class="comment"># LINE 2: Mark start as visited IMMEDIATELY when adding to queue</span>
    <span class="comment"># This prevents adding the same node multiple times</span>
    <span class="comment"># Initially: visited = {'A'}</span>
    visited = <span class="function">set</span>([start])

    <span class="comment"># LINE 3: Counter for nodes explored</span>
    nodes_explored = <span class="number">0</span>

    <span class="comment"># LINE 4: Main loop - continue while queue has nodes</span>
    <span class="keyword">while</span> queue:
        <span class="comment"># LINE 5: Dequeue from FRONT (FIFO - First In First Out)</span>
        <span class="comment"># This is what makes it "breadth-first" - we process oldest nodes first</span>
        <span class="comment"># Example: queue.popleft() returns ('A', ['A']) first time</span>
        node, path = queue.popleft()

        <span class="comment"># LINE 6: Count this node</span>
        nodes_explored += <span class="number">1</span>

        <span class="comment"># LINE 7: Goal test - check if current node is the goal</span>
        <span class="keyword">if</span> node == goal:
            <span class="function">print</span>(<span class="string">f"Goal found! Nodes explored: {nodes_explored}"</span>)
            <span class="keyword">return</span> path  <span class="comment"># SUCCESS! This is guaranteed to be SHORTEST path</span>

        <span class="comment"># LINE 8: Expand current node - add all neighbors to queue</span>
        <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph.get(node, []):
            <span class="comment"># LINE 9: Only add unvisited neighbors</span>
            <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                <span class="comment"># LINE 10: Mark as visited WHEN ADDING (not when processing)</span>
                <span class="comment"># This is crucial for BFS efficiency!</span>
                visited.add(neighbor)

                <span class="comment"># LINE 11: Add to BACK of queue (FIFO)</span>
                <span class="comment"># New nodes go to back, old nodes stay at front</span>
                queue.append((neighbor, path + [neighbor]))

    <span class="comment"># LINE 12: Queue empty = goal unreachable</span>
    <span class="function">print</span>(<span class="string">f"Goal not found. Nodes explored: {nodes_explored}"</span>)
    <span class="keyword">return</span> <span class="keyword">None</span>

<span class="comment"># ============================================================</span>
<span class="comment"># EXECUTION TRACE - Level by Level</span>
<span class="comment"># ============================================================</span>
<span class="function">print</span>(<span class="string">"Finding path from A to I using BFS:"</span>)
path = bfs(graph, <span class="string">'A'</span>, <span class="string">'I'</span>)
<span class="function">print</span>(<span class="string">"Path:"</span>, <span class="string">' -> '</span>.join(path) <span class="keyword">if</span> path <span class="keyword">else</span> <span class="string">"Not found"</span>)

<span class="comment"># ============================================================</span>
<span class="comment"># STEP-BY-STEP EXECUTION:</span>
<span class="comment"># ============================================================</span>
<span class="comment"># LEVEL 0:</span>
<span class="comment">#   queue = [A], visited = {A}</span>
<span class="comment">#   Process A  add B, C to queue</span>
<span class="comment"># </span>
<span class="comment"># LEVEL 1:</span>
<span class="comment">#   queue = [B, C], visited = {A, B, C}</span>
<span class="comment">#   Process B  add D, E to queue</span>
<span class="comment">#   Process C  add F, G to queue</span>
<span class="comment"># </span>
<span class="comment"># LEVEL 2:</span>
<span class="comment">#   queue = [D, E, F, G], visited = {A, B, C, D, E, F, G}</span>
<span class="comment">#   Process D  no children (dead end)</span>
<span class="comment">#   Process E  add H</span>
<span class="comment">#   Process F  no children</span>
<span class="comment">#   Process G  add I</span>
<span class="comment"># </span>
<span class="comment"># LEVEL 3:</span>
<span class="comment">#   queue = [H, I]</span>
<span class="comment">#   Process H  dead end</span>
<span class="comment">#   Process I  GOAL FOUND!</span>
<span class="comment"># </span>
<span class="comment"># Final Output:</span>
<span class="comment"># Goal found! Nodes explored: 8</span>
<span class="comment"># Path: A -> C -> G -> I    (This IS the shortest path!)</span></div>
                </div>

                <!-- BFS Complexity Explanation -->
                <div class="chew-feed-box" style="background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);">
                    <div class="cf-header" style="color: #1e40af;">
                        <i class="fas fa-calculator"></i> BFS Complexity Explained Simply
                    </div>

                    <div class="simple-terms">
                        <h5>Time Complexity: O(b<sup>d</sup>) - Why?</h5>
                        <div style="background: white; padding: 15px; border-radius: 8px; margin: 10px 0;">
                            <p><strong>b</strong> = branching factor, <strong>d</strong> = depth of shallowest goal</p>
                            <p style="margin-top: 10px;"><strong>Simple Explanation:</strong></p>
                            <ul style="margin-left: 25px;">
                                <li><strong>Level 0:</strong> 1 node</li>
                                <li><strong>Level 1:</strong> b nodes</li>
                                <li><strong>Level 2:</strong> b nodes</li>
                                <li><strong>Level d:</strong> b<sup>d</sup> nodes</li>
                                <li><strong>Total:</strong> 1 + b + b + ... + b<sup>d</sup>  O(b<sup>d</sup>)</li>
                            </ul>
                            <p style="margin-top: 10px; background: #dbeafe; padding: 10px; border-radius: 4px;">
                                <strong>Key:</strong> BFS only goes to depth d (where goal is), not deeper!
                            </p>
                        </div>
                    </div>

                    <div class="simple-terms" style="margin-top: 15px;">
                        <h5>Space Complexity: O(b<sup>d</sup>) - Why?</h5>
                        <div style="background: white; padding: 15px; border-radius: 8px; margin: 10px 0;">
                            <p><strong>Problem:</strong> BFS must store ALL nodes at the current level!</p>
                            <ul style="margin-left: 25px;">
                                <li>At level d, there can be b<sup>d</sup> nodes in the queue</li>
                                <li>This is the ENTIRE "frontier" of exploration</li>
                                <li>Unlike DFS which only stores ONE path</li>
                            </ul>
                            <p style="margin-top: 10px; background: #fee2e2; padding: 10px; border-radius: 4px;">
                                <strong>Warning:</strong> BFS can run out of memory on deep/wide graphs!
                                <br>Example: If b=10, d=6  10<sup>6</sup> = 1,000,000 nodes in queue!
                            </p>
                        </div>
                    </div>

                    <div class="simple-terms" style="margin-top: 15px;">
                        <h5>Why BFS Finds Shortest Path</h5>
                        <div style="background: white; padding: 15px; border-radius: 8px; margin: 10px 0;">
                            <p><strong>Proof by level:</strong></p>
                            <ol style="margin-left: 25px;">
                                <li>BFS explores ALL level 1 nodes before ANY level 2 node</li>
                                <li>If goal is at level 3, BFS checks levels 1, 2 first</li>
                                <li>If goal was at level 2, BFS would have found it earlier!</li>
                                <li>Therefore: First path found = shortest path (by edges)</li>
                            </ol>
                        </div>
                    </div>
                </div>

                <!-- BFS Visualization Section -->
                <div class="visualization-section" style="margin: 40px 0; background: linear-gradient(135deg, #0369a1 0%, #0ea5e9 100%); border-radius: 16px; padding: 30px;">
                    <h4 style="color: #fff; margin-bottom: 20px; text-align: center;">
                        <i class="fas fa-film"></i> BFS Algorithm Visualization
                    </h4>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; align-items: start;">
                        <!-- Video Player -->
                        <div style="background: #0f172a; border-radius: 12px; padding: 15px;">
                            <video id="bfsVideo" controls style="width: 100%; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                                <source src="assets/videos/bfs_search.mp4" type="video/mp4">
                                <source src="assets/videos/bfs_search.gif" type="image/gif">
                                Your browser does not support video playback.
                            </video>
                            <p style="color: #94a3b8; text-align: center; margin-top: 10px; font-size: 14px;">
                                <i class="fas fa-info-circle"></i> Click play to watch BFS traversal step-by-step
                            </p>
                        </div>

                        <!-- Step Images Gallery -->
                        <div style="background: rgba(255,255,255,0.1); border-radius: 12px; padding: 15px;">
                            <h5 style="color: #fef3c7; margin-bottom: 15px;"><i class="fas fa-images"></i> Step-by-Step Frames</h5>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; max-height: 300px; overflow-y: auto;">
                                <img src="assets/images/bfs_step_0.png" alt="BFS Step 0" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/bfs_step_1.png" alt="BFS Step 1" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/bfs_step_2.png" alt="BFS Step 2" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/bfs_step_3.png" alt="BFS Step 3" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/bfs_step_4.png" alt="BFS Step 4" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/bfs_step_5.png" alt="BFS Step 5" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/bfs_step_6.png" alt="BFS Step 6" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/bfs_step_7.png" alt="BFS Step 7" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/bfs_step_8.png" alt="BFS Step 8" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/bfs_step_9.png" alt="BFS Step 9" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                            </div>
                        </div>
                    </div>

                    <!-- BFS Legend -->
                    <div style="margin-top: 20px; background: rgba(255,255,255,0.95); border-radius: 8px; padding: 15px;">
                        <div style="display: flex; flex-wrap: wrap; gap: 20px; justify-content: center;">
                            <span><span style="display:inline-block;width:16px;height:16px;background:#0ea5e9;border-radius:50%;vertical-align:middle;"></span> Current Node</span>
                            <span><span style="display:inline-block;width:16px;height:16px;background:#6b7280;border-radius:50%;vertical-align:middle;"></span> Visited</span>
                            <span><span style="display:inline-block;width:16px;height:16px;background:#bae6fd;border-radius:50%;vertical-align:middle;"></span> In Queue</span>
                            <span><span style="display:inline-block;width:16px;height:16px;background:#f59e0b;border-radius:50%;vertical-align:middle;"></span> Goal Node</span>
                            <span><span style="display:inline-block;width:16px;height:16px;background:#22c55e;border-radius:50%;vertical-align:middle;"></span> Goal Found</span>
                        </div>
                        <p style="text-align: center; margin-top: 10px; color: #1e3a5f; font-weight: 500;">
                            <i class="fas fa-stream"></i> BFS uses <strong>Queue (FIFO)</strong> - explores level by level, guarantees shortest path
                        </p>
                    </div>
                </div>

                <!-- Comparison Chart -->
                <div class="chart-container">
                    <div class="chart-title"><i class="fas fa-chart-bar"></i> DFS vs BFS Comparison</div>
                    <canvas id="dfsVsBfsChart" height="120"></canvas>
                </div>

                <h3><i class="fas fa-balance-scale"></i>DFS vs BFS Comparison</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Property</th>
                            <th>DFS (Depth-First)</th>
                            <th>BFS (Breadth-First)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Data Structure</strong></td>
                            <td>Stack (LIFO)</td>
                            <td>Queue (FIFO)</td>
                        </tr>
                        <tr>
                            <td><strong>Exploration Pattern</strong></td>
                            <td>Deep first, then backtrack</td>
                            <td>Level by level (shallow first)</td>
                        </tr>
                        <tr>
                            <td><strong>Memory Usage</strong></td>
                            <td>O(bm) - Linear with depth</td>
                            <td>O(b<sup>d</sup>) - Exponential</td>
                        </tr>
                        <tr>
                            <td><strong>Finds Shortest Path?</strong></td>
                            <td>No</td>
                            <td>Yes (for unit costs)</td>
                        </tr>
                        <tr>
                            <td><strong>Best For</strong></td>
                            <td>Deep solutions, memory constraints</td>
                            <td>Shallow solutions, shortest path</td>
                        </tr>
                        <tr>
                            <td><strong>Industry Use</strong></td>
                            <td>Maze solving, topological sort, cycle detection</td>
                            <td>Shortest path, social network friends, web crawlers</td>
                        </tr>
                    </tbody>
                </table>

                <!-- Industry Example -->
                <div class="case-study">
                    <div class="case-study-title">
                        <i class="fas fa-industry"></i>Industry Application: Social Network Friend Recommendations
                    </div>
                    <p><strong>Company:</strong> LinkedIn, Facebook</p>
                    <p><strong>Problem:</strong> Find people within 2-3 degrees of connection</p>
                    <p><strong>Solution:</strong> BFS from user node, explore connections level by level</p>

                    <!-- Detailed Breakdown -->
                    <div style="margin-top: 25px; background: #fdf4ff; padding: 20px; border-radius: 12px; border: 2px solid #c026d3;">
                        <h4 style="color: #86198f; margin-bottom: 15px;"><i class="fas fa-project-diagram"></i> How LinkedIn "People You May Know" Works</h4>

                        <!-- Visual Diagram -->
                        <div style="background: #1e293b; color: #e2e8f0; padding: 20px; border-radius: 8px; font-family: monospace; font-size: 0.85em; overflow-x: auto;" role="img" aria-label="LinkedIn BFS Friend Recommendation Diagram: Shows a tree with Alice at the top (Level 0), her direct friends Bob, Charlie, Diana at Level 1, and friends-of-friends at Level 2. BFS explores level by level to find potential connections.">
                        <p class="sr-only" style="position: absolute; left: -10000px; width: 1px; height: 1px; overflow: hidden;">Diagram description: A hierarchical tree showing BFS exploration of social connections. Alice (you) at Level 0, connects to Bob, Charlie, Diana at Level 1 (1st degree). These connect to Eve, Frank, Grace, Henry at Level 2 (2nd degree - friend recommendations). BFS uses a queue to explore all Level 1 nodes before any Level 2 nodes.</p>
<pre style="margin: 0;">

                    BFS FOR FRIEND RECOMMENDATIONS                            

                                                                              
   Starting from YOU (Alice), BFS explores level by level:                   
                                                                              
                                                                     
                               ALICE    Level 0 (You)                   
                               (YOU)                                        
                                                                     
                                                   
                                                                           
                                                  
   Level 1     Bob     Charlie    Diana    Your direct friends 
   (Friends)                                      
                                                                           
                                 
                                                                         
                                
         Eve    Frank   Grace   Henry    Ivy                       
                                
   Level 2  Friends of friends - RECOMMEND THESE!                         
                                                                              
      
   WHY BFS?                                                                   
    Explores ALL Level 1 before Level 2 (closest connections first)         
    Uses Queue (FIFO) to maintain level order                                
    Stops at max_degree to limit search                                      
      
                                                                              
   BFS QUEUE TRACE:                                                           
       
    Step 1: Queue = [Alice]                                                
    Step 2: Pop Alice  Add Bob, Charlie, Diana                            
            Queue = [Bob, Charlie, Diana]                                  
    Step 3: Pop Bob  Add Eve, Frank (Bob's friends)                       
            Queue = [Charlie, Diana, Eve, Frank]                           
    Step 4: Pop Charlie  Add Grace                                        
            Queue = [Diana, Eve, Frank, Grace]                             
    ... continues level by level ...                                       
       
                                                                              
   OUTPUT: Recommend [Eve, Frank, Grace, Henry, Ivy] as "People You May Know"

</pre>
                        </div>

                        <!-- Algorithm Steps -->
                        <h5 style="color: #86198f; margin: 20px 0 10px 0;"><i class="fas fa-list-ol"></i> Step-by-Step Algorithm</h5>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 15px;">
                            <div style="background: white; padding: 15px; border-radius: 8px; text-align: center;">
                                <div style="font-size: 2em; color: #c026d3;">1</div>
                                <strong>Start Queue</strong>
                                <p style="font-size: 0.85em; margin-top: 5px;">Put yourself (the user) in the queue with degree=0</p>
                            </div>
                            <div style="background: white; padding: 15px; border-radius: 8px; text-align: center;">
                                <div style="font-size: 2em; color: #c026d3;">2</div>
                                <strong>Pop & Explore</strong>
                                <p style="font-size: 0.85em; margin-top: 5px;">Remove first person, add their friends (if not visited)</p>
                            </div>
                            <div style="background: white; padding: 15px; border-radius: 8px; text-align: center;">
                                <div style="font-size: 2em; color: #c026d3;">3</div>
                                <strong>Track Degree</strong>
                                <p style="font-size: 0.85em; margin-top: 5px;">Record connection degree (1st, 2nd, 3rd degree)</p>
                            </div>
                            <div style="background: white; padding: 15px; border-radius: 8px; text-align: center;">
                                <div style="font-size: 2em; color: #c026d3;">4</div>
                                <strong>Recommend</strong>
                                <p style="font-size: 0.85em; margin-top: 5px;">2nd degree = "People You May Know"!</p>
                            </div>
                        </div>

                        <div style="background: #f5d0fe; padding: 15px; border-radius: 8px; margin-top: 15px;">
                            <strong><i class="fas fa-lightbulb"></i> Why This Works:</strong> Friends of your friends are likely to share common interests! LinkedIn shows this count: "5 mutual connections" to help you recognize people.
                        </div>
                    </div>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-lang"><i class="fab fa-python"></i> Python - LinkedIn Connection Finder</span>
                        <button class="copy-button" onclick="copyCode(this)">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <div class="code-block"><span class="comment"># Industry Example: LinkedIn-style Connection Finder</span>
<span class="keyword">from</span> collections <span class="keyword">import</span> deque

<span class="keyword">class</span> <span class="class">SocialNetworkBFS</span>:
    <span class="string">"""Find connections within N degrees using BFS"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        <span class="comment"># Social network as adjacency list</span>
        self.network = {
            <span class="string">'Alice'</span>: [<span class="string">'Bob'</span>, <span class="string">'Charlie'</span>],
            <span class="string">'Bob'</span>: [<span class="string">'Alice'</span>, <span class="string">'David'</span>, <span class="string">'Eve'</span>],
            <span class="string">'Charlie'</span>: [<span class="string">'Alice'</span>, <span class="string">'Frank'</span>],
            <span class="string">'David'</span>: [<span class="string">'Bob'</span>, <span class="string">'Grace'</span>],
            <span class="string">'Eve'</span>: [<span class="string">'Bob'</span>, <span class="string">'Grace'</span>],
            <span class="string">'Frank'</span>: [<span class="string">'Charlie'</span>, <span class="string">'Henry'</span>],
            <span class="string">'Grace'</span>: [<span class="string">'David'</span>, <span class="string">'Eve'</span>],
            <span class="string">'Henry'</span>: [<span class="string">'Frank'</span>]
        }

    <span class="keyword">def</span> <span class="function">find_connections</span>(self, user, max_degree=<span class="number">2</span>):
        <span class="string">"""Find all connections within max_degree using BFS"""</span>
        queue = deque([(user, <span class="number">0</span>)])  <span class="comment"># (person, degree)</span>
        visited = {user: <span class="number">0</span>}  <span class="comment"># person -> degree</span>
        connections = {<span class="number">1</span>: [], <span class="number">2</span>: [], <span class="number">3</span>: []}  <span class="comment"># degree -> list of people</span>

        <span class="keyword">while</span> queue:
            person, degree = queue.popleft()

            <span class="keyword">if</span> degree >= max_degree:
                <span class="keyword">continue</span>

            <span class="keyword">for</span> friend <span class="keyword">in</span> self.network.get(person, []):
                <span class="keyword">if</span> friend <span class="keyword">not in</span> visited:
                    new_degree = degree + <span class="number">1</span>
                    visited[friend] = new_degree
                    connections[new_degree].append(friend)
                    queue.append((friend, new_degree))

        <span class="keyword">return</span> connections

    <span class="keyword">def</span> <span class="function">suggest_friends</span>(self, user):
        <span class="string">"""Suggest 2nd-degree connections as potential friends"""</span>
        connections = self.find_connections(user, max_degree=<span class="number">2</span>)
        first_degree = <span class="function">set</span>(connections[<span class="number">1</span>])

        <span class="comment"># 2nd degree connections (friends of friends) as suggestions</span>
        suggestions = [p <span class="keyword">for</span> p <span class="keyword">in</span> connections[<span class="number">2</span>] <span class="keyword">if</span> p <span class="keyword">not in</span> first_degree]
        <span class="keyword">return</span> suggestions

<span class="comment"># Demo</span>
network = SocialNetworkBFS()
<span class="function">print</span>(<span class="string">"Alice's connections:"</span>)
connections = network.find_connections(<span class="string">'Alice'</span>, max_degree=<span class="number">3</span>)
<span class="keyword">for</span> degree, people <span class="keyword">in</span> connections.items():
    <span class="keyword">if</span> people:
        <span class="function">print</span>(<span class="string">f"  {degree} connections: {people}"</span>)

<span class="function">print</span>(<span class="string">"\nFriend suggestions for Alice:"</span>, network.suggest_friends(<span class="string">'Alice'</span>))

<span class="comment"># Output:
# Alice's connections:
#   1 connections: ['Bob', 'Charlie']
#   2 connections: ['David', 'Eve', 'Frank']
#   3 connections: ['Grace', 'Henry']
# Friend suggestions for Alice: ['David', 'Eve', 'Frank']</span></div>
                </div>

                <!-- Practice Exercise for LinkedIn/Social Network BFS -->
                <div style="background: #f0fdf4; padding: 20px; border-radius: 12px; margin-top: 20px; border: 2px dashed #22c55e;">
                    <h5 style="color: #166534; margin-bottom: 15px;"><i class="fas fa-pencil-alt"></i> Practice Exercise: Social Network BFS</h5>

                    <p style="margin-bottom: 15px;"><strong>Exercise 1:</strong> Given the following social network, trace BFS to find all connections within 2 degrees from "Alice":</p>
                    <pre style="background: #1e293b; color: #e2e8f0; padding: 15px; border-radius: 8px; font-family: monospace;">
    Alice  Bob  David
              
    Carol  Eve  Frank
      
    Grace
                    </pre>

                    <details style="margin-top: 15px;">
                        <summary style="cursor: pointer; color: #166534; font-weight: bold;"><i class="fas fa-eye"></i> Show BFS Trace</summary>
                        <div style="margin-top: 10px; padding: 15px; background: white; border-radius: 8px;">
                            <table style="width:100%; font-size: 0.9em; border-collapse: collapse;">
                                <tr style="background:#dcfce7;"><th style="padding:8px; border:1px solid #ccc;">Level</th><th style="padding:8px; border:1px solid #ccc;">Queue State</th><th style="padding:8px; border:1px solid #ccc;">Current Person</th><th style="padding:8px; border:1px solid #ccc;">Discovered</th></tr>
                                <tr><td style="padding:8px; border:1px solid #ccc;">0</td><td style="padding:8px; border:1px solid #ccc;">[Alice]</td><td style="padding:8px; border:1px solid #ccc;">Alice</td><td style="padding:8px; border:1px solid #ccc;">Bob, Carol</td></tr>
                                <tr><td style="padding:8px; border:1px solid #ccc;">1</td><td style="padding:8px; border:1px solid #ccc;">[Bob, Carol]</td><td style="padding:8px; border:1px solid #ccc;">Bob</td><td style="padding:8px; border:1px solid #ccc;">David, Eve</td></tr>
                                <tr><td style="padding:8px; border:1px solid #ccc;">1</td><td style="padding:8px; border:1px solid #ccc;">[Carol, David, Eve]</td><td style="padding:8px; border:1px solid #ccc;">Carol</td><td style="padding:8px; border:1px solid #ccc;">Grace (Eve already seen)</td></tr>
                            </table>
                            <p style="margin-top:10px;"><strong>Result:</strong> 1 = {Bob, Carol}, 2 = {David, Eve, Grace}</p>
                        </div>
                    </details>

                    <p style="margin-top: 20px;"><strong>Exercise 2:</strong> Extend the SocialNetworkBFS class to count "mutual friends" between any two users. How would you use BFS for this?</p>

                    <details style="margin-top: 15px;">
                        <summary style="cursor: pointer; color: #166534; font-weight: bold;"><i class="fas fa-eye"></i> Show Solution Approach</summary>
                        <div style="margin-top: 10px; padding: 15px; background: white; border-radius: 8px;">
                            <pre style="background: #1e293b; color: #e2e8f0; padding: 10px; border-radius: 4px; font-size: 0.85em;">
def mutual_friends(self, user1, user2):
    """Find mutual friends between two users"""
    # Get direct friends of both users
    friends1 = set(self.network.get(user1, []))
    friends2 = set(self.network.get(user2, []))

    # Intersection = mutual friends
    mutual = friends1 & friends2
    return list(mutual)

# Usage: network.mutual_friends('Alice', 'David')
# Returns friends who know both Alice AND David</pre>
                            <p style="margin-top:10px;"><strong>Key Insight:</strong> Mutual friends are found by computing the intersection of two users' friend lists. BFS to level 1 gets direct friends, then set intersection finds common ones.</p>
                        </div>
                    </details>

                    <p style="margin-top: 20px;"><strong>Exercise 3 (Challenge):</strong> What is the time complexity of finding the shortest path between any two users in a social network with N users and E friend connections?</p>

                    <details style="margin-top: 15px;">
                        <summary style="cursor: pointer; color: #166534; font-weight: bold;"><i class="fas fa-eye"></i> Show Answer</summary>
                        <div style="margin-top: 10px; padding: 15px; background: white; border-radius: 8px;">
                            <p><strong>Answer:</strong> O(N + E) using BFS</p>
                            <ul style="margin-left: 20px; margin-top: 10px;">
                                <li><strong>N:</strong> Each user is visited at most once</li>
                                <li><strong>E:</strong> Each friendship edge is explored at most twice (once from each end)</li>
                            </ul>
                            <p style="margin-top:10px;"><em>Facebook has ~3B users and ~200B friend connections. Finding shortest path: O(203B) operations worst case, but BFS usually terminates much earlier due to "six degrees of separation"!</em></p>
                        </div>
                    </details>
                </div>

                <div class="qa-box">
                    <h4><i class="fas fa-question-circle"></i>CO1 Comprehensive Questions - Blind Search (DFS & BFS)</h4>

                    <!-- 3-MARK QUESTIONS -->
                    <div style="background: #e0f2fe; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h5 style="color: #0369a1; margin-bottom: 15px;"><i class="fas fa-star"></i> 3-Mark Questions (Short Answer)</h5>

                        <div class="question">
                            <strong>Q1 (3 marks):</strong> Define DFS and state its time and space complexity. Why is it not optimal?
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>Model Answer:</h5>
                                <p><strong>Definition (1 mark):</strong> Depth-First Search is an uninformed search algorithm that explores as far as possible along each branch before backtracking. It uses a Stack (LIFO) data structure.</p>
                                <p style="margin-top:10px;"><strong>Complexity (1 mark):</strong></p>
                                <ul style="margin-left:25px;">
                                    <li>Time: O(b<sup>m</sup>) where b=branching factor, m=maximum depth</li>
                                    <li>Space: O(bm) - only stores current path</li>
                                </ul>
                                <p style="margin-top:10px;"><strong>Not Optimal (1 mark):</strong> DFS may find a deeper solution first instead of a shallower one. It explores one branch completely before trying others, so it might miss a shorter path that exists in an unexplored branch.</p>
                            </div>
                        </div>

                        <div class="question">
                            <strong>Q2 (3 marks):</strong> Explain why BFS guarantees the shortest path in an unweighted graph.
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>Model Answer:</h5>
                                <p><strong>Level-by-Level Exploration (1 mark):</strong> BFS explores all nodes at depth d before any node at depth d+1.</p>
                                <p style="margin-top:10px;"><strong>First Discovery Property (1 mark):</strong> When BFS first reaches the goal, it has taken the minimum number of edges because:</p>
                                <ul style="margin-left:25px;">
                                    <li>All paths of length k are explored before paths of length k+1</li>
                                    <li>Goal at level d means no path shorter than d exists</li>
                                </ul>
                                <p style="margin-top:10px;"><strong>Queue Ordering (1 mark):</strong> FIFO queue ensures nodes are processed in order of their distance from start. Closer nodes are always processed before farther nodes.</p>
                            </div>
                        </div>

                        <div class="question">
                            <strong>Q3 (3 marks):</strong> Compare the memory requirements of DFS and BFS. Which is more memory-efficient and why?
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>Model Answer:</h5>
                                <p><strong>DFS Memory (1 mark):</strong> O(bm) - stores only one path from root to current node plus siblings at each level. Example: b=2, m=10  20 nodes max.</p>
                                <p style="margin-top:10px;"><strong>BFS Memory (1 mark):</strong> O(b<sup>d</sup>) - stores entire frontier (all nodes at current level). Example: b=2, d=10  1024 nodes at level 10!</p>
                                <p style="margin-top:10px;"><strong>DFS is more efficient (1 mark):</strong> Linear O(bm) vs exponential O(b<sup>d</sup>). For deep trees with large branching factor, BFS can run out of memory while DFS stays manageable.</p>
                            </div>
                        </div>

                        <div class="question">
                            <strong>Q4 (3 marks):</strong> What is the difference between a Stack and a Queue? How does this affect DFS vs BFS behavior?
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>Model Answer:</h5>
                                <p><strong>Stack - LIFO (1 mark):</strong> Last In First Out. New elements added to top, removed from top. Like a pile of plates.</p>
                                <p style="margin-top:10px;"><strong>Queue - FIFO (1 mark):</strong> First In First Out. New elements added to back, removed from front. Like a ticket line.</p>
                                <p style="margin-top:10px;"><strong>Effect on Search (1 mark):</strong></p>
                                <ul style="margin-left:25px;">
                                    <li>DFS (Stack): Most recently discovered node is explored next  goes deep</li>
                                    <li>BFS (Queue): Oldest discovered node is explored next  explores level by level</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <!-- 8-MARK QUESTIONS -->
                    <div style="background: #fce7f3; padding: 15px; border-radius: 8px;">
                        <h5 style="color: #be185d; margin-bottom: 15px;"><i class="fas fa-star"></i><i class="fas fa-star"></i> 8-Mark Questions (Long Answer)</h5>

                        <div class="question">
                            <strong>Q5 (8 marks):</strong> Trace both DFS and BFS on the following graph to find path from S to G. Show the complete state of stack/queue at each step.
                            <pre style="background: #f3f4f6; padding: 15px; margin: 10px 0; font-family: monospace;">
Graph:        S  A  B
                          
                          
              C  D  G

Edges: S-A, S-C, A-B, A-D, C-D, B-G, D-G
Start: S, Goal: G
                            </pre>
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>DFS Solution (4 marks):</h5>
                                <table style="width:100%; margin: 10px 0; font-size: 0.9em;">
                                    <tr style="background:#ede9fe;"><th>Step</th><th>Current</th><th>Stack (topbottom)</th><th>Visited</th><th>Action</th></tr>
                                    <tr><td>1</td><td>-</td><td>[S]</td><td>{}</td><td>Initialize with start</td></tr>
                                    <tr><td>2</td><td>S</td><td>[C, A]</td><td>{S}</td><td>Pop S, push neighbors A, C</td></tr>
                                    <tr><td>3</td><td>A</td><td>[C, D, B]</td><td>{S,A}</td><td>Pop A, push B, D</td></tr>
                                    <tr><td>4</td><td>B</td><td>[C, D, G]</td><td>{S,A,B}</td><td>Pop B, push G</td></tr>
                                    <tr style="background:#d1fae5;"><td>5</td><td>G</td><td>[C, D]</td><td>{S,A,B,G}</td><td><strong>GOAL FOUND!</strong></td></tr>
                                </table>
                                <p><strong>DFS Path:</strong> S  A  B  G (length 3)</p>
                                <p><strong>Nodes Explored:</strong> 4</p>
                            </div>

                            <div class="solution-step" style="margin-top: 20px;">
                                <h5>BFS Solution (4 marks):</h5>
                                <table style="width:100%; margin: 10px 0; font-size: 0.9em;">
                                    <tr style="background:#dbeafe;"><th>Step</th><th>Current</th><th>Queue (frontback)</th><th>Visited</th><th>Action</th></tr>
                                    <tr><td>1</td><td>-</td><td>[S]</td><td>{S}</td><td>Initialize</td></tr>
                                    <tr><td>2</td><td>S</td><td>[A, C]</td><td>{S,A,C}</td><td>Dequeue S, enqueue A, C</td></tr>
                                    <tr><td>3</td><td>A</td><td>[C, B, D]</td><td>{S,A,C,B,D}</td><td>Dequeue A, enqueue B, D</td></tr>
                                    <tr><td>4</td><td>C</td><td>[B, D]</td><td>{S,A,C,B,D}</td><td>Dequeue C, D already visited</td></tr>
                                    <tr><td>5</td><td>B</td><td>[D, G]</td><td>{S,A,C,B,D,G}</td><td>Dequeue B, enqueue G</td></tr>
                                    <tr><td>6</td><td>D</td><td>[G]</td><td>{S,A,C,B,D,G}</td><td>Dequeue D, G already queued</td></tr>
                                    <tr style="background:#d1fae5;"><td>7</td><td>G</td><td>[]</td><td>{S,A,C,B,D,G}</td><td><strong>GOAL FOUND!</strong></td></tr>
                                </table>
                                <p><strong>BFS Path:</strong> S  A  B  G (length 3) - <em>same as DFS here!</em></p>
                                <p><strong>Nodes Explored:</strong> 6</p>
                                <p><strong>Note:</strong> BFS explored more nodes but guarantees this is the shortest path.</p>
                            </div>
                        </div>

                        <div class="question" style="margin-top: 20px;">
                            <strong>Q6 (8 marks):</strong> A robot needs to navigate from room A to room F in a building. The room connections are: A-B, A-C, B-D, B-E, C-E, D-F, E-F.
                            <br>(a) Represent this as a state space search problem (2 marks)
                            <br>(b) Apply BFS to find the shortest path (3 marks)
                            <br>(c) Apply DFS and compare the result (3 marks)
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>(a) Problem Formulation (2 marks):</h5>
                                <ul style="margin-left:25px;">
                                    <li><strong>State:</strong> Current room the robot is in (A, B, C, D, E, or F)</li>
                                    <li><strong>Initial State:</strong> Room A</li>
                                    <li><strong>Goal State:</strong> Room F</li>
                                    <li><strong>Actions:</strong> Move to adjacent room</li>
                                    <li><strong>Transition:</strong> RESULT(A, move) = B or C; RESULT(B, move) = D or E</li>
                                    <li><strong>Path Cost:</strong> Number of room transitions</li>
                                </ul>
                            </div>

                            <div class="solution-step" style="margin-top: 15px;">
                                <h5>(b) BFS Solution (3 marks):</h5>
                                <pre style="background:#f0f9ff; padding:10px; border-radius:6px; font-size:0.9em;">
Level 0: [A]
Level 1: [B, C]       (from A)
Level 2: [D, E]       (from B, C - E shared)
Level 3: [F]          (from D or E)
                                </pre>
                                <p><strong>Shortest Path:</strong> A  B  D  F (3 moves)</p>
                                <p><strong>Alternative:</strong> A  B  E  F or A  C  E  F (also 3 moves)</p>
                                <p><em>BFS guarantees this is optimal - no 2-move path exists.</em></p>
                            </div>

                            <div class="solution-step" style="margin-top: 15px;">
                                <h5>(c) DFS Solution (3 marks):</h5>
                                <pre style="background:#fef3c7; padding:10px; border-radius:6px; font-size:0.9em;">
Stack: [A]
Pop A, push B, C  Stack: [C, B]
Pop B, push D, E  Stack: [C, E, D]
Pop D, push F  Stack: [C, E, F]
Pop F  GOAL FOUND!
                                </pre>
                                <p><strong>DFS Path:</strong> A  B  D  F (3 moves)</p>
                                <p><strong>Comparison:</strong></p>
                                <ul style="margin-left:25px;">
                                    <li>Both found same length path (lucky - not guaranteed!)</li>
                                    <li>DFS explored 4 nodes, BFS would explore more</li>
                                    <li>If goal was E: DFS might find ABE while BFS would find both ABE and ACE</li>
                                </ul>
                            </div>
                        </div>

                        <div class="question" style="margin-top: 20px;">
                            <strong>Q7 (8 marks):</strong> Explain the time and space complexity of DFS and BFS with examples. Under what conditions would each algorithm fail or perform poorly?
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>DFS Complexity Analysis (4 marks):</h5>
                                <div style="background:#ede9fe; padding:15px; border-radius:8px; margin:10px 0;">
                                    <p><strong>Time: O(b<sup>m</sup>)</strong></p>
                                    <ul style="margin-left:25px;">
                                        <li>b = branching factor (children per node)</li>
                                        <li>m = maximum depth of tree</li>
                                        <li>Example: b=3, m=5  3<sup>5</sup> = 243 nodes worst case</li>
                                    </ul>
                                    <p style="margin-top:10px;"><strong>Space: O(bm)</strong></p>
                                    <ul style="margin-left:25px;">
                                        <li>Stores one path + siblings at each level</li>
                                        <li>Example: b=3, m=5  15 nodes maximum in stack</li>
                                    </ul>
                                    <p style="margin-top:10px;"><strong>Failure Cases:</strong></p>
                                    <ul style="margin-left:25px;">
                                        <li>Infinite loops in graphs without cycle detection</li>
                                        <li>Infinite depth trees (never terminates)</li>
                                        <li>When optimal solution needed (DFS may find suboptimal)</li>
                                    </ul>
                                </div>
                            </div>

                            <div class="solution-step" style="margin-top: 15px;">
                                <h5>BFS Complexity Analysis (4 marks):</h5>
                                <div style="background:#dbeafe; padding:15px; border-radius:8px; margin:10px 0;">
                                    <p><strong>Time: O(b<sup>d</sup>)</strong></p>
                                    <ul style="margin-left:25px;">
                                        <li>d = depth of shallowest goal</li>
                                        <li>Example: b=3, d=5  3<sup>5</sup> = 243 nodes</li>
                                        <li>Better than DFS if d << m</li>
                                    </ul>
                                    <p style="margin-top:10px;"><strong>Space: O(b<sup>d</sup>)</strong></p>
                                    <ul style="margin-left:25px;">
                                        <li>Must store entire frontier level</li>
                                        <li>Example: b=10, d=6  10<sup>6</sup> = 1,000,000 nodes!</li>
                                    </ul>
                                    <p style="margin-top:10px;"><strong>Failure Cases:</strong></p>
                                    <ul style="margin-left:25px;">
                                        <li>Memory exhaustion on large branching factors</li>
                                        <li>Deep solutions waste time exploring shallow levels</li>
                                        <li>Not suitable for weighted graphs (use Dijkstra/A* instead)</li>
                                    </ul>
                                </div>
                            </div>
                        </div>

                        <div class="question" style="margin-top: 20px;">
                            <strong>Q8 (8 marks):</strong> Write a Python implementation of BFS that returns all paths of minimum length from start to goal, not just one path. Explain each part of your code.
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>Complete Solution with Explanation:</h5>
                                <pre style="background:#1e293b; color:#e2e8f0; padding:15px; border-radius:8px; font-size:0.85em; overflow-x:auto;">
<span style="color:#6b7280;"># (2 marks) Function definition and initialization</span>
<span style="color:#c084fc;">from</span> collections <span style="color:#c084fc;">import</span> deque

<span style="color:#c084fc;">def</span> <span style="color:#fbbf24;">bfs_all_shortest_paths</span>(graph, start, goal):
    <span style="color:#86efac;">"""Find ALL shortest paths from start to goal"""</span>
    <span style="color:#6b7280;"># Queue stores (current_node, path_so_far)</span>
    queue = deque([(start, [start])])
    visited_at_level = {start: 0}  <span style="color:#6b7280;"># Track level at which node was first visited</span>
    shortest_paths = []
    shortest_length = float('inf')

    <span style="color:#6b7280;"># (2 marks) Main BFS loop</span>
    <span style="color:#c084fc;">while</span> queue:
        node, path = queue.popleft()
        current_level = len(path) - 1

        <span style="color:#6b7280;"># Stop if we've passed the shortest path length</span>
        <span style="color:#c084fc;">if</span> len(path) > shortest_length:
            <span style="color:#c084fc;">break</span>

        <span style="color:#6b7280;"># (2 marks) Goal handling - collect all shortest paths</span>
        <span style="color:#c084fc;">if</span> node == goal:
            <span style="color:#c084fc;">if</span> len(path) < shortest_length:
                shortest_length = len(path)
                shortest_paths = [path]  <span style="color:#6b7280;"># New shorter path found</span>
            <span style="color:#c084fc;">elif</span> len(path) == shortest_length:
                shortest_paths.append(path)  <span style="color:#6b7280;"># Another path of same length</span>
            <span style="color:#c084fc;">continue</span>

        <span style="color:#6b7280;"># (2 marks) Explore neighbors</span>
        <span style="color:#c084fc;">for</span> neighbor <span style="color:#c084fc;">in</span> graph.get(node, []):
            next_level = current_level + 1
            <span style="color:#6b7280;"># Allow revisit if at same level (different path)</span>
            <span style="color:#c084fc;">if</span> neighbor <span style="color:#c084fc;">not in</span> visited_at_level <span style="color:#c084fc;">or</span> visited_at_level[neighbor] >= next_level:
                visited_at_level[neighbor] = next_level
                queue.append((neighbor, path + [neighbor]))

    <span style="color:#c084fc;">return</span> shortest_paths

<span style="color:#6b7280;"># Example usage</span>
graph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['D'], 'D': ['E']}
paths = bfs_all_shortest_paths(graph, 'A', 'D')
print(f"All shortest paths: {paths}")
<span style="color:#6b7280;"># Output: All shortest paths: [['A', 'B', 'D'], ['A', 'C', 'D']]</span>
                                </pre>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ==================== SECTION 4: INFORMED SEARCH ==================== -->
            <section id="informed">
                <h2><i class="fas fa-lightbulb"></i>4. Informed Search Techniques</h2>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>Informed Search (Heuristic Search):</strong> Search strategies that use problem-specific knowledge beyond the problem definition to guide the search toward the goal more efficiently.</p>
                </div>

                <div class="wwwh-grid">
                    <div class="wwwh-item what">
                        <h4><i class="fas fa-question-circle"></i>WHAT is Heuristic?</h4>
                        <p>A heuristic h(n) is a function that estimates the cost from node n to the goal. It provides "informed guesses" to guide search.</p>
                    </div>
                    <div class="wwwh-item why">
                        <h4><i class="fas fa-lightbulb"></i>WHY Use Heuristics?</h4>
                        <p>Dramatically reduces search space exploration. What takes BFS millions of nodes might take A* only hundreds with a good heuristic.</p>
                    </div>
                    <div class="wwwh-item when">
                        <h4><i class="fas fa-clock"></i>WHEN to Use?</h4>
                        <p>Large state spaces where blind search is impractical. When domain knowledge can estimate distance to goal.</p>
                    </div>
                    <div class="wwwh-item how">
                        <h4><i class="fas fa-cogs"></i>HOW to Choose h(n)?</h4>
                        <p>h(n) should be: (1) Admissible: never overestimate, (2) Consistent: h(n)  c(n,n') + h(n'), (3) Computationally cheap.</p>
                    </div>
                </div>

                <h3><i class="fas fa-calculator"></i>Heuristic Functions</h3>

                <div class="key-points">
                    <h4><i class="fas fa-key"></i>Properties of Good Heuristics</h4>
                    <ul>
                        <li><strong>Admissible:</strong> h(n)  h*(n) where h*(n) is true cost. Never overestimates!</li>
                        <li><strong>Consistent (Monotonic):</strong> h(n)  c(n,a,n') + h(n') for all successors n'</li>
                        <li><strong>Informative:</strong> Higher h values (while admissible) explore fewer nodes</li>
                    </ul>
                </div>

                <table>
                    <thead>
                        <tr>
                            <th>Problem</th>
                            <th>Heuristic h(n)</th>
                            <th>Admissible?</th>
                            <th>Explanation</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>8-Puzzle</strong></td>
                            <td>Misplaced tiles count</td>
                            <td>Yes</td>
                            <td>Each misplaced tile needs at least 1 move</td>
                        </tr>
                        <tr>
                            <td><strong>8-Puzzle</strong></td>
                            <td>Manhattan distance</td>
                            <td>Yes</td>
                            <td>Sum of distances each tile must move</td>
                        </tr>
                        <tr>
                            <td><strong>Route Finding</strong></td>
                            <td>Straight-line distance</td>
                            <td>Yes</td>
                            <td>Can't travel shorter than straight line</td>
                        </tr>
                        <tr>
                            <td><strong>N-Queens</strong></td>
                            <td>Conflicts remaining</td>
                            <td>No</td>
                            <td>One move may fix multiple conflicts</td>
                        </tr>
                    </tbody>
                </table>

                <h3><i class="fas fa-mountain"></i>Hill Climbing Search</h3>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>Hill Climbing:</strong> A local search algorithm that continuously moves toward increasing value (ascending the "hill" of the objective function). It keeps only the current state in memory.</p>
                </div>

                <!-- Hill Climbing Real-World Analogy -->
                <div class="analogy-box">
                    <div class="analogy-header">
                        <i class="fas fa-hiking"></i> Real-World Analogy: Hiking in Thick Fog
                    </div>
                    <p>Imagine you're a hiker trying to reach the highest point of a mountain range, but there's thick fog everywhere - you can only see a few meters around you!</p>

                    <div class="analogy-scenario">
                        <h5>The Hill Climbing Hiker's Strategy:</h5>
                        <p><strong>What you know:</strong> Only the slope immediately around your feet</p>
                        <p><strong>What you DON'T know:</strong> What's beyond the fog, where the true peak is</p>
                        <p><strong>Your strategy:</strong></p>
                        <ol style="margin-left:25px;">
                            <li>Look around your current position</li>
                            <li>Find which direction goes UP</li>
                            <li>Take a step in that direction</li>
                            <li>Repeat until no direction goes up</li>
                        </ol>
                        <p style="margin-top:10px;"><strong>The problem:</strong> When you reach a point where ALL directions go down, you stop. But is this THE highest peak, or just A peak? You can't tell because of the fog!</p>
                    </div>

                    <p style="margin-top:15px; background:#fff; padding:15px; border-radius:8px;">
                        <strong>This is exactly the "local maximum" problem!</strong> You found a peak, but there might be a much taller mountain somewhere else that you can't see or reach because you'd have to go DOWN first (which the algorithm refuses to do).
                    </p>
                </div>

                <!-- Chew & Feed for Hill Climbing -->
                <div class="chew-feed-box">
                    <div class="cf-header">
                        <i class="fas fa-utensils"></i> Understanding Hill Climbing: The "Greedy Climber"
                    </div>

                    <div class="simple-terms">
                        <h5>Hill Climbing in Plain English:</h5>
                        <p><strong>"Always take the step that looks best RIGHT NOW, and never go backwards."</strong></p>

                        <div style="margin-top:15px;">
                            <p><strong>Think of it like tuning a guitar by ear:</strong></p>
                            <ol style="margin-left:25px; margin-top:10px;">
                                <li>Pluck the string - sounds flat</li>
                                <li>Tighten slightly - sounds better!</li>
                                <li>Tighten more - even better!</li>
                                <li>Tighten more - now it sounds sharp (worse)</li>
                                <li>Loosen just a bit - perfect! Stop here.</li>
                            </ol>
                            <p style="margin-top:10px;"><em>You kept adjusting until any change made it worse. That's hill climbing!</em></p>
                        </div>
                    </div>

                    <div class="simple-terms" style="margin-top:15px; background:#fff3cd; padding:15px; border-radius:8px; border-left:4px solid #ffc107;">
                        <h5>The Three Deadly Problems:</h5>
                        <table style="width:100%; margin-top:10px;">
                            <tr>
                                <td style="width:30%; font-weight:bold; color:#856404;">Local Maximum</td>
                                <td>A small hill blocks your view of Mount Everest. You're on top of the small hill thinking you've won!</td>
                            </tr>
                            <tr>
                                <td style="font-weight:bold; color:#856404;">Plateau</td>
                                <td>A perfectly flat field - you can walk forever but never get higher. No direction seems better.</td>
                            </tr>
                            <tr>
                                <td style="font-weight:bold; color:#856404;">Ridge</td>
                                <td>A narrow mountain spine - you need to balance carefully, but the algorithm keeps slipping off the sides.</td>
                            </tr>
                        </table>
                    </div>
                </div>

                <!-- Daily Life Hill Climbing Examples -->
                <div class="daily-life-box">
                    <div class="daily-header">
                        <i class="fas fa-chart-line"></i> Hill Climbing Problems You Face Daily
                    </div>

                    <div class="daily-example">
                        <h5><i class="fas fa-dumbbell"></i> Optimizing Your Workout</h5>
                        <p><strong>Goal:</strong> Get as fit as possible</p>
                        <p><strong>Hill Climbing Approach:</strong> Try different exercises, keep what works better, discard what doesn't</p>
                        <p><strong>Local Maximum Problem:</strong> You found a routine that works "okay" - running 30 minutes daily. But maybe swimming would be MUCH better for you, but to try it you'd have to temporarily be worse at running (going "down" the hill).</p>
                    </div>

                    <div class="daily-example">
                        <h5><i class="fas fa-briefcase"></i> Career Optimization</h5>
                        <p><strong>Goal:</strong> Maximum career satisfaction and growth</p>
                        <p><strong>Hill Climbing:</strong> Take better opportunities when offered, avoid worse ones</p>
                        <p><strong>Local Maximum:</strong> You're the best employee at a small company (local peak), but might need to take a "junior" role at a top company (going down) to eventually reach a much higher peak (CEO of a Fortune 500).</p>
                    </div>

                    <div class="daily-example">
                        <h5><i class="fas fa-sliders-h"></i> Adjusting Your Car's Mirrors</h5>
                        <p><strong>Goal:</strong> Perfect rearview visibility</p>
                        <p><strong>Hill Climbing:</strong> Nudge the mirror, check if view improved, repeat</p>
                        <p><strong>Why it works here:</strong> Mirror adjustment is a simple, smooth problem with ONE optimal position - no local maxima to get stuck in!</p>
                    </div>
                </div>

                <!-- Why Hill Climbing Still Matters -->
                <div class="why-matters-box">
                    <div class="why-header">
                        <i class="fas fa-question-circle"></i> If Hill Climbing Gets Stuck, Why Use It?
                    </div>
                    <ul>
                        <li><strong>Extremely fast:</strong> Only needs to remember ONE state (current position). Uses almost no memory.</li>
                        <li><strong>Simple to implement:</strong> Just 10-15 lines of code for basic version.</li>
                        <li><strong>Good for smooth problems:</strong> Works perfectly when there ARE no local maxima (like adjusting sliders).</li>
                        <li><strong>Starting point for better algorithms:</strong> Simulated Annealing, Genetic Algorithms, and others build on this concept but add ways to escape local maxima.</li>
                        <li><strong>Often "good enough":</strong> In many real problems, a local maximum is still pretty good, even if not the absolute best.</li>
                    </ul>
                </div>

                <div class="algorithm-box">
                    <div class="algorithm-title">
                        <i class="fas fa-code"></i>Hill Climbing Algorithm
                    </div>
                    <ol class="algorithm-steps">
                        <li>Start with current = initial state</li>
                        <li>Generate all neighbors of current state</li>
                        <li>If no neighbor is better than current, return current (local maximum)</li>
                        <li>Set current = best neighbor</li>
                        <li>Go to step 2</li>
                    </ol>
                </div>

                <div class="warning-box">
                    <p><i class="fas fa-exclamation-triangle"></i><strong>Hill Climbing Problems:</strong></p>
                    <ul style="margin-left: 25px; margin-top: 10px;">
                        <li><strong>Local Maxima:</strong> Peaks that aren't the global maximum</li>
                        <li><strong>Plateaus:</strong> Flat areas where all neighbors have same value</li>
                        <li><strong>Ridges:</strong> Narrow elevated areas difficult to traverse</li>
                    </ul>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-lang"><i class="fab fa-python"></i> Python - Hill Climbing (Line-by-Line Explained)</span>
                        <button class="copy-button" onclick="copyCode(this)">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <div class="code-block"><span class="keyword">import</span> random  <span class="comment"># For random starting positions in N-Queens</span>

<span class="keyword">def</span> <span class="function">hill_climbing</span>(initial_state, get_neighbors, evaluate, maximize=<span class="keyword">True</span>):
    <span class="string">"""
    Hill Climbing Local Search Algorithm

    Think of it like climbing a mountain in fog - you can only see immediate neighbors.
    You keep moving to the highest neighbor until no neighbor is higher (stuck at peak).
    """</span>

    <span class="comment"># </span>
    <span class="comment"># LINE 1: Set starting position</span>
    <span class="comment"># </span>
    current = initial_state           <span class="comment"># Start at given position (e.g., x=0)</span>
    <span class="comment"># OUTPUT: current = 0 (our starting point)</span>

    <span class="comment"># </span>
    <span class="comment"># LINE 2: Evaluate current position</span>
    <span class="comment"># </span>
    current_value = evaluate(current)  <span class="comment"># How good is this position?</span>
    <span class="comment"># OUTPUT: current_value = f(0) = -(0-5) + 25 = -25 + 25 = 0</span>

    iterations = <span class="number">0</span>  <span class="comment"># Count how many steps we take</span>

    <span class="comment"># </span>
    <span class="comment"># MAIN LOOP: Keep climbing until stuck</span>
    <span class="comment"># </span>
    <span class="keyword">while</span> <span class="keyword">True</span>:                        <span class="comment"># Loop forever until we break</span>
        iterations += <span class="number">1</span>                <span class="comment"># Count this iteration</span>

        <span class="comment"># </span>
        <span class="comment"># LINE 3: Get all neighboring positions</span>
        <span class="comment"># </span>
        neighbors = get_neighbors(current)  <span class="comment"># What positions can we move to?</span>
        <span class="comment"># OUTPUT (iter 1): neighbors = [-0.1, 0.1] (step left or right)</span>

        <span class="keyword">if</span> <span class="keyword">not</span> neighbors:              <span class="comment"># No neighbors? We're done</span>
            <span class="keyword">break</span>

        <span class="comment"># </span>
        <span class="comment"># LINE 4-5: Find the BEST neighbor</span>
        <span class="comment"># </span>
        best_neighbor = <span class="keyword">None</span>           <span class="comment"># Haven't found a better one yet</span>
        best_neighbor_value = current_value  <span class="comment"># Must beat current value</span>

        <span class="keyword">for</span> neighbor <span class="keyword">in</span> neighbors:      <span class="comment"># Check each neighbor</span>
            value = evaluate(neighbor)  <span class="comment"># How good is this neighbor?</span>
            <span class="comment"># OUTPUT (iter 1): f(-0.1)=-0.19, f(0.1)=0.19</span>

            <span class="comment"># Is this neighbor better? (higher if maximizing)</span>
            <span class="keyword">if</span> (maximize <span class="keyword">and</span> value > best_neighbor_value) <span class="keyword">or</span> \
               (<span class="keyword">not</span> maximize <span class="keyword">and</span> value < best_neighbor_value):
                best_neighbor = neighbor
                best_neighbor_value = value
                <span class="comment"># OUTPUT (iter 1): best_neighbor=0.1, value=0.19</span>

        <span class="comment"># </span>
        <span class="comment"># LINE 6: Check if stuck (no better neighbor exists)</span>
        <span class="comment"># </span>
        <span class="keyword">if</span> best_neighbor <span class="keyword">is</span> <span class="keyword">None</span>:       <span class="comment"># No neighbor is better!</span>
            <span class="keyword">break</span>                       <span class="comment"># STUCK at local optimum!</span>

        <span class="comment"># </span>
        <span class="comment"># LINE 7: Move to the best neighbor</span>
        <span class="comment"># </span>
        current = best_neighbor         <span class="comment"># Take the step!</span>
        current_value = best_neighbor_value
        <span class="comment"># OUTPUT (iter 1): Moved from 0 to 0.1, value improved 00.19</span>

    <span class="comment"># </span>
    <span class="comment"># RETURN: Our best found position</span>
    <span class="comment"># </span>
    <span class="keyword">return</span> current, current_value, iterations

<span class="comment"># </span>
<span class="comment"># EXAMPLE: Find maximum of f(x) = -(x-5) + 25</span>
<span class="comment"># This is a parabola with peak at x=5, where f(5) = 25</span>
<span class="comment"># </span>

<span class="keyword">def</span> <span class="function">neighbors</span>(x):
    <span class="keyword">return</span> [x - <span class="number">0.1</span>, x + <span class="number">0.1</span>]  <span class="comment"># Can step 0.1 left or right</span>

<span class="keyword">def</span> <span class="function">f</span>(x):
    <span class="keyword">return</span> -(x - <span class="number">5</span>)**<span class="number">2</span> + <span class="number">25</span>      <span class="comment"># Parabola: peak at x=5</span>

result, value, iters = hill_climbing(<span class="number">0</span>, neighbors, f)
<span class="function">print</span>(<span class="string">f"Found x = {result:.2f}, f(x) = {value:.2f} in {iters} iterations"</span>)

<span class="comment"># </span>
<span class="comment"># EXECUTION TRACE (first 5 iterations):</span>
<span class="comment"># </span>
<span class="comment"># Iter 1: current=0.0, f(0)=0.00     neighbors: f(-0.1)=-0.19, f(0.1)=0.19</span>
<span class="comment">#         Best: 0.1 (value 0.19)  MOVE to 0.1</span>
<span class="comment"># Iter 2: current=0.1, f(0.1)=0.19   neighbors: f(0.0)=0.00, f(0.2)=0.36</span>
<span class="comment">#         Best: 0.2 (value 0.36)  MOVE to 0.2</span>
<span class="comment"># Iter 3: current=0.2, f(0.2)=0.36   neighbors: f(0.1)=0.19, f(0.3)=0.51</span>
<span class="comment">#         Best: 0.3 (value 0.51)  MOVE to 0.3</span>
<span class="comment"># ... continues climbing toward x=5 ...</span>
<span class="comment"># Iter 50: current=4.9, f(4.9)=24.99  neighbors: f(4.8)=24.96, f(5.0)=25.00</span>
<span class="comment">#          Best: 5.0 (value 25.00)  MOVE to 5.0</span>
<span class="comment"># Iter 51: current=5.0, f(5.0)=25.00  neighbors: f(4.9)=24.99, f(5.1)=24.99</span>
<span class="comment">#          No neighbor is better  STOP! Local maximum found!</span>
<span class="comment">#</span>
<span class="comment"># OUTPUT: Found x = 5.00, f(x) = 25.00 in 51 iterations</span>
<span class="comment"># </span></div>
                </div>

                <!-- Hill Climbing Complexity Explanation -->
                <div class="walkthrough-box" style="margin: 25px 0;">
                    <h4 style="color: #1e3a5f; margin-bottom: 15px;"><i class="fas fa-clock"></i> Hill Climbing Complexity - Simple Explanation</h4>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div style="background: #d1fae5; padding: 15px; border-radius: 8px; border-left: 4px solid #10b981;">
                            <h5 style="color: #065f46;">Time Complexity: O() worst case, typically O(n  b)</h5>
                            <p><strong>Why?</strong></p>
                            <ul style="margin-left: 20px; font-size: 0.95em;">
                                <li><strong>n</strong> = number of iterations (steps) until we reach a peak</li>
                                <li><strong>b</strong> = number of neighbors to check at each step</li>
                                <li>At each step: check all b neighbors = O(b) work</li>
                                <li>Total steps: varies (depends on starting point and landscape)</li>
                            </ul>
                            <div style="background: #f0fdf4; padding: 10px; border-radius: 4px; margin-top: 10px;">
                                <strong>Simple analogy:</strong> If you take 51 steps to climb a hill, and at each step you look at 2 neighbors (left/right), you do 51  2 = 102 evaluations.
                            </div>
                        </div>

                        <div style="background: #dbeafe; padding: 15px; border-radius: 8px; border-left: 4px solid #3b82f6;">
                            <h5 style="color: #1e40af;">Space Complexity: O(b) = O(1) effectively</h5>
                            <p><strong>Why?</strong></p>
                            <ul style="margin-left: 20px; font-size: 0.95em;">
                                <li>Only stores <strong>current state</strong> (1 position)</li>
                                <li>Only stores <strong>best neighbor</strong> (1 position)</li>
                                <li><strong>NO memory of path!</strong> Unlike BFS/DFS, no queue/stack</li>
                                <li>Doesn't remember where it's been</li>
                            </ul>
                            <div style="background: #eff6ff; padding: 10px; border-radius: 4px; margin-top: 10px;">
                                <strong>Simple analogy:</strong> Like a hiker with no map and no GPS history. Only knows "I'm here" and "which way is up?"
                            </div>
                        </div>
                    </div>

                    <div style="background: #fef3c7; padding: 15px; border-radius: 8px; margin-top: 15px; border-left: 4px solid #f59e0b;">
                        <h5 style="color: #92400e;"><i class="fas fa-exclamation-triangle"></i> Why No Guarantee?</h5>
                        <p>Hill Climbing is <strong>NOT complete</strong> and <strong>NOT optimal</strong>:</p>
                        <ul style="margin-left: 20px;">
                            <li><strong>Not Complete:</strong> May get stuck at local maxima (not find ANY solution)</li>
                            <li><strong>Not Optimal:</strong> Even if it finds a solution, may not be the best one</li>
                            <li><strong>Trade-off:</strong> Super fast and low memory, but no guarantees</li>
                        </ul>
                    </div>
                </div>

                <!-- Hill Climbing Visualization Section -->
                <div class="visualization-section" style="margin: 40px 0; background: linear-gradient(135deg, #dc2626 0%, #f59e0b 100%); border-radius: 16px; padding: 30px;">
                    <h4 style="color: #fff; margin-bottom: 20px; text-align: center;">
                        <i class="fas fa-mountain"></i> Hill Climbing Visualization - Local Maxima Problem
                    </h4>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; align-items: start;">
                        <!-- Video Player -->
                        <div style="background: #0f172a; border-radius: 12px; padding: 15px;">
                            <video id="hillclimbVideo" controls style="width: 100%; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                                <source src="assets/videos/hillclimbing.mp4" type="video/mp4">
                                <source src="assets/videos/hillclimbing.gif" type="image/gif">
                                Your browser does not support video playback.
                            </video>
                            <p style="color: #94a3b8; text-align: center; margin-top: 10px; font-size: 14px;">
                                <i class="fas fa-info-circle"></i> Watch how Hill Climbing gets stuck at local maximum
                            </p>
                        </div>

                        <!-- Step Images Gallery -->
                        <div style="background: rgba(255,255,255,0.1); border-radius: 12px; padding: 15px;">
                            <h5 style="color: #fef3c7; margin-bottom: 15px;"><i class="fas fa-images"></i> Step-by-Step Frames</h5>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; max-height: 300px; overflow-y: auto;">
                                <img src="assets/images/hillclimb_step_0.png" alt="Hill Climb Step 0" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/hillclimb_step_1.png" alt="Hill Climb Step 1" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/hillclimb_step_2.png" alt="Hill Climb Step 2" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/hillclimb_step_3.png" alt="Hill Climb Step 3" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/hillclimb_step_4.png" alt="Hill Climb Step 4" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/hillclimb_step_5.png" alt="Hill Climb Step 5" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                            </div>
                        </div>
                    </div>

                    <!-- Hill Climbing Legend -->
                    <div style="margin-top: 20px; background: rgba(255,255,255,0.95); border-radius: 8px; padding: 15px;">
                        <div style="display: flex; flex-wrap: wrap; gap: 20px; justify-content: center;">
                            <span><span style="display:inline-block;width:16px;height:16px;background:#ef4444;border-radius:50%;vertical-align:middle;"></span> Current Position</span>
                            <span><span style="display:inline-block;width:16px;height:16px;background:#94a3b8;border-radius:50%;vertical-align:middle;"></span> Previous Steps</span>
                            <span><span style="display:inline-block;width:16px;height:16px;background:#22c55e;border-radius:50%;vertical-align:middle;"></span> Global Maximum</span>
                            <span><span style="display:inline-block;width:16px;height:16px;background:#f59e0b;border-radius:50%;vertical-align:middle;"></span> Local Maximum (stuck!)</span>
                        </div>
                        <p style="text-align: center; margin-top: 10px; color: #1e3a5f; font-weight: 500;">
                            <i class="fas fa-exclamation-triangle"></i> <strong>Problem:</strong> Hill Climbing gets stuck at local maxima! Solutions: Random Restart, Simulated Annealing, Genetic Algorithms
                        </p>
                    </div>
                </div>

                <!-- Q&A Section for Informed Search / Hill Climbing -->
                <div class="qa-box">
                    <h4><i class="fas fa-question-circle"></i>CO1 Comprehensive Questions - Informed Search & Hill Climbing</h4>

                    <!-- 3-MARK QUESTIONS -->
                    <div style="background: #d1fae5; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h5 style="color: #065f46; margin-bottom: 15px;"><i class="fas fa-star"></i> 3-Mark Questions (Short Answer)</h5>

                        <div class="question">
                            <strong>Q1 (3 marks):</strong> Define informed search. What makes it different from blind search?
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>Model Answer:</h5>
                                <p><strong>Informed Search Definition (1 mark):</strong> Informed search (heuristic search) uses problem-specific knowledge beyond the problem definition to guide the search toward the goal more efficiently.</p>
                                <p style="margin-top:10px;"><strong>Key Difference (2 marks):</strong></p>
                                <table style="width:100%; margin:10px 0; font-size:0.9em;">
                                    <tr style="background:#d1fae5;"><th>Aspect</th><th>Blind Search</th><th>Informed Search</th></tr>
                                    <tr><td>Knowledge</td><td>Only knows goal test</td><td>Has estimate of "closeness" to goal</td></tr>
                                    <tr><td>Strategy</td><td>Systematic (BFS/DFS)</td><td>Uses heuristic function h(n)</td></tr>
                                    <tr><td>Efficiency</td><td>Explores many irrelevant nodes</td><td>Focuses on promising paths</td></tr>
                                </table>
                            </div>
                        </div>

                        <div class="question">
                            <strong>Q2 (3 marks):</strong> Explain the Hill Climbing algorithm in simple terms. Why is it called "local search"?
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>Model Answer:</h5>
                                <p><strong>Hill Climbing Explanation (2 marks):</strong></p>
                                <ol style="margin-left:25px;">
                                    <li>Start at any position in the search space</li>
                                    <li>Look at all neighboring positions</li>
                                    <li>Move to the neighbor with the best value</li>
                                    <li>Repeat until no neighbor is better (stuck at peak)</li>
                                </ol>
                                <p style="margin-top:10px;"><strong>Why "Local Search" (1 mark):</strong></p>
                                <ul style="margin-left:25px;">
                                    <li>Only looks at <strong>immediate neighbors</strong> (local view)</li>
                                    <li>Has no memory of where it's been (no global view)</li>
                                    <li>Makes decisions based only on current position</li>
                                </ul>
                                <div class="insight">Analogy: Like climbing a mountain in thick fog - you can only see your feet and take steps uphill, but can't see the whole mountain.</div>
                            </div>
                        </div>

                        <div class="question">
                            <strong>Q3 (3 marks):</strong> What are the three main problems with Hill Climbing? Give a brief example of each.
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>Model Answer (1 mark each):</h5>
                                <ol style="margin-left:25px;">
                                    <li><strong>Local Maxima:</strong> Peaks that aren't the highest point.
                                        <br><em>Example:</em> In f(x) with multiple peaks, algorithm reaches x=2.8 (local max) instead of x=5 (global max).</li>
                                    <li style="margin-top:10px;"><strong>Plateaus (Flat Areas):</strong> Regions where all neighbors have the same value.
                                        <br><em>Example:</em> A flat hilltop where f(x)=10 for x=3 to x=7. Algorithm can't decide which way to go.</li>
                                    <li style="margin-top:10px;"><strong>Ridges:</strong> Narrow elevated paths that are hard to traverse.
                                        <br><em>Example:</em> In 2D, a diagonal ridge where neither pure x nor pure y movement goes uphill, but diagonal would.</li>
                                </ol>
                            </div>
                        </div>

                        <div class="question">
                            <strong>Q4 (3 marks):</strong> What is a heuristic function? List two properties of a good heuristic.
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>Model Answer:</h5>
                                <p><strong>Heuristic Function Definition (1 mark):</strong></p>
                                <p>A heuristic function h(n) is an estimate of the cost from node n to the goal. It provides "guidance" to the search algorithm.</p>
                                <p style="margin-top:10px;"><strong>Properties of Good Heuristics (2 marks):</strong></p>
                                <ol style="margin-left:25px;">
                                    <li><strong>Admissible:</strong> Never overestimates the true cost (h(n)  actual cost).
                                        <br><em>Why important:</em> Guarantees optimal solution in A*.</li>
                                    <li><strong>Consistent (Monotonic):</strong> For every node n and successor n': h(n)  cost(nn') + h(n').
                                        <br><em>Why important:</em> Ensures nodes are expanded in optimal order.</li>
                                </ol>
                                <p style="margin-top:10px;"><em>Additional good property:</em> <strong>Informative</strong> - higher values (while staying admissible) reduce search effort.</p>
                            </div>
                        </div>
                    </div>

                    <!-- 8-MARK QUESTIONS -->
                    <div style="background: #fef3c7; padding: 15px; border-radius: 8px;">
                        <h5 style="color: #92400e; margin-bottom: 15px;"><i class="fas fa-star"></i><i class="fas fa-star"></i> 8-Mark Questions (Long Answer)</h5>

                        <div class="question">
                            <strong>Q5 (8 marks):</strong> Explain Hill Climbing with a complete example. Show the step-by-step execution for finding the maximum of f(x) = -(x-3) + 9, starting from x=0 with step size 0.5.
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>Step 1: Understand the Problem (1 mark)</h5>
                                <p>Function: f(x) = -(x-3) + 9 is a parabola opening downward</p>
                                <ul style="margin-left:25px;">
                                    <li>Maximum is at x = 3, where f(3) = 9</li>
                                    <li>Starting point: x = 0, where f(0) = -(0-3) + 9 = -9 + 9 = 0</li>
                                    <li>Neighbors: x - 0.5 and x + 0.5</li>
                                </ul>
                            </div>

                            <div class="solution-step">
                                <h5>Step 2: Execution Trace (5 marks)</h5>
                                <table style="width:100%; font-size:0.9em; margin-top:10px;">
                                    <tr style="background:#fef3c7;"><th>Iteration</th><th>Current x</th><th>f(current)</th><th>f(x-0.5)</th><th>f(x+0.5)</th><th>Action</th></tr>
                                    <tr><td>0</td><td>0.0</td><td>0.00</td><td>-</td><td>-</td><td>Start</td></tr>
                                    <tr><td>1</td><td>0.0</td><td>0.00</td><td>f(-0.5)=-3.25</td><td>f(0.5)=2.75</td><td>Move to 0.5 (2.75 > 0)</td></tr>
                                    <tr><td>2</td><td>0.5</td><td>2.75</td><td>f(0)=0</td><td>f(1.0)=5.00</td><td>Move to 1.0 (5.0 > 2.75)</td></tr>
                                    <tr><td>3</td><td>1.0</td><td>5.00</td><td>f(0.5)=2.75</td><td>f(1.5)=6.75</td><td>Move to 1.5 (6.75 > 5.0)</td></tr>
                                    <tr><td>4</td><td>1.5</td><td>6.75</td><td>f(1.0)=5.0</td><td>f(2.0)=8.00</td><td>Move to 2.0 (8.0 > 6.75)</td></tr>
                                    <tr><td>5</td><td>2.0</td><td>8.00</td><td>f(1.5)=6.75</td><td>f(2.5)=8.75</td><td>Move to 2.5 (8.75 > 8.0)</td></tr>
                                    <tr><td>6</td><td>2.5</td><td>8.75</td><td>f(2.0)=8.0</td><td>f(3.0)=9.00</td><td>Move to 3.0 (9.0 > 8.75)</td></tr>
                                    <tr style="background:#d1fae5;"><td>7</td><td>3.0</td><td>9.00</td><td>f(2.5)=8.75</td><td>f(3.5)=8.75</td><td><strong>STOP!</strong> No better neighbor</td></tr>
                                </table>
                            </div>

                            <div class="solution-step">
                                <h5>Step 3: Result Analysis (2 marks)</h5>
                                <ul style="margin-left:25px;">
                                    <li><strong>Found:</strong> x = 3.0, f(x) = 9.0</li>
                                    <li><strong>Iterations:</strong> 7 steps from x=0 to x=3</li>
                                    <li><strong>Success:</strong> This is the global maximum!</li>
                                    <li><strong>Lucky case:</strong> Single-peak function means no local maxima to get stuck in</li>
                                </ul>
                                <div class="insight">
                                    <strong>Note:</strong> If this function had multiple peaks (like sin(x)), starting from x=0 might have found a local maximum instead of the global one.
                                </div>
                            </div>
                        </div>

                        <div class="question">
                            <strong>Q6 (8 marks):</strong> Compare Greedy Best-First Search and Hill Climbing. When would you use each? Illustrate with the 8-puzzle problem.
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>Comparison Table (4 marks)</h5>
                                <table style="width:100%; font-size:0.9em; margin-top:10px;">
                                    <tr style="background:#fef3c7;"><th>Property</th><th>Hill Climbing</th><th>Greedy Best-First</th></tr>
                                    <tr><td>Search Type</td><td>Local search (no memory)</td><td>Global search (maintains frontier)</td></tr>
                                    <tr><td>Data Structure</td><td>Single current state</td><td>Priority queue</td></tr>
                                    <tr><td>Memory</td><td>O(1) - constant</td><td>O(b^m) - exponential</td></tr>
                                    <tr><td>Evaluation</td><td>h(n) for current neighbors</td><td>h(n) for all frontier nodes</td></tr>
                                    <tr><td>Path Tracking</td><td>No (just final state)</td><td>Yes (can return full path)</td></tr>
                                    <tr><td>Complete?</td><td>No (stuck at local optima)</td><td>No (can get stuck in loops)</td></tr>
                                    <tr><td>Optimal?</td><td>No</td><td>No</td></tr>
                                    <tr><td>Backtracking</td><td>None</td><td>Implicit (via frontier)</td></tr>
                                </table>
                            </div>

                            <div class="solution-step">
                                <h5>When to Use Each (2 marks)</h5>
                                <p><strong>Use Hill Climbing when:</strong></p>
                                <ul style="margin-left:25px;">
                                    <li>Memory is extremely limited</li>
                                    <li>You only need the final state (not the path)</li>
                                    <li>Problem has many solutions (any good one acceptable)</li>
                                    <li>Example: N-Queens placement, scheduling optimization</li>
                                </ul>
                                <p style="margin-top:10px;"><strong>Use Greedy Best-First when:</strong></p>
                                <ul style="margin-left:25px;">
                                    <li>You need the complete path from start to goal</li>
                                    <li>Problem might have dead-ends (need backtracking)</li>
                                    <li>State space is not too large</li>
                                    <li>Example: Pathfinding, puzzle solving</li>
                                </ul>
                            </div>

                            <div class="solution-step">
                                <h5>8-Puzzle Example (2 marks)</h5>
                                <p><strong>Hill Climbing approach:</strong></p>
                                <ul style="margin-left:25px;">
                                    <li>State = current tile arrangement</li>
                                    <li>h(n) = number of misplaced tiles</li>
                                    <li>Pick the move that reduces misplaced tiles most</li>
                                    <li><strong>Problem:</strong> Can get stuck if no single move improves h(n)</li>
                                </ul>
                                <p style="margin-top:10px;"><strong>Greedy Best-First approach:</strong></p>
                                <ul style="margin-left:25px;">
                                    <li>Maintain priority queue of all explored states</li>
                                    <li>Always expand state with lowest h(n)</li>
                                    <li>Can backtrack if current path leads to dead-end</li>
                                    <li><strong>Problem:</strong> May not find shortest solution</li>
                                </ul>
                            </div>
                        </div>

                        <div class="question">
                            <strong>Q7 (8 marks):</strong> Describe Random Restart Hill Climbing and Simulated Annealing as solutions to Hill Climbing's limitations.
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>Random Restart Hill Climbing (4 marks)</h5>
                                <p><strong>Algorithm:</strong></p>
                                <ol style="margin-left:25px;">
                                    <li>Run standard Hill Climbing from a random starting point</li>
                                    <li>Record the best solution found</li>
                                    <li>Restart from a NEW random starting point</li>
                                    <li>Repeat for N restarts (or until time limit)</li>
                                    <li>Return the best solution across all runs</li>
                                </ol>
                                <p style="margin-top:10px;"><strong>Why it works:</strong></p>
                                <ul style="margin-left:25px;">
                                    <li>Different starting points reach different local maxima</li>
                                    <li>With enough restarts, likely to hit global maximum's "basin"</li>
                                    <li>If k restarts and probability p of finding global max per restart, overall probability = 1 - (1-p)^k</li>
                                </ul>
                                <div class="insight">Example: With 10% chance per restart and 20 restarts: 1 - (0.9)^20 = 88% chance of finding global max!</div>
                            </div>

                            <div class="solution-step">
                                <h5>Simulated Annealing (4 marks)</h5>
                                <p><strong>Key Idea:</strong> Sometimes accept WORSE moves to escape local optima!</p>
                                <p><strong>Algorithm:</strong></p>
                                <ol style="margin-left:25px;">
                                    <li>Start with high "temperature" T</li>
                                    <li>Generate random neighbor</li>
                                    <li>If better: always accept</li>
                                    <li>If worse: accept with probability e^(-E/T)</li>
                                    <li>Gradually decrease T (cooling schedule)</li>
                                    <li>When T  0, behaves like regular Hill Climbing</li>
                                </ol>
                                <p style="margin-top:10px;"><strong>Why it works:</strong></p>
                                <ul style="margin-left:25px;">
                                    <li>High T: Accepts many bad moves  explores widely</li>
                                    <li>Low T: Accepts few bad moves  focuses on refinement</li>
                                    <li>Mimics metallurgical annealing (slow cooling = stronger metal)</li>
                                </ul>
                                <div class="insight">Real-world use: VLSI chip design, airline scheduling, protein folding. Proven to converge to optimal with slow enough cooling!</div>
                            </div>
                        </div>
                    </div>
                </div>

                <h3><i class="fas fa-arrow-right"></i>Best-First Search</h3>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>Greedy Best-First Search:</strong> Expands the node that appears closest to the goal based on heuristic h(n). Uses a priority queue ordered by h(n).</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-lang"><i class="fab fa-python"></i> Python - Greedy Best-First Search</span>
                        <button class="copy-button" onclick="copyCode(this)">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <div class="code-block"><span class="keyword">import</span> heapq

<span class="keyword">def</span> <span class="function">greedy_best_first</span>(problem, start, goal):
    <span class="string">"""
    Greedy Best-First Search
    Expands node with lowest h(n) - estimated distance to goal

    Fast but not optimal - might not find shortest path
    """</span>
    <span class="comment"># Priority queue: (h(n), node, path)</span>
    frontier = [(problem.h(start), start, [start])]
    visited = <span class="function">set</span>()
    nodes_explored = <span class="number">0</span>

    <span class="keyword">while</span> frontier:
        h_val, node, path = heapq.heappop(frontier)
        nodes_explored += <span class="number">1</span>

        <span class="keyword">if</span> node == goal:
            <span class="function">print</span>(<span class="string">f"Greedy BFS: Found in {nodes_explored} nodes"</span>)
            <span class="keyword">return</span> path, h_val

        <span class="keyword">if</span> node <span class="keyword">in</span> visited:
            <span class="keyword">continue</span>
        visited.add(node)

        <span class="keyword">for</span> neighbor <span class="keyword">in</span> problem.actions(node):
            <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                heapq.heappush(frontier, (
                    problem.h(neighbor),
                    neighbor,
                    path + [neighbor]
                ))

    <span class="keyword">return</span> <span class="keyword">None</span>, <span class="function">float</span>(<span class="string">'inf'</span>)

<span class="comment"># Using Romania map from earlier</span>
<span class="comment"># problem = RoutePlanningProblem('Arad', 'Bucharest')</span>
<span class="comment"># path, _ = greedy_best_first(problem, 'Arad', 'Bucharest')</span>
<span class="comment"># Result: Arad -> Sibiu -> Fagaras -> Bucharest (not optimal!)</span></div>
                </div>

                <div class="comparison-grid">
                    <div class="comparison-card">
                        <h4><i class="fas fa-mountain"></i> Hill Climbing</h4>
                        <ul style="text-align: left; margin-left: 20px;">
                            <li>Local search (memory-less)</li>
                            <li>Only keeps current state</li>
                            <li>Gets stuck in local optima</li>
                            <li>Very fast, low memory</li>
                            <li>Use: Optimization problems</li>
                        </ul>
                    </div>
                    <div class="comparison-card">
                        <h4><i class="fas fa-route"></i> Best-First Search</h4>
                        <ul style="text-align: left; margin-left: 20px;">
                            <li>Global search (tree/graph)</li>
                            <li>Keeps frontier in memory</li>
                            <li>Explores promising paths</li>
                            <li>Not optimal</li>
                            <li>Use: Large state spaces</li>
                        </ul>
                    </div>
                </div>

                <div class="qa-box">
                    <h4><i class="fas fa-question-circle"></i>CO1 Sample Questions - Informed Search</h4>

                    <div class="question">
                        <strong>Q7:</strong> Define heuristic function. What makes a heuristic admissible?
                        <div class="answer">
                            <strong>Answer:</strong> A heuristic function h(n) estimates the cost from node n to the goal state.
                            <br><br>A heuristic is <strong>admissible</strong> if it never overestimates the actual cost:
                            <br>h(n)  h*(n) for all nodes n
                            <br>where h*(n) is the true optimal cost to reach goal from n.
                            <br><br>Example: In route-finding, straight-line distance is admissible because you can't travel shorter than a straight line.
                        </div>
                    </div>

                    <div class="question">
                        <strong>Q8:</strong> What are the limitations of Hill Climbing? How can they be addressed?
                        <div class="answer">
                            <strong>Answer:</strong>
                            <br><strong>Limitations:</strong>
                            <br>1. Local Maxima - stuck at suboptimal peaks
                            <br>2. Plateaus - flat regions with no gradient
                            <br>3. Ridges - narrow peaks hard to traverse
                            <br>
                            <br><strong>Solutions:</strong>
                            <br>1. <em>Random Restart:</em> Run multiple times from random starts
                            <br>2. <em>Simulated Annealing:</em> Accept worse moves with decreasing probability
                            <br>3. <em>Stochastic Hill Climbing:</em> Random selection among uphill moves
                            <br>4. <em>Genetic Algorithms:</em> Population-based search
                        </div>
                    </div>
                </div>
            </section>

            <!-- ==================== SECTION 5: A* AND AO* SEARCH ==================== -->
            <section id="astar">
                <h2><i class="fas fa-star"></i>5. A* and AO* Search Algorithms</h2>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>A* Search:</strong> The most widely used informed search algorithm. Combines the actual cost to reach a node g(n) with the estimated cost to reach goal h(n). Evaluation function: <strong>f(n) = g(n) + h(n)</strong></p>
                </div>

                <!-- A* Real-World Analogy -->
                <div class="analogy-box">
                    <div class="analogy-header">
                        <i class="fas fa-map-marked-alt"></i> Real-World Analogy: Planning a Road Trip
                    </div>
                    <p>Imagine you're driving from your home to a destination you've never been to. You have a GPS that shows:</p>

                    <div class="analogy-scenario">
                        <h5>How A* is Like Your GPS Navigation:</h5>
                        <table style="width:100%; margin-top:10px;">
                            <tr style="background:#dbeafe;">
                                <td style="padding:10px; width:20%; font-weight:bold;">g(n) - Distance traveled</td>
                                <td style="padding:10px;">Your odometer reading - how far you've ACTUALLY driven so far</td>
                            </tr>
                            <tr style="background:#fef3c7;">
                                <td style="padding:10px; font-weight:bold;">h(n) - Straight-line distance</td>
                                <td style="padding:10px;">The "as the crow flies" distance to destination (what you see on the map)</td>
                            </tr>
                            <tr style="background:#d1fae5;">
                                <td style="padding:10px; font-weight:bold;">f(n) = g(n) + h(n)</td>
                                <td style="padding:10px;">Your GPS's estimate: "Total trip will be about THIS long if you go this way"</td>
                            </tr>
                        </table>
                    </div>

                    <p style="margin-top:15px; background:#fff; padding:15px; border-radius:8px;">
                        <strong>Why it works:</strong> At every intersection, you ask "Which route has the lowest TOTAL expected cost?" Not just "which way is shorter so far" (that's greedy), and not just "which looks closest to the goal" (that might ignore traffic). A* balances BOTH!
                    </p>
                </div>

                <!-- Chew & Feed for A* -->
                <div class="chew-feed-box">
                    <div class="cf-header">
                        <i class="fas fa-utensils"></i> Understanding A*: The Smart Navigator
                    </div>

                    <div class="simple-terms">
                        <h5>A* in Plain English:</h5>
                        <p><strong>"Always expand the path that looks cheapest in TOTAL (already spent + expected remaining)."</strong></p>

                        <div style="margin-top:15px;">
                            <p><strong>Think of it like choosing which restaurant to visit:</strong></p>
                            <ul style="margin-left:25px; margin-top:10px;">
                                <li><strong>g(n) = Cost to reach:</strong> How much time/money you've already spent getting there</li>
                                <li><strong>h(n) = Expected remaining cost:</strong> How much will the meal and tip cost?</li>
                                <li><strong>f(n) = Total cost:</strong> The FULL experience cost</li>
                            </ul>
                            <p style="margin-top:10px;">You wouldn't just pick the closest restaurant (h alone) or the one you're already near (g alone). You consider the WHOLE cost!</p>
                        </div>
                    </div>

                    <div class="simple-terms" style="margin-top:15px;">
                        <h5>Why A* is "Optimal" (Guaranteed to Find the Best Path)</h5>
                        <p>The secret is the <strong>admissible heuristic</strong>:</p>
                        <div class="term-explain">
                            <span class="term">Admissible</span>
                            <span>"Never overestimate." If h(n) says it's 5km to the goal, the real distance is AT LEAST 5km (or more). We're being optimistic.</span>
                        </div>
                        <p style="margin-top:10px;"><strong>Why does this matter?</strong> If we're always optimistic about unexplored paths, we won't accidentally skip a good path thinking it's worse than it is. We'll explore it and discover the truth!</p>
                    </div>
                </div>

                <!-- Daily Life A* Examples -->
                <div class="daily-life-box">
                    <div class="daily-header">
                        <i class="fas fa-route"></i> A* is Everywhere in Your Life!
                    </div>

                    <div class="daily-example">
                        <h5><i class="fas fa-car"></i> Google Maps / Waze Navigation</h5>
                        <p><strong>g(n):</strong> Time/distance you've already traveled</p>
                        <p><strong>h(n):</strong> Estimated time to destination based on speed limits and traffic patterns</p>
                        <p><strong>f(n):</strong> "Arrive by 3:45 PM" - the total estimated trip time</p>
                        <p><em>Every time you see multiple routes and pick one, your GPS used A*!</em></p>
                    </div>

                    <div class="daily-example">
                        <h5><i class="fas fa-gamepad"></i> Video Game Pathfinding</h5>
                        <p>When characters in games walk around obstacles smoothly, they're using A*!</p>
                        <p><strong>g(n):</strong> Steps the character has taken</p>
                        <p><strong>h(n):</strong> Estimated steps to reach the player</p>
                        <p><em>Games like Age of Empires, StarCraft, and most RPGs use A* for unit movement.</em></p>
                    </div>

                    <div class="daily-example">
                        <h5><i class="fas fa-robot"></i> Robot Vacuum Cleaners</h5>
                        <p>Your Roomba plans paths using A*-like algorithms!</p>
                        <p><strong>g(n):</strong> Distance already traveled (battery used)</p>
                        <p><strong>h(n):</strong> Estimated distance to cover remaining floor</p>
                        <p><em>It balances "clean efficiently" with "get back to charger before dying".</em></p>
                    </div>
                </div>

                <!-- Step-by-step mental model -->
                <div class="think-like-box">
                    <div class="think-header">
                        <i class="fas fa-brain"></i> Mental Model: How to Think About A*
                    </div>
                    <div class="thought-bubble">
                        <p><strong>Imagine you have a magic compass</strong> that points toward the goal and shows the TOTAL expected journey length for each direction you could go.</p>
                        <p style="margin-top:10px;"><strong>At each intersection, you:</strong></p>
                        <ol style="margin-left:25px;">
                            <li>Check ALL possible next steps</li>
                            <li>For each, calculate: "How far have I walked?" + "How far to goal?"</li>
                            <li>Pick the one with the LOWEST total</li>
                            <li>Walk to that point and repeat</li>
                        </ol>
                        <p style="margin-top:10px;"><strong>The guarantee:</strong> If your compass never lies (never overestimates distance), you'll find the shortest path!</p>
                    </div>
                </div>

                <div class="wwwh-grid">
                    <div class="wwwh-item what">
                        <h4><i class="fas fa-question-circle"></i>WHAT is A*?</h4>
                        <p>A* evaluates nodes by f(n) = g(n) + h(n), where g(n) is actual cost from start and h(n) is estimated cost to goal.</p>
                    </div>
                    <div class="wwwh-item why">
                        <h4><i class="fas fa-lightbulb"></i>WHY is A* Optimal?</h4>
                        <p>With admissible heuristic, A* is guaranteed to find the optimal path. It expands nodes in order of total estimated cost.</p>
                    </div>
                    <div class="wwwh-item when">
                        <h4><i class="fas fa-clock"></i>WHEN to Use A*?</h4>
                        <p>When optimal solution is required and a good heuristic is available. Standard for pathfinding in games, robotics, navigation.</p>
                    </div>
                    <div class="wwwh-item how">
                        <h4><i class="fas fa-cogs"></i>HOW A* Works?</h4>
                        <p>Priority queue ordered by f(n). Always expand lowest f(n). Update g(n) if better path found. Stop when goal popped.</p>
                    </div>
                </div>

                <h3><i class="fas fa-calculator"></i>A* Evaluation Components</h3>

                <div class="chart-container">
                    <div class="chart-title"><i class="fas fa-balance-scale"></i> A* Function: f(n) = g(n) + h(n)</div>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-top: 20px;">
                        <div style="background: #dbeafe; padding: 20px; border-radius: 10px; text-align: center;">
                            <div style="font-size: 2em; color: #1e40af;">g(n)</div>
                            <div style="font-weight: bold; margin: 10px 0;">Actual Cost</div>
                            <div>Cost of path from start to node n</div>
                        </div>
                        <div style="background: #fef3c7; padding: 20px; border-radius: 10px; text-align: center;">
                            <div style="font-size: 2em; color: #92400e;">h(n)</div>
                            <div style="font-weight: bold; margin: 10px 0;">Heuristic Cost</div>
                            <div>Estimated cost from n to goal</div>
                        </div>
                        <div style="background: #d1fae5; padding: 20px; border-radius: 10px; text-align: center;">
                            <div style="font-size: 2em; color: #065f46;">f(n)</div>
                            <div style="font-weight: bold; margin: 10px 0;">Total Estimate</div>
                            <div>Estimated total path cost through n</div>
                        </div>
                    </div>
                </div>

                <div class="algorithm-box">
                    <div class="algorithm-title">
                        <i class="fas fa-code"></i>A* Algorithm
                    </div>
                    <ol class="algorithm-steps">
                        <li>Initialize: Open list = {start}, Closed list = {}</li>
                        <li>If Open list is empty, return FAILURE</li>
                        <li>Select node n with lowest f(n) from Open list</li>
                        <li>If n is GOAL, return path (trace back via parents)</li>
                        <li>Move n from Open to Closed list</li>
                        <li>For each successor s of n:
                            <br>&nbsp;&nbsp; If s in Closed list, skip
                            <br>&nbsp;&nbsp; Calculate g(s) = g(n) + cost(n, s)
                            <br>&nbsp;&nbsp; If s not in Open or new g(s) is better, update s
                        </li>
                        <li>Go to step 2</li>
                    </ol>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-lang"><i class="fab fa-python"></i> Python - Complete A* Implementation</span>
                        <button class="copy-button" onclick="copyCode(this)">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <div class="code-block"><span class="keyword">import</span> heapq
<span class="keyword">from</span> typing <span class="keyword">import</span> Dict, List, Tuple, Optional, Callable

<span class="keyword">class</span> <span class="class">AStarSearch</span>:
    <span class="string">"""
    A* Search Algorithm - Complete Implementation

    Guarantees optimal solution with admissible heuristic
    Used in: Game AI, Robotics, GPS Navigation
    """</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self, graph: Dict, heuristic: Dict):
        <span class="string">"""
        Args:
            graph: {node: [(neighbor, cost), ...]}
            heuristic: {node: estimated_cost_to_goal}
        """</span>
        self.graph = graph
        self.h = heuristic

    <span class="keyword">def</span> <span class="function">search</span>(self, start: <span class="function">str</span>, goal: <span class="function">str</span>) -> Tuple[Optional[List], <span class="function">float</span>, <span class="function">int</span>]:
        <span class="string">"""
        Perform A* search from start to goal

        Returns:
            (path, total_cost, nodes_explored)
        """</span>
        <span class="comment"># Priority queue: (f(n), g(n), node, path)</span>
        <span class="comment"># f(n) = g(n) + h(n)</span>
        open_list = [(self.h.get(start, <span class="number">0</span>), <span class="number">0</span>, start, [start])]

        <span class="comment"># Best g(n) found for each node</span>
        g_scores = {start: <span class="number">0</span>}

        <span class="comment"># Closed list - already evaluated nodes</span>
        closed_set = <span class="function">set</span>()

        nodes_explored = <span class="number">0</span>

        <span class="keyword">while</span> open_list:
            <span class="comment"># Get node with lowest f(n)</span>
            f, g, current, path = heapq.heappop(open_list)
            nodes_explored += <span class="number">1</span>

            <span class="comment"># Goal check (when node is EXPANDED, not when generated)</span>
            <span class="keyword">if</span> current == goal:
                <span class="keyword">return</span> path, g, nodes_explored

            <span class="comment"># Skip if already processed with better g</span>
            <span class="keyword">if</span> current <span class="keyword">in</span> closed_set:
                <span class="keyword">continue</span>
            closed_set.add(current)

            <span class="comment"># Explore neighbors</span>
            <span class="keyword">for</span> neighbor, cost <span class="keyword">in</span> self.graph.get(current, []):
                <span class="keyword">if</span> neighbor <span class="keyword">in</span> closed_set:
                    <span class="keyword">continue</span>

                <span class="comment"># Calculate g(neighbor) through current path</span>
                tentative_g = g + cost

                <span class="comment"># If this path is better than any previous</span>
                <span class="keyword">if</span> neighbor <span class="keyword">not in</span> g_scores <span class="keyword">or</span> tentative_g < g_scores[neighbor]:
                    g_scores[neighbor] = tentative_g
                    f_score = tentative_g + self.h.get(neighbor, <span class="number">0</span>)
                    heapq.heappush(open_list, (
                        f_score,
                        tentative_g,
                        neighbor,
                        path + [neighbor]
                    ))

        <span class="keyword">return</span> <span class="keyword">None</span>, <span class="function">float</span>(<span class="string">'inf'</span>), nodes_explored

<span class="comment"># Romania Map Example</span>
romania_graph = {
    <span class="string">'Arad'</span>: [(<span class="string">'Sibiu'</span>, <span class="number">140</span>), (<span class="string">'Timisoara'</span>, <span class="number">118</span>), (<span class="string">'Zerind'</span>, <span class="number">75</span>)],
    <span class="string">'Sibiu'</span>: [(<span class="string">'Arad'</span>, <span class="number">140</span>), (<span class="string">'Fagaras'</span>, <span class="number">99</span>), (<span class="string">'Oradea'</span>, <span class="number">151</span>), (<span class="string">'Rimnicu'</span>, <span class="number">80</span>)],
    <span class="string">'Timisoara'</span>: [(<span class="string">'Arad'</span>, <span class="number">118</span>), (<span class="string">'Lugoj'</span>, <span class="number">111</span>)],
    <span class="string">'Zerind'</span>: [(<span class="string">'Arad'</span>, <span class="number">75</span>), (<span class="string">'Oradea'</span>, <span class="number">71</span>)],
    <span class="string">'Fagaras'</span>: [(<span class="string">'Sibiu'</span>, <span class="number">99</span>), (<span class="string">'Bucharest'</span>, <span class="number">211</span>)],
    <span class="string">'Oradea'</span>: [(<span class="string">'Zerind'</span>, <span class="number">71</span>), (<span class="string">'Sibiu'</span>, <span class="number">151</span>)],
    <span class="string">'Rimnicu'</span>: [(<span class="string">'Sibiu'</span>, <span class="number">80</span>), (<span class="string">'Pitesti'</span>, <span class="number">97</span>), (<span class="string">'Craiova'</span>, <span class="number">146</span>)],
    <span class="string">'Lugoj'</span>: [(<span class="string">'Timisoara'</span>, <span class="number">111</span>), (<span class="string">'Mehadia'</span>, <span class="number">70</span>)],
    <span class="string">'Pitesti'</span>: [(<span class="string">'Rimnicu'</span>, <span class="number">97</span>), (<span class="string">'Bucharest'</span>, <span class="number">101</span>)],
    <span class="string">'Bucharest'</span>: [(<span class="string">'Fagaras'</span>, <span class="number">211</span>), (<span class="string">'Pitesti'</span>, <span class="number">101</span>)]
}

<span class="comment"># Straight-line distances to Bucharest (heuristic)</span>
h_bucharest = {
    <span class="string">'Arad'</span>: <span class="number">366</span>, <span class="string">'Bucharest'</span>: <span class="number">0</span>, <span class="string">'Craiova'</span>: <span class="number">160</span>,
    <span class="string">'Fagaras'</span>: <span class="number">176</span>, <span class="string">'Lugoj'</span>: <span class="number">244</span>, <span class="string">'Mehadia'</span>: <span class="number">241</span>,
    <span class="string">'Oradea'</span>: <span class="number">380</span>, <span class="string">'Pitesti'</span>: <span class="number">100</span>, <span class="string">'Rimnicu'</span>: <span class="number">193</span>,
    <span class="string">'Sibiu'</span>: <span class="number">253</span>, <span class="string">'Timisoara'</span>: <span class="number">329</span>, <span class="string">'Zerind'</span>: <span class="number">374</span>
}

<span class="comment"># Run A* Search</span>
astar = AStarSearch(romania_graph, h_bucharest)
path, cost, explored = astar.search(<span class="string">'Arad'</span>, <span class="string">'Bucharest'</span>)

<span class="function">print</span>(<span class="string">"A* Search Results:"</span>)
<span class="function">print</span>(<span class="string">f"Path: {' -> '.join(path)}"</span>)
<span class="function">print</span>(<span class="string">f"Total Cost: {cost} km"</span>)
<span class="function">print</span>(<span class="string">f"Nodes Explored: {explored}"</span>)

<span class="comment"># </span>
<span class="comment"># EXECUTION TRACE for Arad  Bucharest:</span>
<span class="comment"># </span>
<span class="comment"># Step 1: Start at Arad</span>
<span class="comment">#         Open: [(f=366, g=0, 'Arad', [Arad])]  (h(Arad)=366)</span>
<span class="comment"># Step 2: Expand Arad, add neighbors</span>
<span class="comment">#         Open: [(f=393, g=140, 'Sibiu'), (f=447, g=118, 'Timisoara'), (f=449, g=75, 'Zerind')]</span>
<span class="comment">#         Note: f(Sibiu) = 140 + 253 = 393 (lowest!)</span>
<span class="comment"># Step 3: Expand Sibiu</span>
<span class="comment">#         Open: [(f=415, g=239, 'Fagaras'), (f=413, g=220, 'Rimnicu'), ...]</span>
<span class="comment">#         Note: f(Rimnicu) = 220 + 193 = 413 (lowest!)</span>
<span class="comment"># Step 4: Expand Rimnicu Vilcea</span>
<span class="comment">#         Open: [(f=415, g=239, 'Fagaras'), (f=417, g=317, 'Pitesti'), ...]</span>
<span class="comment">#         Note: f(Pitesti) = 317 + 100 = 417</span>
<span class="comment"># Step 5: Expand Fagaras (f=415 < f=417)</span>
<span class="comment">#         Open: [(f=417, g=317, 'Pitesti'), (f=450, g=450, 'Bucharest via Fagaras')]</span>
<span class="comment"># Step 6: Expand Pitesti</span>
<span class="comment">#         Open: [(f=418, g=418, 'Bucharest via Pitesti'), ...]</span>
<span class="comment">#         Bucharest via Pitesti: f = 418 + 0 = 418 (LOWEST!)</span>
<span class="comment"># Step 7: Expand Bucharest - GOAL FOUND!</span>
<span class="comment">#</span>
<span class="comment"># OUTPUT:</span>
<span class="comment"># A* Search Results:</span>
<span class="comment"># Path: Arad -> Sibiu -> Rimnicu -> Pitesti -> Bucharest</span>
<span class="comment"># Total Cost: 418 km</span>
<span class="comment"># Nodes Explored: 6</span>
<span class="comment"># </span></div>
                </div>

                <!-- A* Complexity Explanation -->
                <div class="walkthrough-box" style="margin: 25px 0;">
                    <h4 style="color: #1e3a5f; margin-bottom: 15px;"><i class="fas fa-clock"></i> A* Complexity - Simple Explanation</h4>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div style="background: #d1fae5; padding: 15px; border-radius: 8px; border-left: 4px solid #10b981;">
                            <h5 style="color: #065f46;">Time Complexity: O(b<sup>d</sup>) - but highly dependent on heuristic!</h5>
                            <p><strong>What affects time?</strong></p>
                            <ul style="margin-left: 20px; font-size: 0.95em;">
                                <li><strong>b</strong> = branching factor (neighbors per node)</li>
                                <li><strong>d</strong> = depth of optimal solution</li>
                                <li><strong>Heuristic quality</strong> = determines how many nodes we explore</li>
                            </ul>
                            <p style="margin-top:10px;"><strong>Heuristic Impact:</strong></p>
                            <ul style="margin-left: 20px; font-size: 0.95em;">
                                <li><strong>Perfect h(n) = h*(n):</strong> Only expands nodes on optimal path  O(d)</li>
                                <li><strong>h(n) = 0:</strong> Becomes Dijkstra's  explores all nodes to depth d  O(b<sup>d</sup>)</li>
                                <li><strong>Good h(n):</strong> Somewhere in between - dramatically reduces exploration</li>
                            </ul>
                            <div style="background: #f0fdf4; padding: 10px; border-radius: 4px; margin-top: 10px;">
                                <strong>Romania example:</strong> BFS explores 17 nodes, A* explores only 6 nodes (65% reduction!)
                            </div>
                        </div>

                        <div style="background: #dbeafe; padding: 15px; border-radius: 8px; border-left: 4px solid #3b82f6;">
                            <h5 style="color: #1e40af;">Space Complexity: O(b<sup>d</sup>) - stores all generated nodes</h5>
                            <p><strong>Why so much memory?</strong></p>
                            <ul style="margin-left: 20px; font-size: 0.95em;">
                                <li>Open list (priority queue) holds unexpanded nodes</li>
                                <li>Closed list holds expanded nodes (for duplicate detection)</li>
                                <li>Must remember paths to reconstruct solution</li>
                                <li>Worst case: stores all nodes at depth  d</li>
                            </ul>
                            <div style="background: #eff6ff; padding: 10px; border-radius: 4px; margin-top: 10px;">
                                <strong>Memory is A*'s main weakness!</strong> For large problems, variants like IDA* (Iterative Deepening A*) trade time for space.
                            </div>
                        </div>
                    </div>

                    <div style="background: #f0fdf4; padding: 15px; border-radius: 8px; margin-top: 15px; border-left: 4px solid #22c55e;">
                        <h5 style="color: #166534;"><i class="fas fa-check-circle"></i> Key Properties of A*</h5>
                        <ul style="margin-left: 20px;">
                            <li><strong>Complete:</strong> Yes (if solution exists and finite)</li>
                            <li><strong>Optimal:</strong> Yes, IF h(n) is admissible (never overestimates)</li>
                            <li><strong>Optimally Efficient:</strong> No algorithm expands fewer nodes (given same heuristic)</li>
                            <li><strong>Used everywhere:</strong> GPS navigation, video games, robotics, network routing</li>
                        </ul>
                    </div>
                </div>

                <h3><i class="fas fa-project-diagram"></i>AO* Algorithm (AND-OR Graphs)</h3>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>AO* Search:</strong> Extension of A* for AND-OR graphs where some problems decompose into subproblems that ALL must be solved (AND nodes) or have multiple solution options (OR nodes).</p>
                </div>

                <div class="simple-explanation">
                    <div class="simple-explanation-title">
                        <i class="fas fa-lightbulb"></i>Understanding AND-OR Graphs
                    </div>
                    <p><strong>OR Nodes:</strong> Choose ONE child path (like regular A*)</p>
                    <p><strong>AND Nodes:</strong> ALL children must be solved for success</p>
                    <p style="margin-top: 10px;"><strong>Example:</strong> To get to airport (OR): drive OR take taxi OR take bus</p>
                    <p>To travel abroad (AND): get passport AND book flight AND pack bags</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-lang"><i class="fab fa-python"></i> Python - AO* Algorithm</span>
                        <button class="copy-button" onclick="copyCode(this)">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <div class="code-block"><span class="keyword">class</span> <span class="class">AOStarSearch</span>:
    <span class="string">"""
    AO* Search for AND-OR Graphs

    Used for: Planning problems, Theorem proving, Game trees
    """</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        <span class="comment"># Node structure: {name: {'type': 'AND'/'OR', 'children': [...], 'h': cost}}</span>
        self.graph = {}
        self.solved = {}  <span class="comment"># Tracks solved nodes</span>
        self.cost = {}    <span class="comment"># Tracks optimal costs</span>

    <span class="keyword">def</span> <span class="function">add_node</span>(self, name, node_type, children, h):
        <span class="string">"""Add a node to the AND-OR graph"""</span>
        self.graph[name] = {
            <span class="string">'type'</span>: node_type,
            <span class="string">'children'</span>: children,
            <span class="string">'h'</span>: h
        }
        self.cost[name] = h

    <span class="keyword">def</span> <span class="function">solve</span>(self, start):
        <span class="string">"""Run AO* algorithm"""</span>
        <span class="keyword">while</span> <span class="keyword">not</span> self.solved.get(start, <span class="keyword">False</span>):
            <span class="comment"># Find most promising unsolved node</span>
            node = self._find_best_node(start)
            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">None</span>:
                <span class="keyword">break</span>

            <span class="comment"># Update costs and check if solved</span>
            self._update_costs(node)

        <span class="keyword">return</span> self.solved.get(start, <span class="keyword">False</span>), self.cost.get(start, <span class="function">float</span>(<span class="string">'inf'</span>))

    <span class="keyword">def</span> <span class="function">_find_best_node</span>(self, node):
        <span class="string">"""Find leaf node with best promise in marked subgraph"""</span>
        <span class="keyword">if</span> node <span class="keyword">not in</span> self.graph:
            <span class="keyword">return</span> <span class="keyword">None</span>

        info = self.graph[node]
        <span class="keyword">if</span> <span class="keyword">not</span> info[<span class="string">'children'</span>]:  <span class="comment"># Leaf node</span>
            <span class="keyword">return</span> node <span class="keyword">if</span> <span class="keyword">not</span> self.solved.get(node) <span class="keyword">else</span> <span class="keyword">None</span>

        <span class="comment"># For OR: pick child with minimum cost</span>
        <span class="comment"># For AND: need all children</span>
        <span class="keyword">if</span> info[<span class="string">'type'</span>] == <span class="string">'OR'</span>:
            best_child = <span class="function">min</span>(info[<span class="string">'children'</span>],
                            key=<span class="keyword">lambda</span> c: self.cost.get(c, <span class="function">float</span>(<span class="string">'inf'</span>)))
            <span class="keyword">return</span> self._find_best_node(best_child)
        <span class="keyword">else</span>:  <span class="comment"># AND node</span>
            <span class="keyword">for</span> child <span class="keyword">in</span> info[<span class="string">'children'</span>]:
                <span class="keyword">if</span> <span class="keyword">not</span> self.solved.get(child, <span class="keyword">False</span>):
                    <span class="keyword">return</span> self._find_best_node(child)
        <span class="keyword">return</span> <span class="keyword">None</span>

    <span class="keyword">def</span> <span class="function">_update_costs</span>(self, node):
        <span class="string">"""Update costs bottom-up"""</span>
        <span class="keyword">if</span> node <span class="keyword">not in</span> self.graph:
            <span class="keyword">return</span>

        info = self.graph[node]

        <span class="keyword">if</span> <span class="keyword">not</span> info[<span class="string">'children'</span>]:  <span class="comment"># Leaf - mark as solved</span>
            self.solved[node] = <span class="keyword">True</span>
            <span class="keyword">return</span>

        <span class="keyword">if</span> info[<span class="string">'type'</span>] == <span class="string">'OR'</span>:
            <span class="comment"># Cost = min of children + edge cost (1)</span>
            min_cost = <span class="function">min</span>(self.cost.get(c, <span class="function">float</span>(<span class="string">'inf'</span>)) <span class="keyword">for</span> c <span class="keyword">in</span> info[<span class="string">'children'</span>])
            self.cost[node] = <span class="number">1</span> + min_cost
            <span class="comment"># Solved if any child is solved</span>
            self.solved[node] = <span class="function">any</span>(self.solved.get(c, <span class="keyword">False</span>) <span class="keyword">for</span> c <span class="keyword">in</span> info[<span class="string">'children'</span>])
        <span class="keyword">else</span>:  <span class="comment"># AND</span>
            <span class="comment"># Cost = sum of children + edge cost</span>
            total_cost = <span class="function">sum</span>(self.cost.get(c, <span class="function">float</span>(<span class="string">'inf'</span>)) <span class="keyword">for</span> c <span class="keyword">in</span> info[<span class="string">'children'</span>])
            self.cost[node] = <span class="number">1</span> + total_cost
            <span class="comment"># Solved only if ALL children are solved</span>
            self.solved[node] = <span class="function">all</span>(self.solved.get(c, <span class="keyword">False</span>) <span class="keyword">for</span> c <span class="keyword">in</span> info[<span class="string">'children'</span>])

<span class="comment"># Example: Planning a trip</span>
ao = AOStarSearch()

<span class="comment"># Goal: Complete Trip (AND - need all)</span>
ao.add_node(<span class="string">'Trip'</span>, <span class="string">'AND'</span>, [<span class="string">'Transport'</span>, <span class="string">'Accommodation'</span>, <span class="string">'Activities'</span>], <span class="number">10</span>)

<span class="comment"># Transport options (OR - pick one)</span>
ao.add_node(<span class="string">'Transport'</span>, <span class="string">'OR'</span>, [<span class="string">'Flight'</span>, <span class="string">'Train'</span>, <span class="string">'Drive'</span>], <span class="number">5</span>)
ao.add_node(<span class="string">'Flight'</span>, <span class="string">'AND'</span>, [], <span class="number">3</span>)  <span class="comment"># Leaf</span>
ao.add_node(<span class="string">'Train'</span>, <span class="string">'AND'</span>, [], <span class="number">4</span>)
ao.add_node(<span class="string">'Drive'</span>, <span class="string">'AND'</span>, [], <span class="number">6</span>)

<span class="comment"># Accommodation (leaf)</span>
ao.add_node(<span class="string">'Accommodation'</span>, <span class="string">'AND'</span>, [], <span class="number">2</span>)

<span class="comment"># Activities (leaf)</span>
ao.add_node(<span class="string">'Activities'</span>, <span class="string">'AND'</span>, [], <span class="number">1</span>)

solved, cost = ao.solve(<span class="string">'Trip'</span>)
<span class="function">print</span>(<span class="string">f"Trip solvable: {solved}, Minimum cost: {cost}"</span>)</div>
                </div>

                <h3><i class="fas fa-chart-bar"></i>A* Performance Comparison</h3>

                <div class="chart-container">
                    <div class="chart-title"><i class="fas fa-chart-bar"></i> Nodes Explored: A* vs Other Algorithms (Romania Map)</div>
                    <canvas id="astarComparisonChart" height="120"></canvas>
                </div>

                <div class="case-study">
                    <div class="case-study-title">
                        <i class="fas fa-gamepad"></i>Industry Case Study: A* in Video Game Pathfinding
                    </div>
                    <p><strong>Company:</strong> Blizzard Entertainment (StarCraft, Warcraft)</p>
                    <p><strong>Challenge:</strong> Move thousands of units efficiently on complex terrain</p>
                    <p><strong>Solution:</strong></p>
                    <ul style="margin: 15px 0 0 25px;">
                        <li><strong>Hierarchical A*:</strong> Search at multiple levels of abstraction</li>
                        <li><strong>Jump Point Search:</strong> Optimized A* for uniform-cost grids</li>
                        <li><strong>Navmesh:</strong> Precomputed navigation meshes</li>
                        <li><strong>Flow Fields:</strong> For large groups of units</li>
                    </ul>
                    <p style="margin-top: 15px;"><strong>Result:</strong> Smooth pathfinding for 200+ units in real-time!</p>

                    <!-- Detailed Breakdown -->
                    <div style="margin-top: 25px; background: #ecfdf5; padding: 20px; border-radius: 12px; border: 2px solid #10b981;">
                        <h4 style="color: #065f46; margin-bottom: 15px;"><i class="fas fa-route"></i> How Game Pathfinding Works - Complete Breakdown</h4>

                        <!-- Visual Grid Diagram -->
                        <div style="background: #1e293b; color: #e2e8f0; padding: 20px; border-radius: 8px; font-family: monospace; font-size: 0.85em; overflow-x: auto;" role="img" aria-label="A* Pathfinding Grid Diagram: Shows a 10x5 game grid with Start at top-left, Goal at bottom-right, and walls blocking direct path. A* explores cells guided by heuristic, finding optimal path around obstacles in 16 expansions.">
                        <p class="sr-only" style="position: absolute; left: -10000px; width: 1px; height: 1px; overflow: hidden;">Diagram description: A 10x5 game grid where S is the unit's start position at top-left, G is the goal at bottom-right. Black squares represent walls. A* uses Manhattan distance heuristic to guide search toward the goal, exploring only 16 nodes to find the optimal 13-step path that navigates around the wall obstacles. Numbers in cells show the order of exploration.</p>
<pre style="margin: 0;">

                    A* PATHFINDING ON GAME GRID                               

                                                                              
   GAME MAP (10x8 Grid):                                                      
                                    
    S  .  .  .      .  .  .  .   S = Start (Unit position)      
     G = Goal (Click destination)   
    .  .          .  .  .  .    = Obstacle (wall/building)   
     . = Walkable terrain           
    .  .  .  .  .    .  .    .   * = Optimal path               
                                    
    .  .  .  .  .  .  .  .    .                                  
                                    
    .  .  .  .  .  .  .  .    G                                  
                                    
                                                                              
   A* EXPLORATION (colored by f(n) = g(n) + h(n)):                           
                                    
    S  1  2  3                                                  
     Numbers = order explored       
    4  5                       A* focuses toward goal!        
                                    
       6  7  8  9   10 11        Notice: Doesn't explore        
     areas away from goal!          
                  12 13 14                                       
                                    
                        15    G   Found in 16 expansions!        
                                    
                                                                              
   FINAL PATH (length = 13):                                                  
   S                G                                         
                                                                              
      
   HEURISTIC: Manhattan Distance = |x1-x2| + |y1-y2|                          
              From S(0,0) to G(9,4): h = |9-0| + |4-0| = 13                   
      

</pre>
                        </div>

                        <!-- Working Code Example -->
                        <h5 style="color: #065f46; margin: 20px 0 10px 0;"><i class="fas fa-code"></i> Game Pathfinding Implementation</h5>
                        <div class="code-container" style="margin: 0;">
                            <div class="code-header">
                                <span class="code-lang"><i class="fab fa-python"></i> Python - Game Grid Pathfinding with A*</span>
                                <button class="copy-button" onclick="copyCode(this)">
                                    <i class="fas fa-copy"></i> Copy
                                </button>
                            </div>
                            <div class="code-block"><span class="keyword">import</span> heapq

<span class="keyword">class</span> <span class="class">GamePathfinder</span>:
    <span class="string">"""
    A* Pathfinding for 2D Game Grid
    Used in: StarCraft, Age of Empires, Civilization, etc.
    """</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self, grid):
        <span class="string">"""
        grid: 2D list where 0=walkable, 1=obstacle
        Example: [[0,0,1,0], [0,1,0,0], [0,0,0,0]]
        """</span>
        self.grid = grid
        self.rows = <span class="function">len</span>(grid)
        self.cols = <span class="function">len</span>(grid[<span class="number">0</span>])

        <span class="comment"># 8 directions: up, down, left, right + 4 diagonals</span>
        self.directions = [
            (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>),  <span class="comment"># Cardinal</span>
            (-<span class="number">1</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">1</span>)   <span class="comment"># Diagonal</span>
        ]

    <span class="keyword">def</span> <span class="function">heuristic</span>(self, a, b):
        <span class="string">"""Manhattan distance - admissible for 4-direction movement"""</span>
        <span class="keyword">return</span> <span class="function">abs</span>(a[<span class="number">0</span>] - b[<span class="number">0</span>]) + <span class="function">abs</span>(a[<span class="number">1</span>] - b[<span class="number">1</span>])

    <span class="keyword">def</span> <span class="function">find_path</span>(self, start, goal):
        <span class="string">"""
        Find shortest path from start to goal using A*

        Args:
            start: (row, col) tuple - unit's current position
            goal: (row, col) tuple - clicked destination

        Returns:
            List of (row, col) tuples forming the path
        """</span>
        <span class="comment"># Priority queue: (f_score, g_score, position, path)</span>
        open_list = [(self.heuristic(start, goal), <span class="number">0</span>, start, [start])]
        visited = <span class="function">set</span>()
        g_scores = {start: <span class="number">0</span>}

        nodes_explored = <span class="number">0</span>

        <span class="keyword">while</span> open_list:
            f, g, current, path = heapq.heappop(open_list)
            nodes_explored += <span class="number">1</span>

            <span class="comment"># Goal reached!</span>
            <span class="keyword">if</span> current == goal:
                <span class="function">print</span>(<span class="string">f"Path found! Length: {len(path)}, Nodes explored: {nodes_explored}"</span>)
                <span class="keyword">return</span> path

            <span class="keyword">if</span> current <span class="keyword">in</span> visited:
                <span class="keyword">continue</span>
            visited.add(current)

            <span class="comment"># Explore neighbors (8 directions)</span>
            <span class="keyword">for</span> dr, dc <span class="keyword">in</span> self.directions:
                nr, nc = current[<span class="number">0</span>] + dr, current[<span class="number">1</span>] + dc

                <span class="comment"># Check bounds and obstacles</span>
                <span class="keyword">if</span> <span class="number">0</span> <= nr < self.rows <span class="keyword">and</span> <span class="number">0</span> <= nc < self.cols:
                    <span class="keyword">if</span> self.grid[nr][nc] == <span class="number">0</span> <span class="keyword">and</span> (nr, nc) <span class="keyword">not in</span> visited:
                        <span class="comment"># Diagonal movement costs more (2  1.41)</span>
                        move_cost = <span class="number">1.41</span> <span class="keyword">if</span> dr != <span class="number">0</span> <span class="keyword">and</span> dc != <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span>
                        new_g = g + move_cost

                        <span class="keyword">if</span> (nr, nc) <span class="keyword">not in</span> g_scores <span class="keyword">or</span> new_g < g_scores[(nr, nc)]:
                            g_scores[(nr, nc)] = new_g
                            new_f = new_g + self.heuristic((nr, nc), goal)
                            heapq.heappush(open_list, (new_f, new_g, (nr, nc), path + [(nr, nc)]))

        <span class="function">print</span>(<span class="string">"No path found!"</span>)
        <span class="keyword">return</span> []

    <span class="keyword">def</span> <span class="function">visualize</span>(self, path):
        <span class="string">"""Display the grid with path marked"""</span>
        path_set = <span class="function">set</span>(path)
        <span class="function">print</span>(<span class="string">"\nGame Map with Path:"</span>)
        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="function">range</span>(self.rows):
            row_str = <span class="string">""</span>
            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="function">range</span>(self.cols):
                <span class="keyword">if</span> (r, c) == path[<span class="number">0</span>]:
                    row_str += <span class="string">" S "</span>  <span class="comment"># Start</span>
                <span class="keyword">elif</span> (r, c) == path[-<span class="number">1</span>]:
                    row_str += <span class="string">" G "</span>  <span class="comment"># Goal</span>
                <span class="keyword">elif</span> (r, c) <span class="keyword">in</span> path_set:
                    row_str += <span class="string">" * "</span>  <span class="comment"># Path</span>
                <span class="keyword">elif</span> self.grid[r][c] == <span class="number">1</span>:
                    row_str += <span class="string">"  "</span>  <span class="comment"># Wall</span>
                <span class="keyword">else</span>:
                    row_str += <span class="string">"  "</span>  <span class="comment"># Empty</span>
            <span class="function">print</span>(row_str)

<span class="comment"># </span>
<span class="comment"># DEMO: StarCraft-style game map</span>
<span class="comment"># </span>
game_map = [
    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],
    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],
    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],
    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],
    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]
]

pathfinder = GamePathfinder(game_map)

<span class="comment"># Unit at (0,0), player clicks on (4,9)</span>
start = (<span class="number">0</span>, <span class="number">0</span>)
goal = (<span class="number">4</span>, <span class="number">9</span>)

<span class="function">print</span>(<span class="string">f"Finding path from {start} to {goal}..."</span>)
path = pathfinder.find_path(start, goal)
pathfinder.visualize(path)

<span class="comment"># OUTPUT:
# Finding path from (0, 0) to (4, 9)...
# Path found! Length: 13, Nodes explored: 23
#
# Game Map with Path:
#  S  *  *  *            
#                    
#    *  *  *  *    *  *    
#            *    *    
#                *    G</span></div>
                        </div>

                        <!-- Game-Specific Optimizations -->
                        <h5 style="color: #065f46; margin: 20px 0 10px 0;"><i class="fas fa-rocket"></i> Real-World Game Optimizations</h5>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                            <div style="background: white; padding: 15px; border-radius: 8px; border-left: 4px solid #10b981;">
                                <strong style="color: #065f46;">Hierarchical A* (HPA*)</strong>
                                <p style="font-size: 0.9em; margin-top: 5px;">Split map into clusters. First find path between clusters, then refine within each. 10x faster for large maps!</p>
                            </div>
                            <div style="background: white; padding: 15px; border-radius: 8px; border-left: 4px solid #3b82f6;">
                                <strong style="color: #1e40af;">Jump Point Search</strong>
                                <p style="font-size: 0.9em; margin-top: 5px;">Skip symmetric paths on uniform grids. Only consider "jump points" where direction changes. 10-30x faster!</p>
                            </div>
                            <div style="background: white; padding: 15px; border-radius: 8px; border-left: 4px solid #f59e0b;">
                                <strong style="color: #92400e;">Flow Fields</strong>
                                <p style="font-size: 0.9em; margin-top: 5px;">Precompute direction to goal for each cell. All units share one calculation. Perfect for 100+ units moving to same target!</p>
                            </div>
                            <div style="background: white; padding: 15px; border-radius: 8px; border-left: 4px solid #ef4444;">
                                <strong style="color: #991b1b;">Path Caching</strong>
                                <p style="font-size: 0.9em; margin-top: 5px;">Store frequently-used paths. If unit moves from base to enemy base often, reuse the path instead of recalculating!</p>
                            </div>
                        </div>

                        <div style="background: #d1fae5; padding: 15px; border-radius: 8px; margin-top: 15px;">
                            <strong><i class="fas fa-lightbulb"></i> Fun Fact:</strong> StarCraft 2 processes ~1000 pathfinding requests per second during intense battles. Without A* optimizations, the game would run at 2 FPS instead of 60!
                        </div>

                        <!-- Practice Exercise for A* Pathfinding -->
                        <div style="background: #fef3c7; padding: 20px; border-radius: 12px; margin-top: 20px; border: 2px dashed #f59e0b;">
                            <h5 style="color: #92400e; margin-bottom: 15px;"><i class="fas fa-pencil-alt"></i> Practice Exercise: A* Game Pathfinding</h5>

                            <p style="margin-bottom: 15px;"><strong>Exercise 1:</strong> Trace A* on this small grid. Find path from S to G. Show f(n), g(n), h(n) for each expanded node.</p>
                            <pre style="background: #1e293b; color: #e2e8f0; padding: 15px; border-radius: 8px; font-family: monospace;">
    S  
      
      G

    S = (0,0), G = (2,2)
    Use Manhattan distance as heuristic
                            </pre>

                            <details style="margin-top: 15px;">
                                <summary style="cursor: pointer; color: #92400e; font-weight: bold;"><i class="fas fa-eye"></i> Show A* Trace</summary>
                                <div style="margin-top: 10px; padding: 15px; background: white; border-radius: 8px;">
                                    <table style="width:100%; font-size: 0.9em; border-collapse: collapse;">
                                        <tr style="background:#fef3c7;"><th style="padding:8px; border:1px solid #ccc;">Step</th><th style="padding:8px; border:1px solid #ccc;">Node</th><th style="padding:8px; border:1px solid #ccc;">g(n)</th><th style="padding:8px; border:1px solid #ccc;">h(n)</th><th style="padding:8px; border:1px solid #ccc;">f(n)</th></tr>
                                        <tr><td style="padding:8px; border:1px solid #ccc;">1</td><td style="padding:8px; border:1px solid #ccc;">S (0,0)</td><td style="padding:8px; border:1px solid #ccc;">0</td><td style="padding:8px; border:1px solid #ccc;">4</td><td style="padding:8px; border:1px solid #ccc;">4</td></tr>
                                        <tr><td style="padding:8px; border:1px solid #ccc;">2</td><td style="padding:8px; border:1px solid #ccc;">(0,1)</td><td style="padding:8px; border:1px solid #ccc;">1</td><td style="padding:8px; border:1px solid #ccc;">3</td><td style="padding:8px; border:1px solid #ccc;">4</td></tr>
                                        <tr><td style="padding:8px; border:1px solid #ccc;">3</td><td style="padding:8px; border:1px solid #ccc;">(0,2)</td><td style="padding:8px; border:1px solid #ccc;">2</td><td style="padding:8px; border:1px solid #ccc;">2</td><td style="padding:8px; border:1px solid #ccc;">4</td></tr>
                                        <tr><td style="padding:8px; border:1px solid #ccc;">4</td><td style="padding:8px; border:1px solid #ccc;">(1,2)</td><td style="padding:8px; border:1px solid #ccc;">3</td><td style="padding:8px; border:1px solid #ccc;">1</td><td style="padding:8px; border:1px solid #ccc;">4</td></tr>
                                        <tr style="background:#d1fae5;"><td style="padding:8px; border:1px solid #ccc;">5</td><td style="padding:8px; border:1px solid #ccc;">G (2,2)</td><td style="padding:8px; border:1px solid #ccc;">4</td><td style="padding:8px; border:1px solid #ccc;">0</td><td style="padding:8px; border:1px solid #ccc;">4</td></tr>
                                    </table>
                                    <p style="margin-top:10px;"><strong>Path:</strong> S  (0,1)  (0,2)  (1,2)  G</p>
                                    <p><strong>Notice:</strong> f(n) stays constant at 4 because h is admissible!</p>
                                </div>
                            </details>

                            <p style="margin-top: 20px;"><strong>Exercise 2:</strong> Modify the GamePathfinder class to use Euclidean distance instead of Manhattan. What happens to the path found? Is the heuristic still admissible?</p>

                            <details style="margin-top: 15px;">
                                <summary style="cursor: pointer; color: #92400e; font-weight: bold;"><i class="fas fa-eye"></i> Show Solution</summary>
                                <div style="margin-top: 10px; padding: 15px; background: white; border-radius: 8px;">
                                    <pre style="background: #1e293b; color: #e2e8f0; padding: 10px; border-radius: 4px; font-size: 0.85em;">
import math

def euclidean_heuristic(self, a, b):
    """Euclidean distance - admissible for diagonal movement"""
    return math.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)
                                    </pre>
                                    <p style="margin-top:10px;"><strong>Admissibility:</strong></p>
                                    <ul style="margin-left: 20px;">
                                        <li>For 4-direction (cardinal only): Euclidean underestimates  still admissible</li>
                                        <li>For 8-direction (with diagonals): Euclidean is EXACT  admissible</li>
                                    </ul>
                                    <p style="margin-top:10px;"><strong>Path:</strong> Same optimal path, but fewer nodes explored since Euclidean is more informative than Manhattan for diagonal movement.</p>
                                </div>
                            </details>

                            <p style="margin-top: 20px;"><strong>Exercise 3 (Challenge):</strong> How would you handle moving obstacles (like enemy units) in a real-time game? What modifications to A* are needed?</p>

                            <details style="margin-top: 15px;">
                                <summary style="cursor: pointer; color: #92400e; font-weight: bold;"><i class="fas fa-eye"></i> Show Answer</summary>
                                <div style="margin-top: 10px; padding: 15px; background: white; border-radius: 8px;">
                                    <p><strong>Options for dynamic obstacles:</strong></p>
                                    <ol style="margin-left: 20px; margin-top: 10px;">
                                        <li><strong>Replan on collision:</strong> Detect when path becomes blocked, recalculate from current position</li>
                                        <li><strong>D* Lite (Dynamic A*):</strong> Incrementally repair paths when obstacles move - faster than full replan</li>
                                        <li><strong>Time-expanded A*:</strong> Include time dimension - avoid cells at specific times when enemies will be there</li>
                                        <li><strong>Local avoidance:</strong> Use A* for global path, add steering behaviors for local obstacle avoidance</li>
                                    </ol>
                                    <p style="margin-top:10px;"><em>Most games use option 4: A* + local avoidance (like ORCA algorithm) for smooth, responsive movement!</em></p>
                                </div>
                            </details>
                        </div>
                    </div>
                </div>

                <div class="qa-box">
                    <h4><i class="fas fa-question-circle"></i>CO1 Comprehensive Questions - A* Search Algorithm</h4>

                    <!-- 3-MARK QUESTIONS -->
                    <div style="background: #d1fae5; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h5 style="color: #065f46; margin-bottom: 15px;"><i class="fas fa-star"></i> 3-Mark Questions (Short Answer)</h5>

                        <div class="question">
                            <strong>Q1 (3 marks):</strong> Define A* search and explain the meaning of f(n) = g(n) + h(n).
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>Model Answer:</h5>
                                <p><strong>A* Definition (1 mark):</strong> A* is an informed search algorithm that finds the optimal path by combining actual cost with estimated cost. It uses a priority queue ordered by f(n).</p>
                                <p style="margin-top:10px;"><strong>Components (2 marks):</strong></p>
                                <ul style="margin-left:25px;">
                                    <li><strong>g(n)</strong> = Actual cost from start to node n (known, computed)</li>
                                    <li><strong>h(n)</strong> = Heuristic estimate from n to goal (estimated)</li>
                                    <li><strong>f(n)</strong> = Total estimated cost of path through n = g(n) + h(n)</li>
                                </ul>
                                <div class="insight">A* always expands the node with lowest f(n), balancing "how far we've come" with "how far we think we need to go."</div>
                            </div>
                        </div>

                        <div class="question">
                            <strong>Q2 (3 marks):</strong> What is an admissible heuristic? Give an example for the 8-puzzle problem.
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>Model Answer:</h5>
                                <p><strong>Admissible Heuristic (1 mark):</strong> A heuristic h(n) is admissible if it NEVER overestimates the actual cost to reach the goal. Formally: h(n)  h*(n) for all n, where h*(n) is the true cost.</p>
                                <p style="margin-top:10px;"><strong>8-Puzzle Examples (2 marks):</strong></p>
                                <ol style="margin-left:25px;">
                                    <li><strong>Misplaced Tiles:</strong> Count of tiles not in goal position. Admissible because each misplaced tile needs at least 1 move.</li>
                                    <li><strong>Manhattan Distance:</strong> Sum of horizontal + vertical distances of each tile from goal position. Admissible because tiles can only move one step at a time.</li>
                                </ol>
                                <p style="background:#fef3c7; padding:10px; border-radius:4px; margin-top:10px;">Manhattan distance is more informative (higher values)  fewer nodes explored!</p>
                            </div>
                        </div>

                        <div class="question">
                            <strong>Q3 (3 marks):</strong> Compare A* with Greedy Best-First Search. When does each perform better?
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>Model Answer:</h5>
                                <table style="width:100%; margin:10px 0; font-size:0.9em;">
                                    <tr style="background:#d1fae5;"><th>Property</th><th>A*</th><th>Greedy Best-First</th></tr>
                                    <tr><td>Evaluation</td><td>f(n) = g(n) + h(n)</td><td>f(n) = h(n) only</td></tr>
                                    <tr><td>Optimal?</td><td>Yes (with admissible h)</td><td>No</td></tr>
                                    <tr><td>Complete?</td><td>Yes</td><td>No (can get stuck)</td></tr>
                                    <tr><td>Speed</td><td>Slower (considers actual cost)</td><td>Faster (ignores path cost)</td></tr>
                                </table>
                                <p><strong>Use A*:</strong> When optimal solution required (navigation, robotics)</p>
                                <p><strong>Use Greedy:</strong> When any solution is acceptable and speed matters</p>
                            </div>
                        </div>

                        <div class="question">
                            <strong>Q4 (3 marks):</strong> What is the time and space complexity of A*? Explain why.
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>Model Answer:</h5>
                                <p><strong>Time Complexity: O(b<sup>d</sup>) (1 mark)</strong></p>
                                <ul style="margin-left:25px;">
                                    <li>In worst case, explores all nodes up to depth d</li>
                                    <li>Better with good heuristic - can be O(d) if h(n) is perfect!</li>
                                </ul>
                                <p style="margin-top:10px;"><strong>Space Complexity: O(b<sup>d</sup>) (1 mark)</strong></p>
                                <ul style="margin-left:25px;">
                                    <li>Must store all expanded nodes (for duplicate detection)</li>
                                    <li>Priority queue can hold up to b<sup>d</sup> nodes</li>
                                </ul>
                                <p style="margin-top:10px;"><strong>Why exponential? (1 mark):</strong> A* expands nodes in order of f(n), which means it might need to examine many nodes before finding the optimal path, especially if heuristic is weak.</p>
                            </div>
                        </div>
                    </div>

                    <!-- 8-MARK QUESTIONS -->
                    <div style="background: #fef3c7; padding: 15px; border-radius: 8px;">
                        <h5 style="color: #92400e; margin-bottom: 15px;"><i class="fas fa-star"></i><i class="fas fa-star"></i> 8-Mark Questions (Long Answer)</h5>

                        <div class="question">
                            <strong>Q5 (8 marks):</strong> Apply A* to find the path from Arad to Bucharest. Show complete trace with g(n), h(n), f(n) at each step.
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>Given Information (2 marks):</h5>
                                <pre style="background:#f0fdf4; padding:10px; border-radius:6px; font-size:0.85em;">
Road Distances:                    Straight-Line Distances to Bucharest (h(n)):
Arad-Sibiu: 140km                  Arad: 366, Sibiu: 253, Fagaras: 176
Arad-Timisoara: 118km              Rimnicu: 193, Pitesti: 100, Bucharest: 0
Sibiu-Fagaras: 99km                Timisoara: 329, Zerind: 374
Sibiu-Rimnicu: 80km
Rimnicu-Pitesti: 97km
Pitesti-Bucharest: 101km
Fagaras-Bucharest: 211km
                                </pre>
                            </div>

                            <div class="solution-step" style="margin-top: 15px;">
                                <h5>A* Execution Trace (6 marks):</h5>
                                <table style="width:100%; margin: 10px 0; font-size: 0.85em;">
                                    <tr style="background:#d1fae5;"><th>Step</th><th>Expand</th><th>g(n)</th><th>h(n)</th><th>f(n)</th><th>Priority Queue (sorted by f)</th></tr>
                                    <tr><td>0</td><td>-</td><td>-</td><td>-</td><td>-</td><td>Arad(f=366)</td></tr>
                                    <tr><td>1</td><td>Arad</td><td>0</td><td>366</td><td>366</td><td>Sibiu(393), Timisoara(447), Zerind(449)</td></tr>
                                    <tr><td>2</td><td>Sibiu</td><td>140</td><td>253</td><td>393</td><td>Rimnicu(413), Fagaras(415), Tim(447), Zer(449)</td></tr>
                                    <tr><td>3</td><td>Rimnicu</td><td>220</td><td>193</td><td>413</td><td>Fagaras(415), Pitesti(417), Tim(447), ...</td></tr>
                                    <tr><td>4</td><td>Fagaras</td><td>239</td><td>176</td><td>415</td><td>Pitesti(417), Bucharest(450), ...</td></tr>
                                    <tr><td>5</td><td>Pitesti</td><td>317</td><td>100</td><td>417</td><td>Bucharest(418), Bucharest(450), ...</td></tr>
                                    <tr style="background:#bbf7d0;"><td>6</td><td>Bucharest</td><td>418</td><td>0</td><td>418</td><td><strong>GOAL REACHED!</strong></td></tr>
                                </table>
                                <p style="margin-top:10px;"><strong>Calculations shown:</strong></p>
                                <ul style="margin-left:25px; font-size:0.9em;">
                                    <li>Sibiu: g=140, h=253, f=140+253=393</li>
                                    <li>Rimnicu via Sibiu: g=140+80=220, h=193, f=413</li>
                                    <li>Pitesti via Rimnicu: g=220+97=317, h=100, f=417</li>
                                    <li>Bucharest via Pitesti: g=317+101=418, h=0, f=418</li>
                                </ul>
                                <p style="background:#d1fae5; padding:10px; border-radius:4px; margin-top:10px;">
                                    <strong>Optimal Path:</strong> Arad  Sibiu  Rimnicu  Pitesti  Bucharest<br>
                                    <strong>Total Distance:</strong> 418 km<br>
                                    <strong>Nodes Explored:</strong> 6 (A* is efficient!)
                                </p>
                            </div>
                        </div>

                        <div class="question" style="margin-top: 20px;">
                            <strong>Q6 (8 marks):</strong> Prove that A* is optimal when h(n) is admissible. Use a formal proof structure.
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>Formal Optimality Proof:</h5>

                                <div style="background:#f0fdf4; padding:15px; border-radius:8px; margin:10px 0;">
                                    <p><strong>Theorem:</strong> A* with an admissible heuristic is optimal (finds least-cost solution).</p>
                                </div>

                                <p><strong>Given (1 mark):</strong></p>
                                <ul style="margin-left:25px;">
                                    <li>h(n) is admissible: h(n)  h*(n) for all nodes n</li>
                                    <li>h*(n) = true cost from n to nearest goal</li>
                                </ul>

                                <p style="margin-top:15px;"><strong>Proof by Contradiction (5 marks):</strong></p>
                                <div style="background:white; padding:15px; border-radius:8px; border-left:4px solid #22c55e;">
                                    <p><strong>Assume:</strong> A* returns a suboptimal goal G with cost C when optimal goal G* with cost C* exists, where C > C*.</p>

                                    <p style="margin-top:10px;"><strong>Step 1:</strong> Let n be any unexpanded node on the optimal path to G*.</p>

                                    <p style="margin-top:10px;"><strong>Step 2:</strong> For node n on optimal path:</p>
                                    <div class="calculation">
                                        f(n) = g(n) + h(n)<br>
                                        f(n)  g(n) + h*(n)  [since h is admissible: h(n)  h*(n)]<br>
                                        f(n)  C*  [since g(n) + h*(n) = cost of optimal path through n]
                                    </div>

                                    <p style="margin-top:10px;"><strong>Step 3:</strong> For suboptimal goal G:</p>
                                    <div class="calculation">
                                        f(G) = g(G) + h(G)<br>
                                        f(G) = C + 0  [h(goal) = 0]<br>
                                        f(G) = C
                                    </div>

                                    <p style="margin-top:10px;"><strong>Step 4:</strong> Compare:</p>
                                    <div class="calculation">
                                        f(n)  C* < C = f(G)<br>
                                        Therefore: f(n) < f(G)
                                    </div>

                                    <p style="margin-top:10px;"><strong>Step 5:</strong> Contradiction! A* always expands node with minimum f(n). Since f(n) < f(G), A* would expand n before G. This means A* would find the optimal path before returning G.</p>
                                </div>

                                <p style="margin-top:15px;"><strong>Conclusion (2 marks):</strong></p>
                                <div style="background:#d1fae5; padding:10px; border-radius:4px;">
                                    A* cannot return a suboptimal solution when h(n) is admissible. Therefore, A* is optimal. 
                                </div>
                            </div>
                        </div>

                        <div class="question" style="margin-top: 20px;">
                            <strong>Q7 (8 marks):</strong> For the 8-puzzle, compare two heuristics: (a) Number of misplaced tiles, (b) Manhattan distance. Show calculations for a given state and explain which is better.
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>Given State (2 marks):</h5>
                                <pre style="background:#f0fdf4; padding:15px; border-radius:6px;">
Current State:        Goal State:
        
 2  8  3          1  2  3 
        
 1  6  4          4  5  6 
        
 7  _  5          7  8  _ 
        
                                </pre>
                            </div>

                            <div class="solution-step" style="margin-top: 15px;">
                                <h5>h: Misplaced Tiles (2 marks):</h5>
                                <table style="width:100%; margin:10px 0; font-size:0.9em;">
                                    <tr><th>Tile</th><th>Current Pos</th><th>Goal Pos</th><th>Misplaced?</th></tr>
                                    <tr><td>1</td><td>(1,0)</td><td>(0,0)</td><td>Yes</td></tr>
                                    <tr><td>2</td><td>(0,0)</td><td>(0,1)</td><td>Yes</td></tr>
                                    <tr><td>3</td><td>(0,2)</td><td>(0,2)</td><td>No</td></tr>
                                    <tr><td>4</td><td>(1,2)</td><td>(1,0)</td><td>Yes</td></tr>
                                    <tr><td>5</td><td>(2,2)</td><td>(1,1)</td><td>Yes</td></tr>
                                    <tr><td>6</td><td>(1,1)</td><td>(1,2)</td><td>Yes</td></tr>
                                    <tr><td>7</td><td>(2,0)</td><td>(2,0)</td><td>No</td></tr>
                                    <tr><td>8</td><td>(0,1)</td><td>(2,1)</td><td>Yes</td></tr>
                                </table>
                                <p><strong>h = 6</strong> (tiles 1, 2, 4, 5, 6, 8 are misplaced)</p>
                            </div>

                            <div class="solution-step" style="margin-top: 15px;">
                                <h5>h: Manhattan Distance (2 marks):</h5>
                                <table style="width:100%; margin:10px 0; font-size:0.9em;">
                                    <tr><th>Tile</th><th>Current</th><th>Goal</th><th>|row| + |col|</th></tr>
                                    <tr><td>1</td><td>(1,0)</td><td>(0,0)</td><td>|1-0| + |0-0| = 1</td></tr>
                                    <tr><td>2</td><td>(0,0)</td><td>(0,1)</td><td>|0-0| + |0-1| = 1</td></tr>
                                    <tr><td>4</td><td>(1,2)</td><td>(1,0)</td><td>|1-1| + |2-0| = 2</td></tr>
                                    <tr><td>5</td><td>(2,2)</td><td>(1,1)</td><td>|2-1| + |2-1| = 2</td></tr>
                                    <tr><td>6</td><td>(1,1)</td><td>(1,2)</td><td>|1-1| + |1-2| = 1</td></tr>
                                    <tr><td>8</td><td>(0,1)</td><td>(2,1)</td><td>|0-2| + |1-1| = 2</td></tr>
                                </table>
                                <p><strong>h = 1+1+2+2+1+2 = 9</strong></p>
                            </div>

                            <div class="solution-step" style="margin-top: 15px;">
                                <h5>Comparison and Analysis (2 marks):</h5>
                                <table style="width:100%; margin:10px 0;">
                                    <tr style="background:#fef3c7;"><th>Property</th><th>h (Misplaced)</th><th>h (Manhattan)</th></tr>
                                    <tr><td>Value for this state</td><td>6</td><td>9</td></tr>
                                    <tr><td>Admissible?</td><td>Yes</td><td>Yes</td></tr>
                                    <tr><td>Dominance</td><td>Less informed</td><td>More informed</td></tr>
                                </table>
                                <p style="margin-top:10px;"><strong>Why h is better:</strong></p>
                                <ul style="margin-left:25px;">
                                    <li>h  h always (9  6 in this case)</li>
                                    <li>h is more "informative" - closer to true cost</li>
                                    <li>A* expands fewer nodes with h (nodes with f(n) < f* are skipped)</li>
                                    <li>h dominates h: for any state, h(n)  h(n)</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ==================== SECTION 6: GAME TREES ==================== -->
            <section id="game">
                <h2><i class="fas fa-gamepad"></i>6. Game Trees, Mini-Max & Alpha-Beta Pruning</h2>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>Game Tree:</strong> A tree representing all possible game states and moves. Each node is a game state, each edge is a move. Used in adversarial search where two players compete.</p>
                </div>

                <!-- Game Trees Real-World Analogy -->
                <div class="analogy-box">
                    <div class="analogy-header">
                        <i class="fas fa-chess"></i> Real-World Analogy: Playing Chess Against a Grandmaster
                    </div>
                    <p>Imagine you're playing chess against a grandmaster. Before making your move, you think:</p>

                    <div class="analogy-scenario">
                        <h5>How Your Mind Creates a "Game Tree":</h5>
                        <p><strong>Your thought process:</strong></p>
                        <ol style="margin-left:25px;">
                            <li>"If I move my knight here..."</li>
                            <li>"...my opponent will probably take my pawn (his best response)"</li>
                            <li>"Then I could move my bishop..."</li>
                            <li>"...but then he might castle (his best response to that)"</li>
                            <li>"...and then I could..."</li>
                        </ol>
                        <p style="margin-top:10px;">You're naturally building a mental tree of possibilities, going several moves ahead!</p>
                    </div>

                    <p style="margin-top:15px; background:#fff; padding:15px; border-radius:8px;">
                        <strong>The Key Insight:</strong> You assume your opponent will always make their BEST move (not a random or silly move). You're being pessimistic about them, thinking "What's the WORST (for me) that they could do?" This is exactly the MIN part of Mini-Max!
                    </p>
                </div>

                <!-- Chew & Feed for Mini-Max -->
                <div class="chew-feed-box">
                    <div class="cf-header">
                        <i class="fas fa-utensils"></i> Understanding Mini-Max: The Pessimistic Optimist
                    </div>

                    <div class="simple-terms">
                        <h5>Mini-Max in Plain English:</h5>
                        <p><strong>"I'll assume my opponent is as smart as possible, and I'll make the best move assuming that."</strong></p>

                        <div style="margin-top:15px;">
                            <p><strong>Think of it like negotiating a salary:</strong></p>
                            <ul style="margin-left:25px; margin-top:10px;">
                                <li><strong>YOU (MAX):</strong> Want the HIGHEST salary possible</li>
                                <li><strong>EMPLOYER (MIN):</strong> Wants to pay the LOWEST salary possible</li>
                                <li><strong>Your strategy:</strong> "What's the best I can realistically get, assuming they won't just give me whatever I ask for?"</li>
                                <li><strong>Their strategy:</strong> "What's the minimum we can pay while still hiring this person?"</li>
                            </ul>
                            <p style="margin-top:10px;">The negotiated salary is the Mini-Max value - the best outcome when both sides play optimally!</p>
                        </div>
                    </div>

                    <div class="simple-terms" style="margin-top:15px;">
                        <h5>Why "Mini" and "Max"?</h5>
                        <div class="term-explain">
                            <span class="term">MAX Player</span>
                            <span>That's YOU! You want to MAXIMIZE your score/outcome. You always pick the option with the HIGHEST value.</span>
                        </div>
                        <div class="term-explain">
                            <span class="term">MIN Player</span>
                            <span>Your OPPONENT! They want to MINIMIZE your score. They always pick the option with the LOWEST value (for you).</span>
                        </div>
                        <div class="term-explain">
                            <span class="term">The Algorithm</span>
                            <span>Simulates BOTH players playing perfectly, alternating between maximizing and minimizing at each level of the game tree.</span>
                        </div>
                    </div>
                </div>

                <!-- Daily Life Mini-Max Examples -->
                <div class="daily-life-box">
                    <div class="daily-header">
                        <i class="fas fa-users"></i> Mini-Max Thinking in Everyday Life
                    </div>

                    <div class="daily-example">
                        <h5><i class="fas fa-handshake"></i> Negotiating a Price</h5>
                        <p><strong>Buying a used car:</strong></p>
                        <p><strong>You (MAX):</strong> Want to pay as LITTLE as possible</p>
                        <p><strong>Seller (MIN):</strong> Wants to get as MUCH as possible (minimize your gain)</p>
                        <p><strong>Your thinking:</strong> "If I offer $5000, they'll probably counter with $7000. Then I offer $6000, they might accept $6500..."</p>
                        <p><em>You're running Mini-Max in your head!</em></p>
                    </div>

                    <div class="daily-example">
                        <h5><i class="fas fa-gavel"></i> Legal Strategy in Court</h5>
                        <p><strong>Prosecutor (MAX):</strong> Wants maximum sentence</p>
                        <p><strong>Defense (MIN):</strong> Wants minimum sentence</p>
                        <p><strong>Both sides think:</strong> "If I present this evidence, the other side will counter with..."</p>
                        <p><em>Legal strategy is essentially Mini-Max with arguments instead of chess pieces!</em></p>
                    </div>

                    <div class="daily-example">
                        <h5><i class="fas fa-futbol"></i> Sports Strategy</h5>
                        <p><strong>Your team:</strong> Wants to maximize points scored</p>
                        <p><strong>Opposing team:</strong> Wants to minimize your points (and maximize theirs)</p>
                        <p><strong>Coach's thinking:</strong> "If we run this play, they'll probably defend like this, so we should actually run that play instead..."</p>
                        <p><em>Every play-call involves Mini-Max thinking!</em></p>
                    </div>
                </div>

                <!-- Walkthrough Example -->
                <div class="walkthrough-box">
                    <div class="walkthrough-header">
                        <i class="fas fa-shoe-prints"></i> Step-by-Step: How Mini-Max Decides a Move
                    </div>
                    <p>Let's trace through a simple game tree to see exactly how Mini-Max works:</p>

                    <div class="step">
                        <div class="step-number">1</div>
                        <h5>Build the Game Tree</h5>
                        <p>Starting from the current position, generate ALL possible moves for YOU (MAX), then for each of those, ALL possible responses by opponent (MIN), and so on until the game ends or we hit our depth limit.</p>
                        <pre style="background:#f0fdf4; padding:10px; border-radius:6px; margin-top:10px;">
                    YOU (MAX)
                   /         \
              MIN(A)       MIN(B)
             /    \       /    \
           3      5      2      9   (These are final scores if game ends here)
                        </pre>
                    </div>

                    <div class="step">
                        <div class="step-number">2</div>
                        <h5>Evaluate Leaf Nodes</h5>
                        <p>At the bottom (leaf nodes), we have actual game outcomes. In this example: 3, 5, 2, 9 are the scores if the game reaches those states. Higher is better for you!</p>
                    </div>

                    <div class="step">
                        <div class="step-number">3</div>
                        <h5>MIN Nodes Pick Minimum</h5>
                        <p><strong>MIN(A):</strong> Opponent chooses between 3 and 5  picks <strong>3</strong> (worse for you)</p>
                        <p><strong>MIN(B):</strong> Opponent chooses between 2 and 9  picks <strong>2</strong> (worse for you)</p>
                        <p><em>Remember: Your opponent is trying to HURT you!</em></p>
                    </div>

                    <div class="step">
                        <div class="step-number">4</div>
                        <h5>MAX Node Picks Maximum</h5>
                        <p><strong>YOU:</strong> Choose between MIN(A)=3 and MIN(B)=2</p>
                        <p>You pick <strong>3</strong> (the move leading to MIN(A))</p>
                        <p><em>Even though MIN(B) has a path to 9, you can't get it because opponent will block you!</em></p>
                    </div>

                    <div class="step">
                        <div class="step-number">5</div>
                        <h5>Final Decision</h5>
                        <p>You should take move A! The guaranteed value is 3.</p>
                        <p><strong>Why not move B?</strong> Move B COULD lead to 9, but against a smart opponent, it will actually give you only 2. Move A guarantees at least 3.</p>
                    </div>
                </div>

                <div class="wwwh-grid">
                    <div class="wwwh-item what">
                        <h4><i class="fas fa-question-circle"></i>WHAT is Adversarial Search?</h4>
                        <p>Search in competitive environments where opponents try to minimize your utility. The game tree represents alternating moves by MAX and MIN players.</p>
                    </div>
                    <div class="wwwh-item why">
                        <h4><i class="fas fa-lightbulb"></i>WHY Game Trees?</h4>
                        <p>To make optimal decisions against intelligent opponents. Foundation for chess engines, Go AI, game-playing bots.</p>
                    </div>
                    <div class="wwwh-item when">
                        <h4><i class="fas fa-clock"></i>WHEN to Use Mini-Max?</h4>
                        <p>Two-player, zero-sum, perfect information games: Chess, Checkers, Tic-Tac-Toe, Connect Four, Othello.</p>
                    </div>
                    <div class="wwwh-item how">
                        <h4><i class="fas fa-cogs"></i>HOW Does Mini-Max Work?</h4>
                        <p>MAX player maximizes score, MIN player minimizes it. Recursively evaluate all positions, backing up optimal values.</p>
                    </div>
                </div>

                <h3><i class="fas fa-calculator"></i>Evaluation Function</h3>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>Evaluation Function:</strong> A heuristic that estimates the "goodness" of a game position. Returns + for winning, - for losing, and intermediate values for uncertain positions.</p>
                </div>

                <table>
                    <thead>
                        <tr>
                            <th>Game</th>
                            <th>Evaluation Components</th>
                            <th>Example Features</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Chess</strong></td>
                            <td>Material, Position, Safety</td>
                            <td>Queen=9, Rook=5, Knight=3, Pawn=1, King safety, Center control</td>
                        </tr>
                        <tr>
                            <td><strong>Tic-Tac-Toe</strong></td>
                            <td>Lines, Blocks</td>
                            <td>+10 for win, -10 for loss, 0 for draw</td>
                        </tr>
                        <tr>
                            <td><strong>Checkers</strong></td>
                            <td>Pieces, Kings</td>
                            <td>King=2regular piece, Position on board</td>
                        </tr>
                    </tbody>
                </table>

                <h3><i class="fas fa-arrows-alt-v"></i>Mini-Max Algorithm</h3>

                <div class="algorithm-box">
                    <div class="algorithm-title">
                        <i class="fas fa-code"></i>Mini-Max Algorithm
                    </div>
                    <ol class="algorithm-steps">
                        <li>If node is terminal (win/lose/draw), return utility value</li>
                        <li>If MAX's turn: return maximum of children's Mini-Max values</li>
                        <li>If MIN's turn: return minimum of children's Mini-Max values</li>
                        <li>Backed-up value is the optimal value for the position</li>
                    </ol>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-lang"><i class="fab fa-python"></i> Python - Mini-Max with Tic-Tac-Toe (Line-by-Line Explained)</span>
                        <button class="copy-button" onclick="copyCode(this)">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <div class="code-block"><span class="comment"># </span>
<span class="comment"># TIC-TAC-TOE GAME CLASS - Represents the game state</span>
<span class="comment"># </span>

<span class="keyword">class</span> <span class="class">TicTacToe</span>:
    <span class="string">"""Tic-Tac-Toe game - the 'world' our AI will reason about"""</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        <span class="comment"># Create 3x3 board: each cell starts empty ('')</span>
        self.board = [[<span class="string">''</span>] * <span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="function">range</span>(<span class="number">3</span>)]
        <span class="comment"># X always goes first (X = MAX player, O = MIN player)</span>
        self.current_player = <span class="string">'X'</span>

    <span class="keyword">def</span> <span class="function">get_winner</span>(self):
        <span class="string">"""Check all winning lines for a winner"""</span>
        lines = []
        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(<span class="number">3</span>):
            lines.append([self.board[i][j] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="function">range</span>(<span class="number">3</span>)])  <span class="comment"># 3 rows</span>
            lines.append([self.board[j][i] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="function">range</span>(<span class="number">3</span>)])  <span class="comment"># 3 columns</span>
        lines.append([self.board[i][i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(<span class="number">3</span>)])      <span class="comment"># main diagonal</span>
        lines.append([self.board[i][<span class="number">2</span>-i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(<span class="number">3</span>)])    <span class="comment"># anti-diagonal</span>

        <span class="keyword">for</span> line <span class="keyword">in</span> lines:
            <span class="keyword">if</span> line[<span class="number">0</span>] == line[<span class="number">1</span>] == line[<span class="number">2</span>] <span class="keyword">and</span> line[<span class="number">0</span>]:  <span class="comment"># Three in a row!</span>
                <span class="keyword">return</span> line[<span class="number">0</span>]  <span class="comment"># Returns 'X' or 'O'</span>
        <span class="keyword">return</span> <span class="keyword">None</span>  <span class="comment"># No winner yet</span>

    <span class="keyword">def</span> <span class="function">is_full</span>(self):
        <span class="string">"""Check if board is completely filled"""</span>
        <span class="keyword">return</span> <span class="function">all</span>(self.board[i][j] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(<span class="number">3</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="function">range</span>(<span class="number">3</span>))

    <span class="keyword">def</span> <span class="function">is_terminal</span>(self):
        <span class="string">"""Game over? (someone won OR board is full)"""</span>
        <span class="keyword">return</span> self.get_winner() <span class="keyword">is not</span> <span class="keyword">None</span> <span class="keyword">or</span> self.is_full()

    <span class="keyword">def</span> <span class="function">utility</span>(self):
        <span class="string">"""Score from X's perspective (MAX player)"""</span>
        winner = self.get_winner()
        <span class="keyword">if</span> winner == <span class="string">'X'</span>: <span class="keyword">return</span> <span class="number">10</span>   <span class="comment"># X wins = +10 (good for MAX)</span>
        <span class="keyword">if</span> winner == <span class="string">'O'</span>: <span class="keyword">return</span> <span class="number">-10</span>  <span class="comment"># O wins = -10 (bad for MAX)</span>
        <span class="keyword">return</span> <span class="number">0</span>  <span class="comment"># Draw = 0 (neutral)</span>

    <span class="keyword">def</span> <span class="function">get_moves</span>(self):
        <span class="string">"""List all empty cells (possible moves)"""</span>
        <span class="keyword">return</span> [(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(<span class="number">3</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="function">range</span>(<span class="number">3</span>) <span class="keyword">if</span> self.board[i][j] == <span class="string">''</span>]

    <span class="keyword">def</span> <span class="function">make_move</span>(self, row, col):
        <span class="string">"""Place current player's mark and switch turns"""</span>
        self.board[row][col] = self.current_player
        self.current_player = <span class="string">'O'</span> <span class="keyword">if</span> self.current_player == <span class="string">'X'</span> <span class="keyword">else</span> <span class="string">'X'</span>

    <span class="keyword">def</span> <span class="function">undo_move</span>(self, row, col):
        <span class="string">"""Undo a move (for backtracking in Mini-Max)"""</span>
        self.board[row][col] = <span class="string">''</span>
        self.current_player = <span class="string">'O'</span> <span class="keyword">if</span> self.current_player == <span class="string">'X'</span> <span class="keyword">else</span> <span class="string">'X'</span>

<span class="comment"># </span>
<span class="comment"># MINI-MAX ALGORITHM - The heart of game-playing AI</span>
<span class="comment"># </span>

<span class="keyword">def</span> <span class="function">minimax</span>(game, depth, is_maximizing):
    <span class="string">"""
    Mini-Max Algorithm - Finds optimal move assuming perfect opponent

    KEY INSIGHT: We simulate ALL possible games to the end, then work
    backwards to find the move that leads to the best GUARANTEED outcome.
    """</span>

    <span class="comment"># </span>
    <span class="comment"># BASE CASE: Game is over (someone won or draw)</span>
    <span class="comment"># </span>
    <span class="keyword">if</span> game.is_terminal():
        <span class="keyword">return</span> game.utility()  <span class="comment"># Return actual score: +10, -10, or 0</span>
        <span class="comment"># OUTPUT example: If X won, returns 10</span>

    <span class="comment"># Get all legal moves from current position</span>
    moves = game.get_moves()
    <span class="comment"># OUTPUT: moves = [(1,0), (1,2), (2,0), (2,1), (2,2)] for 5 empty cells</span>

    <span class="comment"># </span>
    <span class="comment"># MAX PLAYER'S TURN (X) - Wants the HIGHEST value</span>
    <span class="comment"># </span>
    <span class="keyword">if</span> is_maximizing:
        max_eval = <span class="function">float</span>(<span class="string">'-inf'</span>)  <span class="comment"># Start with worst possible (-)</span>

        <span class="keyword">for</span> row, col <span class="keyword">in</span> moves:          <span class="comment"># Try each possible move</span>
            game.make_move(row, col)      <span class="comment"># Make the move temporarily</span>
            <span class="comment"># RECURSIVE CALL: What happens after this move?</span>
            <span class="comment"># Now it's MIN's turn (is_maximizing=False)</span>
            eval_score = minimax(game, depth + <span class="number">1</span>, <span class="keyword">False</span>)
            game.undo_move(row, col)      <span class="comment"># Undo (we're just exploring)</span>

            max_eval = <span class="function">max</span>(max_eval, eval_score)  <span class="comment"># Keep best (highest)</span>
            <span class="comment"># OUTPUT: "Move (2,0) leads to value 10, best so far!"</span>

        <span class="keyword">return</span> max_eval  <span class="comment"># Return the best value MAX can achieve</span>

    <span class="comment"># </span>
    <span class="comment"># MIN PLAYER'S TURN (O) - Wants the LOWEST value</span>
    <span class="comment"># </span>
    <span class="keyword">else</span>:
        min_eval = <span class="function">float</span>(<span class="string">'inf'</span>)  <span class="comment"># Start with worst possible (+)</span>

        <span class="keyword">for</span> row, col <span class="keyword">in</span> moves:          <span class="comment"># Try each possible move</span>
            game.make_move(row, col)      <span class="comment"># Make the move temporarily</span>
            <span class="comment"># RECURSIVE CALL: What happens after this move?</span>
            <span class="comment"># Now it's MAX's turn (is_maximizing=True)</span>
            eval_score = minimax(game, depth + <span class="number">1</span>, <span class="keyword">True</span>)
            game.undo_move(row, col)      <span class="comment"># Undo (we're just exploring)</span>

            min_eval = <span class="function">min</span>(min_eval, eval_score)  <span class="comment"># Keep best (lowest)</span>
            <span class="comment"># OUTPUT: "Move (1,0) leads to value -10, best for MIN!"</span>

        <span class="keyword">return</span> min_eval  <span class="comment"># Return the best value MIN can achieve</span>

<span class="comment"># </span>
<span class="comment"># FIND BEST MOVE - Wrapper to get actual move, not just value</span>
<span class="comment"># </span>

<span class="keyword">def</span> <span class="function">find_best_move</span>(game):
    <span class="string">"""Find the best move for the current player"""</span>
    best_move = <span class="keyword">None</span>
    is_max = (game.current_player == <span class="string">'X'</span>)  <span class="comment"># X is MAX, O is MIN</span>
    best_value = <span class="function">float</span>(<span class="string">'-inf'</span>) <span class="keyword">if</span> is_max <span class="keyword">else</span> <span class="function">float</span>(<span class="string">'inf'</span>)

    <span class="keyword">for</span> row, col <span class="keyword">in</span> game.get_moves():
        game.make_move(row, col)
        value = minimax(game, <span class="number">0</span>, <span class="keyword">not</span> is_max)  <span class="comment"># Evaluate this move</span>
        game.undo_move(row, col)

        <span class="keyword">if</span> is_max <span class="keyword">and</span> value > best_value:  <span class="comment"># MAX wants highest</span>
            best_value = value
            best_move = (row, col)
        <span class="keyword">elif</span> <span class="keyword">not</span> is_max <span class="keyword">and</span> value < best_value:  <span class="comment"># MIN wants lowest</span>
            best_value = value
            best_move = (row, col)

    <span class="keyword">return</span> best_move, best_value

<span class="comment"># </span>
<span class="comment"># EXAMPLE: X's turn with this board</span>
<span class="comment"># </span>
game = TicTacToe()
game.board = [
    [<span class="string">'X'</span>, <span class="string">'O'</span>, <span class="string">'X'</span>],   <span class="comment"># Row 0: X|O|X</span>
    [<span class="string">''</span>, <span class="string">'O'</span>, <span class="string">''</span>],    <span class="comment"># Row 1: _|O|_</span>
    [<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>]      <span class="comment"># Row 2: _|_|_</span>
]
game.current_player = <span class="string">'X'</span>

<span class="function">print</span>(<span class="string">"Current board:"</span>)
<span class="keyword">for</span> row <span class="keyword">in</span> game.board:
    <span class="function">print</span>([c <span class="keyword">if</span> c <span class="keyword">else</span> <span class="string">'_'</span> <span class="keyword">for</span> c <span class="keyword">in</span> row])

move, value = find_best_move(game)
<span class="function">print</span>(<span class="string">f"\nBest move for X: {move}, Value: {value}"</span>)

<span class="comment"># </span>
<span class="comment"># EXECUTION TRACE for the example above:</span>
<span class="comment"># </span>
<span class="comment"># Available moves: (1,0), (1,2), (2,0), (2,1), (2,2)</span>
<span class="comment">#</span>
<span class="comment"># Try (1,0): X|O|X     O's turn, O tries to block...</span>
<span class="comment">#            X|O|_      Eventually leads to value 0 (draw)</span>
<span class="comment">#            _|_|_</span>
<span class="comment">#</span>
<span class="comment"># Try (2,0): X|O|X     X can win with diagonal! (X at 0,0; 1,1; 2,0?)</span>
<span class="comment">#            _|O|_      Wait, (0,0) is X, (1,1) is O... Try column?</span>
<span class="comment">#            X|_|_      X at (0,0), (1,0)? No, (1,0) empty. Check (0,2),(1,2),(2,2)?</span>
<span class="comment">#                       X at (2,0) enables: (2,0)(2,1)(2,2) path!</span>
<span class="comment">#                       After analysis: This leads to value 10 (X wins!)</span>
<span class="comment">#</span>
<span class="comment"># Best move: (2,0) with value 10 - X wins!</span>
<span class="comment"># OUTPUT: Best move for X: (2, 0), Value: 10</span>
<span class="comment"># </span></div>
                </div>

                <!-- Mini-Max Complexity Explanation -->
                <div class="walkthrough-box" style="margin: 25px 0;">
                    <h4 style="color: #1e3a5f; margin-bottom: 15px;"><i class="fas fa-clock"></i> Mini-Max Complexity - Simple Explanation</h4>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div style="background: #fee2e2; padding: 15px; border-radius: 8px; border-left: 4px solid #ef4444;">
                            <h5 style="color: #991b1b;">Time Complexity: O(b<sup>m</sup>)</h5>
                            <p><strong>What do b and m mean?</strong></p>
                            <ul style="margin-left: 20px; font-size: 0.95em;">
                                <li><strong>b</strong> = branching factor (average moves per turn)</li>
                                <li><strong>m</strong> = maximum depth (game length)</li>
                            </ul>
                            <p style="margin-top:10px;"><strong>Why exponential?</strong></p>
                            <ul style="margin-left: 20px; font-size: 0.95em;">
                                <li>At each level, we try ALL b moves</li>
                                <li>Each move leads to b more moves... for m levels</li>
                                <li>Total nodes = b  b  b  ... (m times) = b<sup>m</sup></li>
                            </ul>
                            <div style="background: #fef2f2; padding: 10px; border-radius: 4px; margin-top: 10px;">
                                <strong>Tic-Tac-Toe:</strong> b  4 (average), m = 9 (max moves)<br>
                                Worst case: ~9! = 362,880 states (actually ~550,000 with recursion)<br>
                                <strong>Chess:</strong> b  35, m  80  35<sup>80</sup> = IMPOSSIBLE!
                            </div>
                        </div>

                        <div style="background: #dbeafe; padding: 15px; border-radius: 8px; border-left: 4px solid #3b82f6;">
                            <h5 style="color: #1e40af;">Space Complexity: O(b  m)</h5>
                            <p><strong>Why linear in depth?</strong></p>
                            <ul style="margin-left: 20px; font-size: 0.95em;">
                                <li>Uses recursion (function call stack)</li>
                                <li>Maximum recursion depth = m (game length)</li>
                                <li>At each level, stores b moves temporarily</li>
                                <li>Total stack space = O(b  m)</li>
                            </ul>
                            <div style="background: #eff6ff; padding: 10px; border-radius: 4px; margin-top: 10px;">
                                <strong>Key insight:</strong> Mini-Max uses DFS (depth-first), so it only keeps ONE path in memory at a time, not the entire tree!
                            </div>
                        </div>
                    </div>

                    <div style="background: #f0fdf4; padding: 15px; border-radius: 8px; margin-top: 15px; border-left: 4px solid #22c55e;">
                        <h5 style="color: #166534;"><i class="fas fa-check-circle"></i> Properties of Mini-Max</h5>
                        <ul style="margin-left: 20px;">
                            <li><strong>Complete:</strong> Yes, always finds a terminal state (if game ends)</li>
                            <li><strong>Optimal:</strong> Yes, finds best move against optimal opponent</li>
                            <li><strong>Problem:</strong> Exponential time makes it impractical for complex games</li>
                            <li><strong>Solution:</strong> Alpha-Beta Pruning reduces work by ~96%!</li>
                        </ul>
                    </div>
                </div>

                <!-- Mini-Max Visualization Section -->
                <div class="visualization-section" style="margin: 40px 0; background: linear-gradient(135deg, #1e3a5f 0%, #7c3aed 100%); border-radius: 16px; padding: 30px;">
                    <h4 style="color: #fff; margin-bottom: 20px; text-align: center;">
                        <i class="fas fa-chess"></i> Mini-Max Algorithm Visualization
                    </h4>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; align-items: start;">
                        <!-- Video Player -->
                        <div style="background: #0f172a; border-radius: 12px; padding: 15px;">
                            <video id="minimaxVideo" controls style="width: 100%; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                                <source src="assets/videos/minimax.mp4" type="video/mp4">
                                <source src="assets/videos/minimax.gif" type="image/gif">
                                Your browser does not support video playback.
                            </video>
                            <p style="color: #94a3b8; text-align: center; margin-top: 10px; font-size: 14px;">
                                <i class="fas fa-info-circle"></i> Watch Mini-Max evaluate game tree step-by-step
                            </p>
                        </div>

                        <!-- Step Images Gallery -->
                        <div style="background: rgba(255,255,255,0.1); border-radius: 12px; padding: 15px;">
                            <h5 style="color: #fef3c7; margin-bottom: 15px;"><i class="fas fa-images"></i> Step-by-Step Frames</h5>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; max-height: 300px; overflow-y: auto;">
                                <img src="assets/images/minimax_step_0.png" alt="Mini-Max Step 0" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/minimax_step_1.png" alt="Mini-Max Step 1" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/minimax_step_2.png" alt="Mini-Max Step 2" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/minimax_step_3.png" alt="Mini-Max Step 3" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/minimax_step_4.png" alt="Mini-Max Step 4" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/minimax_step_5.png" alt="Mini-Max Step 5" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/minimax_step_6.png" alt="Mini-Max Step 6" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/minimax_step_7.png" alt="Mini-Max Step 7" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                            </div>
                        </div>
                    </div>

                    <!-- Mini-Max Legend -->
                    <div style="margin-top: 20px; background: rgba(255,255,255,0.95); border-radius: 8px; padding: 15px;">
                        <div style="display: flex; flex-wrap: wrap; gap: 20px; justify-content: center;">
                            <span><span style="display:inline-block;width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-bottom:16px solid #3b82f6;vertical-align:middle;margin-right:4px;"></span> MAX Node (maximize)</span>
                            <span><span style="display:inline-block;width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-top:16px solid #7c3aed;vertical-align:middle;margin-right:4px;"></span> MIN Node (minimize)</span>
                            <span><span style="display:inline-block;width:16px;height:16px;background:#86efac;border-radius:50%;vertical-align:middle;"></span> Terminal (leaf)</span>
                            <span><span style="display:inline-block;width:16px;height:16px;background:#3b82f6;border-radius:50%;vertical-align:middle;"></span> Current Node</span>
                            <span><span style="display:inline-block;width:16px;height:16px;background:#c4b5fd;border-radius:50%;vertical-align:middle;"></span> Evaluated</span>
                        </div>
                        <p style="text-align: center; margin-top: 10px; color: #1e3a5f; font-weight: 500;">
                            <i class="fas fa-gamepad"></i> Mini-Max: MAX picks highest value, MIN picks lowest value - assumes optimal opponent
                        </p>
                    </div>
                </div>

                <h3><i class="fas fa-cut"></i>Alpha-Beta Pruning</h3>

                <div class="definition">
                    <p><i class="fas fa-book"></i><strong>Alpha-Beta Pruning:</strong> Optimization of Mini-Max that eliminates branches that cannot affect the final decision. Maintains  (best for MAX) and  (best for MIN) to prune.</p>
                </div>

                <div class="simple-explanation">
                    <div class="simple-explanation-title">
                        <i class="fas fa-lightbulb"></i>Alpha-Beta Intuition
                    </div>
                    <p><strong> (alpha):</strong> Best value MAX can guarantee (starts at -)</p>
                    <p><strong> (beta):</strong> Best value MIN can guarantee (starts at +)</p>
                    <p style="margin-top: 10px;"><strong>Pruning rule:</strong> If at any point   , we can stop searching this branch!</p>
                    <p style="margin-top: 10px;"><em>Think of it like:</em> "I already have a move worth 5. Why would I explore a path where my opponent can force me to get less than 5?"</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-lang"><i class="fab fa-python"></i> Python - Alpha-Beta Pruning (Line-by-Line Explained)</span>
                        <button class="copy-button" onclick="copyCode(this)">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <div class="code-block"><span class="comment"># </span>
<span class="comment"># ALPHA-BETA PRUNING - Smart Mini-Max that skips useless branches</span>
<span class="comment"># </span>
<span class="comment">#</span>
<span class="comment"># KEY INSIGHT: If we already know a better path exists, why keep exploring</span>
<span class="comment"># paths that can only lead to worse outcomes?</span>
<span class="comment">#</span>
<span class="comment">#  (alpha) = "I (MAX) can already guarantee at least this value"</span>
<span class="comment">#  (beta)  = "Opponent (MIN) can already force at most this value"</span>
<span class="comment">#</span>
<span class="comment"># If   : STOP! This branch is useless.</span>
<span class="comment"># </span>

<span class="keyword">def</span> <span class="function">alpha_beta</span>(game, depth, alpha, beta, is_maximizing):
    <span class="string">"""
    Mini-Max with Alpha-Beta Pruning

    Same result as Mini-Max, but MUCH faster by pruning hopeless branches.
    In Tic-Tac-Toe: 549,946 nodes  18,297 nodes (96.7% reduction!)
    """</span>
    <span class="keyword">global</span> nodes_explored
    nodes_explored += <span class="number">1</span>  <span class="comment"># Count how many nodes we visit</span>

    <span class="comment"># </span>
    <span class="comment"># BASE CASE: Game over - return actual score</span>
    <span class="comment"># </span>
    <span class="keyword">if</span> game.is_terminal():
        <span class="keyword">return</span> game.utility()  <span class="comment"># +10, -10, or 0</span>

    moves = game.get_moves()

    <span class="comment"># </span>
    <span class="comment"># MAX PLAYER'S TURN - Wants highest value, updates </span>
    <span class="comment"># </span>
    <span class="keyword">if</span> is_maximizing:
        max_eval = <span class="function">float</span>(<span class="string">'-inf'</span>)

        <span class="keyword">for</span> row, col <span class="keyword">in</span> moves:
            game.make_move(row, col)
            <span class="comment"># Recursive call with same ,  (passed down)</span>
            eval_score = alpha_beta(game, depth + <span class="number">1</span>, alpha, beta, <span class="keyword">False</span>)
            game.undo_move(row, col)

            max_eval = <span class="function">max</span>(max_eval, eval_score)

            <span class="comment"># </span>
            <span class="comment"># UPDATE ALPHA: MAX found a better guaranteed value!</span>
            <span class="comment"># </span>
            alpha = <span class="function">max</span>(alpha, eval_score)
            <span class="comment"># OUTPUT: "MAX found move with value 3.  now = 3"</span>

            <span class="comment"># </span>
            <span class="comment"># BETA CUTOFF: If   , PRUNE! (MIN won't allow this path)</span>
            <span class="comment"># </span>
            <span class="keyword">if</span> beta <= alpha:
                <span class="comment"># WHY PRUNE? MIN (our parent) already has a path that gives</span>
                <span class="comment"># them  or less. We just found we can get  (which  ).</span>
                <span class="comment"># MIN will NEVER let us come here - they'll pick their better path!</span>
                <span class="keyword">break</span>  <span class="comment"># Don't bother checking remaining moves</span>
                <span class="comment"># OUTPUT: "(2)  (3), PRUNING remaining branches!"</span>

        <span class="keyword">return</span> max_eval

    <span class="comment"># </span>
    <span class="comment"># MIN PLAYER'S TURN - Wants lowest value, updates </span>
    <span class="comment"># </span>
    <span class="keyword">else</span>:
        min_eval = <span class="function">float</span>(<span class="string">'inf'</span>)

        <span class="keyword">for</span> row, col <span class="keyword">in</span> moves:
            game.make_move(row, col)
            eval_score = alpha_beta(game, depth + <span class="number">1</span>, alpha, beta, <span class="keyword">True</span>)
            game.undo_move(row, col)

            min_eval = <span class="function">min</span>(min_eval, eval_score)

            <span class="comment"># </span>
            <span class="comment"># UPDATE BETA: MIN found a better (lower) guaranteed value!</span>
            <span class="comment"># </span>
            beta = <span class="function">min</span>(beta, eval_score)
            <span class="comment"># OUTPUT: "MIN found move with value 2.  now = 2"</span>

            <span class="comment"># </span>
            <span class="comment"># ALPHA CUTOFF: If   , PRUNE! (MAX won't allow this path)</span>
            <span class="comment"># </span>
            <span class="keyword">if</span> beta <= alpha:
                <span class="comment"># WHY PRUNE? MAX (our parent) already has a path that gives</span>
                <span class="comment"># them  or more. We just found MIN can force  (which  ).</span>
                <span class="comment"># MAX will NEVER let us come here - they'll pick their better path!</span>
                <span class="keyword">break</span>
                <span class="comment"># OUTPUT: "(2)  (3), PRUNING remaining branches!"</span>

        <span class="keyword">return</span> min_eval

<span class="comment"># </span>
<span class="comment"># COMPARISON: Mini-Max vs Alpha-Beta</span>
<span class="comment"># </span>

<span class="keyword">def</span> <span class="function">compare_algorithms</span>():
    <span class="keyword">global</span> nodes_explored

    game = TicTacToe()  <span class="comment"># Empty board - worst case for both</span>

    <span class="comment"># Run Mini-Max</span>
    nodes_explored = <span class="number">0</span>
    minimax(game, <span class="number">0</span>, <span class="keyword">True</span>)
    mm_nodes = nodes_explored

    <span class="comment"># Run Alpha-Beta</span>
    nodes_explored = <span class="number">0</span>
    alpha_beta(game, <span class="number">0</span>, <span class="function">float</span>(<span class="string">'-inf'</span>), <span class="function">float</span>(<span class="string">'inf'</span>), <span class="keyword">True</span>)
    ab_nodes = nodes_explored

    <span class="function">print</span>(<span class="string">f"Empty Tic-Tac-Toe Board Analysis:"</span>)
    <span class="function">print</span>(<span class="string">f"Mini-Max nodes explored: {mm_nodes:,}"</span>)
    <span class="function">print</span>(<span class="string">f"Alpha-Beta nodes explored: {ab_nodes:,}"</span>)
    <span class="function">print</span>(<span class="string">f"Reduction: {(1 - ab_nodes/mm_nodes)*100:.1f}%"</span>)

nodes_explored = <span class="number">0</span>
compare_algorithms()

<span class="comment"># </span>
<span class="comment"># EXECUTION TRACE for small game tree:</span>
<span class="comment">#</span>
<span class="comment">#            MAX(A) =-, =+</span>
<span class="comment">#           /              \</span>
<span class="comment">#      MIN(B)            MIN(C)</span>
<span class="comment">#      /    \            /    \</span>
<span class="comment">#     3      5          2      9</span>
<span class="comment">#</span>
<span class="comment"># Step 1: Go to B, then explore leaf 3</span>
<span class="comment">#         B's  = min(+, 3) = 3</span>
<span class="comment"># Step 2: Explore leaf 5</span>
<span class="comment">#         B's  = min(3, 5) = 3 (no change)</span>
<span class="comment">#         B returns 3 to A</span>
<span class="comment"># Step 3: A's  = max(-, 3) = 3</span>
<span class="comment">#         "MAX can guarantee at least 3 by going left!"</span>
<span class="comment"># Step 4: Go to C with =3, =+</span>
<span class="comment">#         Explore leaf 2</span>
<span class="comment">#         C's  = min(+, 2) = 2</span>
<span class="comment"># Step 5: CHECK: (2)  (3)? YES!</span>
<span class="comment">#         </span>
<span class="comment">#          PRUNE! Don't look at leaf 9!                      </span>
<span class="comment">#          Why? MAX already has 3 from left side.            </span>
<span class="comment">#          C can only give 2 or less (MIN picks minimum).    </span>
<span class="comment">#          MAX will never choose C over B!                   </span>
<span class="comment">#         </span>
<span class="comment"># Step 6: A = max(3, 2) = 3</span>
<span class="comment">#         Result: 3 (same as Mini-Max, but we skipped node 9!)</span>
<span class="comment">#</span>
<span class="comment"># OUTPUT:</span>
<span class="comment"># Empty Tic-Tac-Toe Board Analysis:</span>
<span class="comment"># Mini-Max nodes explored: 549,946</span>
<span class="comment"># Alpha-Beta nodes explored: 18,297</span>
<span class="comment"># Reduction: 96.7%</span>
<span class="comment"># </span></div>
                </div>

                <!-- Alpha-Beta Complexity Explanation -->
                <div class="walkthrough-box" style="margin: 25px 0;">
                    <h4 style="color: #1e3a5f; margin-bottom: 15px;"><i class="fas fa-clock"></i> Alpha-Beta Complexity - Simple Explanation</h4>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div style="background: #d1fae5; padding: 15px; border-radius: 8px; border-left: 4px solid #10b981;">
                            <h5 style="color: #065f46;">Time Complexity: O(b<sup>m/2</sup>) best case, O(b<sup>m</sup>) worst case</h5>
                            <p><strong>Best Case (Perfect Ordering):</strong></p>
                            <ul style="margin-left: 20px; font-size: 0.95em;">
                                <li>If moves are ordered best-first, we prune maximally</li>
                                <li>Effective branching factor becomes b</li>
                                <li>Time = (b)<sup>m</sup> = b<sup>m/2</sup></li>
                                <li><strong>Chess example:</strong> 35<sup>40</sup> instead of 35<sup>80</sup>!</li>
                            </ul>
                            <p style="margin-top:10px;"><strong>Worst Case (Worst Ordering):</strong></p>
                            <ul style="margin-left: 20px; font-size: 0.95em;">
                                <li>If moves are ordered worst-first, no pruning occurs</li>
                                <li>Same as Mini-Max: O(b<sup>m</sup>)</li>
                            </ul>
                            <div style="background: #f0fdf4; padding: 10px; border-radius: 4px; margin-top: 10px;">
                                <strong>Real impact:</strong> In Tic-Tac-Toe, we see 96.7% reduction. In Chess, proper ordering achieves similar pruning!
                            </div>
                        </div>

                        <div style="background: #dbeafe; padding: 15px; border-radius: 8px; border-left: 4px solid #3b82f6;">
                            <h5 style="color: #1e40af;">Space Complexity: O(b  m) - Same as Mini-Max</h5>
                            <p><strong>Why same space?</strong></p>
                            <ul style="margin-left: 20px; font-size: 0.95em;">
                                <li>Still uses DFS (recursion stack)</li>
                                <li>Only adds two numbers (, ) per call</li>
                                <li>Pruning reduces TIME, not space</li>
                                <li>Maximum stack depth still = m</li>
                            </ul>
                            <div style="background: #eff6ff; padding: 10px; border-radius: 4px; margin-top: 10px;">
                                <strong>Memory per level:</strong> Just store current ,  plus move list  O(b) per level. Total: O(b  m).
                            </div>
                        </div>
                    </div>

                    <div style="background: #fef3c7; padding: 15px; border-radius: 8px; margin-top: 15px; border-left: 4px solid #f59e0b;">
                        <h5 style="color: #92400e;"><i class="fas fa-sort-amount-down"></i> Why Move Ordering Matters</h5>
                        <p>To get best-case performance, examine "best" moves first:</p>
                        <ul style="margin-left: 20px;">
                            <li><strong>Killer Move Heuristic:</strong> Moves that caused cutoffs before often do again</li>
                            <li><strong>History Heuristic:</strong> Track which moves were good in similar positions</li>
                            <li><strong>Iterative Deepening:</strong> Search depth d-1 first, use results to order depth d</li>
                            <li><strong>Domain Knowledge:</strong> In chess, captures/checks before quiet moves</li>
                        </ul>
                    </div>

                    <div style="background: #f0fdf4; padding: 15px; border-radius: 8px; margin-top: 15px; border-left: 4px solid #22c55e;">
                        <h5 style="color: #166534;"><i class="fas fa-check-circle"></i> Key Properties</h5>
                        <ul style="margin-left: 20px;">
                            <li><strong>Complete:</strong> Yes (same as Mini-Max)</li>
                            <li><strong>Optimal:</strong> Yes - ALWAYS gives same result as Mini-Max!</li>
                            <li><strong>Pruning is SAFE:</strong> We only skip branches that can't affect the answer</li>
                            <li><strong>Foundation:</strong> Used in ALL modern game-playing programs</li>
                        </ul>
                    </div>
                </div>

                <!-- Alpha-Beta Pruning Visualization Section -->
                <div class="visualization-section" style="margin: 40px 0; background: linear-gradient(135deg, #7c3aed 0%, #ec4899 100%); border-radius: 16px; padding: 30px;">
                    <h4 style="color: #fff; margin-bottom: 20px; text-align: center;">
                        <i class="fas fa-cut"></i> Alpha-Beta Pruning Visualization
                    </h4>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; align-items: start;">
                        <!-- Video Player -->
                        <div style="background: #0f172a; border-radius: 12px; padding: 15px;">
                            <video id="alphabetaVideo" controls style="width: 100%; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                                <source src="assets/videos/alphabeta.mp4" type="video/mp4">
                                <source src="assets/videos/alphabeta.gif" type="image/gif">
                                Your browser does not support video playback.
                            </video>
                            <p style="color: #94a3b8; text-align: center; margin-top: 10px; font-size: 14px;">
                                <i class="fas fa-info-circle"></i> Watch Alpha-Beta prune unnecessary branches
                            </p>
                        </div>

                        <!-- Step Images Gallery -->
                        <div style="background: rgba(255,255,255,0.1); border-radius: 12px; padding: 15px;">
                            <h5 style="color: #fef3c7; margin-bottom: 15px;"><i class="fas fa-images"></i> Step-by-Step Frames</h5>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; max-height: 300px; overflow-y: auto;">
                                <img src="assets/images/alphabeta_step_0.png" alt="Alpha-Beta Step 0" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/alphabeta_step_1.png" alt="Alpha-Beta Step 1" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/alphabeta_step_2.png" alt="Alpha-Beta Step 2" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/alphabeta_step_3.png" alt="Alpha-Beta Step 3" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/alphabeta_step_4.png" alt="Alpha-Beta Step 4" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/alphabeta_step_5.png" alt="Alpha-Beta Step 5" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                                <img src="assets/images/alphabeta_step_6.png" alt="Alpha-Beta Step 6" style="width: 100%; border-radius: 6px; cursor: pointer;" onclick="openModal(this.src)">
                            </div>
                        </div>
                    </div>

                    <!-- Alpha-Beta Legend -->
                    <div style="margin-top: 20px; background: rgba(255,255,255,0.95); border-radius: 8px; padding: 15px;">
                        <div style="display: flex; flex-wrap: wrap; gap: 20px; justify-content: center;">
                            <span><span style="display:inline-block;width:16px;height:16px;background:#3b82f6;border-radius:50%;vertical-align:middle;"></span> Current Node</span>
                            <span><span style="display:inline-block;width:16px;height:16px;background:#c4b5fd;border-radius:50%;vertical-align:middle;"></span> Evaluated</span>
                            <span><span style="display:inline-block;width:16px;height:16px;background:#fecaca;border-radius:50%;vertical-align:middle;"></span> <strong style="color:#ef4444;">PRUNED!</strong></span>
                            <span style="background:#dbeafe;padding:2px 8px;border-radius:4px;"><strong></strong> = best for MAX</span>
                            <span style="background:#dbeafe;padding:2px 8px;border-radius:4px;"><strong></strong> = best for MIN</span>
                        </div>
                        <p style="text-align: center; margin-top: 10px; color: #1e3a5f; font-weight: 500;">
                            <i class="fas fa-bolt"></i> <strong>Pruning Rule:</strong> When   , stop searching this branch! Same result as Mini-Max with 96%+ less work!
                        </p>
                    </div>
                </div>

                <div class="chart-container">
                    <div class="chart-title"><i class="fas fa-chart-bar"></i> Mini-Max vs Alpha-Beta: Nodes Explored</div>
                    <canvas id="pruningChart" height="120"></canvas>
                </div>

                <div class="case-study">
                    <div class="case-study-title">
                        <i class="fas fa-chess"></i>Industry Case Study: Deep Blue vs Kasparov (1997)
                    </div>
                    <p><strong>System:</strong> IBM Deep Blue - First computer to beat world chess champion</p>
                    <p><strong>Technology:</strong></p>
                    <ul style="margin: 15px 0 0 25px;">
                        <li><strong>Alpha-Beta with Extensions:</strong> Deeper search for promising lines</li>
                        <li><strong>Evaluation Function:</strong> 8,000+ features including piece values, king safety, pawn structure</li>
                        <li><strong>Hardware:</strong> 256 custom chess processors, 200 million positions/second</li>
                        <li><strong>Opening Book:</strong> 4,000 positions from grandmaster games</li>
                    </ul>
                    <p style="margin-top: 15px;"><strong>Result:</strong> 3.5-2.5 victory over Garry Kasparov!</p>

                    <!-- Detailed Breakdown -->
                    <div style="margin-top: 25px; background: #fef2f2; padding: 20px; border-radius: 12px; border: 2px solid #ef4444;">
                        <h4 style="color: #991b1b; margin-bottom: 15px;"><i class="fas fa-chess-king"></i> Inside Deep Blue: How a Computer Beat the World Champion</h4>

                        <!-- Architecture Diagram -->
                        <div style="background: #1e293b; color: #e2e8f0; padding: 20px; border-radius: 8px; font-family: monospace; font-size: 0.85em; overflow-x: auto;" role="img" aria-label="Deep Blue Chess AI Architecture: Shows the decision flow from receiving Kasparov's move through Opening Book lookup, Move Generator, Game Tree Search (Alpha-Beta), Evaluation Function (8000 features), and finally the Best Move output. 480 custom chess chips ran in parallel.">
                        <p class="sr-only" style="position: absolute; left: -10000px; width: 1px; height: 1px; overflow: hidden;">Diagram description: A flowchart of Deep Blue's architecture. After receiving opponent's move, it first checks the Opening Book (4000 GM games). If not found, the Move Generator creates legal moves, then 480 parallel chess chips run Alpha-Beta search 12+ ply deep. The Evaluation Function scores positions using 8000 features including material, position, king safety. The best move is returned within tournament time limits.</p>
<pre style="margin: 0;">

                        DEEP BLUE ARCHITECTURE                                

                                                                              
   KASPAROV'S MOVE: e2-e4                                                     
                                                                             
                                                                             
                                                           
     OPENING BOOK     Lookup known positions (4,000 GM games)          
     (if in book)         Returns: "Play c5 (Sicilian Defense)"             
                                                           
             (if not in book)                                                
                                                                             
      
                       ALPHA-BETA SEARCH ENGINE                             
            
       DEPTH 12-14 (sometimes 40+ with extensions)                        
                                                                          
                MAX (Deep Blue's turn)                                    
               /    |    |    \                                           
            e5    d5    c5    Nf6   ... (20 possible moves)               
                                                                         
            MIN (Kasparov's response)                                     
           / | \                                                          
        Nf3 d4 Nc3 ... (20 responses each)                                
                                                                         
        ... continues 12-14 moves deep ...                                
                                                                          
        PRUNING:  = best for MAX,  = best for MIN                       
                 Skip branches where                                   
            
                                                                           
                                                                           
           
                    EVALUATION FUNCTION (8,000+ features)                
                                                                         
         Material:  Q=9, R=5, B=3, N=3, P=1                             
         King Safety: -50 for exposed king, +30 for castled             
         Pawn Structure: -15 doubled pawns, +20 passed pawn             
         Piece Activity: +5 per controlled center square                
         Mobility: +2 per legal move available                          
                                                                         
         TOTAL SCORE = (all features  weights)                        
           
      
                                                                             
                                                                             
                                                           
      BEST MOVE:      Move with highest Mini-Max value                 
      Nf6 (+0.35)         "Play Knight to f6"                              
                                                           
                                                                              
   STATS: 200 million positions/second  3 minutes = 36 BILLION positions   

</pre>
                        </div>

                        <!-- Working Code Example -->
                        <h5 style="color: #991b1b; margin: 20px 0 10px 0;"><i class="fas fa-code"></i> Simplified Chess AI Implementation</h5>
                        <div class="code-container" style="margin: 0;">
                            <div class="code-header">
                                <span class="code-lang"><i class="fab fa-python"></i> Python - Deep Blue-Style Chess AI</span>
                                <button class="copy-button" onclick="copyCode(this)">
                                    <i class="fas fa-copy"></i> Copy
                                </button>
                            </div>
                            <div class="code-block"><span class="keyword">class</span> <span class="class">ChessAI</span>:
    <span class="string">"""
    Simplified Deep Blue-style Chess AI
    Uses Alpha-Beta pruning with a multi-feature evaluation function
    """</span>

    <span class="comment"># Piece values (centipawns: 100 = 1 pawn)</span>
    PIECE_VALUES = {
        <span class="string">'P'</span>: <span class="number">100</span>,   <span class="comment"># Pawn</span>
        <span class="string">'N'</span>: <span class="number">320</span>,   <span class="comment"># Knight</span>
        <span class="string">'B'</span>: <span class="number">330</span>,   <span class="comment"># Bishop (slightly better than knight)</span>
        <span class="string">'R'</span>: <span class="number">500</span>,   <span class="comment"># Rook</span>
        <span class="string">'Q'</span>: <span class="number">900</span>,   <span class="comment"># Queen</span>
        <span class="string">'K'</span>: <span class="number">20000</span>  <span class="comment"># King (infinite value, but we use large number)</span>
    }

    <span class="comment"># Piece-square tables: bonus for good positions</span>
    <span class="comment"># Knights love the center, pawns should advance, etc.</span>
    KNIGHT_TABLE = [
        [-<span class="number">50</span>,-<span class="number">40</span>,-<span class="number">30</span>,-<span class="number">30</span>,-<span class="number">30</span>,-<span class="number">30</span>,-<span class="number">40</span>,-<span class="number">50</span>],
        [-<span class="number">40</span>,-<span class="number">20</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,-<span class="number">20</span>,-<span class="number">40</span>],
        [-<span class="number">30</span>,  <span class="number">0</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">10</span>,  <span class="number">0</span>,-<span class="number">30</span>],
        [-<span class="number">30</span>,  <span class="number">5</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">15</span>,  <span class="number">5</span>,-<span class="number">30</span>],  <span class="comment"># Center is best!</span>
        [-<span class="number">30</span>,  <span class="number">0</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">15</span>,  <span class="number">0</span>,-<span class="number">30</span>],
        [-<span class="number">30</span>,  <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">10</span>,  <span class="number">5</span>,-<span class="number">30</span>],
        [-<span class="number">40</span>,-<span class="number">20</span>,  <span class="number">0</span>,  <span class="number">5</span>,  <span class="number">5</span>,  <span class="number">0</span>,-<span class="number">20</span>,-<span class="number">40</span>],
        [-<span class="number">50</span>,-<span class="number">40</span>,-<span class="number">30</span>,-<span class="number">30</span>,-<span class="number">30</span>,-<span class="number">30</span>,-<span class="number">40</span>,-<span class="number">50</span>]
    ]

    <span class="comment"># Pawn table: advance pawns, control center</span>
    PAWN_TABLE = [
        [ <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>],
        [<span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>],  <span class="comment"># About to promote!</span>
        [<span class="number">10</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">10</span>],
        [ <span class="number">5</span>,  <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>, <span class="number">25</span>, <span class="number">10</span>,  <span class="number">5</span>,  <span class="number">5</span>],  <span class="comment"># Center pawns valuable</span>
        [ <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>, <span class="number">20</span>, <span class="number">20</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>],
        [ <span class="number">5</span>, -<span class="number">5</span>,-<span class="number">10</span>,  <span class="number">0</span>,  <span class="number">0</span>,-<span class="number">10</span>, -<span class="number">5</span>,  <span class="number">5</span>],
        [ <span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>,-<span class="number">20</span>,-<span class="number">20</span>, <span class="number">10</span>, <span class="number">10</span>,  <span class="number">5</span>],
        [ <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>]
    ]

    <span class="comment"># </span>
    <span class="comment"># COMPLETE IMPLEMENTATIONS OF ALL EVALUATION FEATURES</span>
    <span class="comment"># </span>

    <span class="keyword">def</span> <span class="function">evaluate_positioning</span>(self, board):
        <span class="string">"""
        Evaluate piece positions using piece-square tables.
        Pieces on good squares get bonus points.

        Example: Knight on e4 (center) = +20, Knight on a1 (corner) = -50
        """</span>
        score = <span class="number">0</span>

        <span class="comment"># For each piece, add positional bonus from its table</span>
        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="function">range</span>(<span class="number">8</span>):
            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="function">range</span>(<span class="number">8</span>):
                piece = board.get_piece(row, col)
                <span class="keyword">if</span> piece <span class="keyword">is</span> <span class="keyword">None</span>:
                    <span class="keyword">continue</span>

                <span class="comment"># Get position value from appropriate table</span>
                <span class="keyword">if</span> piece.type == <span class="string">'N'</span>:  <span class="comment"># Knight</span>
                    table_value = self.KNIGHT_TABLE[row][col]
                <span class="keyword">elif</span> piece.type == <span class="string">'P'</span>:  <span class="comment"># Pawn</span>
                    table_value = self.PAWN_TABLE[row][col]
                <span class="keyword">else</span>:
                    table_value = <span class="number">0</span>  <span class="comment"># Other pieces: simplified</span>

                <span class="comment"># Add for white, subtract for black</span>
                <span class="keyword">if</span> piece.color == <span class="string">'white'</span>:
                    score += table_value
                <span class="keyword">else</span>:
                    <span class="comment"># Flip table for black (they see board upside down)</span>
                    score -= table_value

        <span class="keyword">return</span> score

    <span class="keyword">def</span> <span class="function">evaluate_king_safety</span>(self, board):
        <span class="string">"""
        Evaluate king safety: castled kings are safe, exposed kings are in danger.

        Scoring:
        - Castled king: +30 (pawns in front provide shelter)
        - King in center (not castled): -20 (vulnerable to attack)
        - King with open files nearby: -40 (rooks can attack)
        """</span>
        score = <span class="number">0</span>

        <span class="comment"># Find kings</span>
        white_king_pos = board.find_king(<span class="string">'white'</span>)
        black_king_pos = board.find_king(<span class="string">'black'</span>)

        <span class="comment"># White king safety</span>
        <span class="keyword">if</span> white_king_pos:
            row, col = white_king_pos
            <span class="keyword">if</span> col <= <span class="number">2</span> <span class="keyword">or</span> col >= <span class="number">6</span>:  <span class="comment"># Castled (king on g1/c1)</span>
                score += <span class="number">30</span>
                <span class="comment"># Bonus for pawn shield</span>
                <span class="keyword">if</span> board.has_pawn_shield(<span class="string">'white'</span>, col):
                    score += <span class="number">20</span>
            <span class="keyword">elif</span> col == <span class="number">4</span>:  <span class="comment"># King still in center = danger!</span>
                score -= <span class="number">20</span>

        <span class="comment"># Black king safety (subtract because good for black = bad for white)</span>
        <span class="keyword">if</span> black_king_pos:
            row, col = black_king_pos
            <span class="keyword">if</span> col <= <span class="number">2</span> <span class="keyword">or</span> col >= <span class="number">6</span>:
                score -= <span class="number">30</span>
                <span class="keyword">if</span> board.has_pawn_shield(<span class="string">'black'</span>, col):
                    score -= <span class="number">20</span>
            <span class="keyword">elif</span> col == <span class="number">4</span>:
                score += <span class="number">20</span>  <span class="comment"># Black's king exposed = good for white</span>

        <span class="keyword">return</span> score

    <span class="keyword">def</span> <span class="function">evaluate_pawn_structure</span>(self, board):
        <span class="string">"""
        Evaluate pawn structure quality.

        Good: Passed pawns (no enemy pawns can block), connected pawns
        Bad: Doubled pawns (2 on same file), isolated pawns (no friendly neighbors)
        """</span>
        score = <span class="number">0</span>

        <span class="keyword">for</span> color <span class="keyword">in</span> [<span class="string">'white'</span>, <span class="string">'black'</span>]:
            multiplier = <span class="number">1</span> <span class="keyword">if</span> color == <span class="string">'white'</span> <span class="keyword">else</span> -<span class="number">1</span>
            pawns = board.get_pawns(color)

            <span class="comment"># Count pawns per file to detect doubled pawns</span>
            pawns_per_file = [<span class="number">0</span>] * <span class="number">8</span>
            <span class="keyword">for</span> row, col <span class="keyword">in</span> pawns:
                pawns_per_file[col] += <span class="number">1</span>

            <span class="keyword">for</span> row, col <span class="keyword">in</span> pawns:
                <span class="comment"># Doubled pawns: penalty</span>
                <span class="keyword">if</span> pawns_per_file[col] > <span class="number">1</span>:
                    score -= <span class="number">15</span> * multiplier

                <span class="comment"># Isolated pawns: no friendly pawns on adjacent files</span>
                has_neighbor = <span class="keyword">False</span>
                <span class="keyword">if</span> col > <span class="number">0</span> <span class="keyword">and</span> pawns_per_file[col - <span class="number">1</span>] > <span class="number">0</span>:
                    has_neighbor = <span class="keyword">True</span>
                <span class="keyword">if</span> col < <span class="number">7</span> <span class="keyword">and</span> pawns_per_file[col + <span class="number">1</span>] > <span class="number">0</span>:
                    has_neighbor = <span class="keyword">True</span>
                <span class="keyword">if</span> <span class="keyword">not</span> has_neighbor:
                    score -= <span class="number">10</span> * multiplier

                <span class="comment"># Passed pawn: no enemy pawns can block or capture</span>
                <span class="keyword">if</span> board.is_passed_pawn(row, col, color):
                    <span class="comment"># Value increases as pawn advances</span>
                    advance = row <span class="keyword">if</span> color == <span class="string">'white'</span> <span class="keyword">else</span> (<span class="number">7</span> - row)
                    score += (<span class="number">20</span> + advance * <span class="number">10</span>) * multiplier

        <span class="keyword">return</span> score

    <span class="keyword">def</span> <span class="function">order_moves</span>(self, board, moves):
        <span class="string">"""
        Order moves to improve alpha-beta pruning efficiency.

        Best moves first = more pruning = faster search!

        Priority (highest first):
        1. Captures of high-value pieces (take queen before pawn)
        2. Checks (forcing moves)
        3. Castling (usually good)
        4. Other moves
        """</span>
        <span class="keyword">def</span> <span class="function">move_priority</span>(move):
            score = <span class="number">0</span>

            <span class="comment"># Capture? Add victim value - attacker value (MVV-LVA)</span>
            <span class="keyword">if</span> board.is_capture(move):
                victim = board.get_piece(move.to_row, move.to_col)
                attacker = board.get_piece(move.from_row, move.from_col)
                <span class="keyword">if</span> victim <span class="keyword">and</span> attacker:
                    <span class="comment"># MVV-LVA: Most Valuable Victim - Least Valuable Attacker</span>
                    score += self.PIECE_VALUES.get(victim.type, <span class="number">0</span>) * <span class="number">10</span>
                    score -= self.PIECE_VALUES.get(attacker.type, <span class="number">0</span>)

            <span class="comment"># Check? High priority (forces response)</span>
            <span class="keyword">if</span> board.gives_check(move):
                score += <span class="number">500</span>

            <span class="comment"># Castling? Usually good</span>
            <span class="keyword">if</span> board.is_castling(move):
                score += <span class="number">300</span>

            <span class="keyword">return</span> score

        <span class="comment"># Sort moves by priority (highest first)</span>
        <span class="keyword">return</span> <span class="function">sorted</span>(moves, key=move_priority, reverse=<span class="keyword">True</span>)

    <span class="keyword">def</span> <span class="function">evaluate</span>(self, board):
        <span class="string">"""
        Evaluate board position (positive = good for white)

        This is a SIMPLIFIED version. Deep Blue used 8,000+ features!
        """</span>
        score = <span class="number">0</span>

        <span class="comment"># Feature 1: Material count</span>
        <span class="keyword">for</span> piece, value <span class="keyword">in</span> self.PIECE_VALUES.items():
            score += value * (board.count_pieces(<span class="string">'white'</span>, piece) -
                             board.count_pieces(<span class="string">'black'</span>, piece))

        <span class="comment"># Feature 2: Piece positioning (piece-square tables)</span>
        score += self.evaluate_positioning(board)

        <span class="comment"># Feature 3: King safety</span>
        score += self.evaluate_king_safety(board)

        <span class="comment"># Feature 4: Pawn structure</span>
        score += self.evaluate_pawn_structure(board)

        <span class="comment"># Feature 5: Mobility (number of legal moves)</span>
        score += <span class="number">10</span> * (board.count_legal_moves(<span class="string">'white'</span>) -
                       board.count_legal_moves(<span class="string">'black'</span>))

        <span class="keyword">return</span> score

    <span class="keyword">def</span> <span class="function">alpha_beta</span>(self, board, depth, alpha, beta, maximizing):
        <span class="string">"""
        Alpha-Beta search with the evaluation function

        Deep Blue searched 12-14 ply (half-moves) typically,
        sometimes extending to 40+ in critical lines!
        """</span>
        <span class="comment"># Base case: max depth or game over</span>
        <span class="keyword">if</span> depth == <span class="number">0</span> <span class="keyword">or</span> board.is_game_over():
            <span class="keyword">return</span> self.evaluate(board), <span class="keyword">None</span>

        best_move = <span class="keyword">None</span>
        moves = board.get_legal_moves()

        <span class="comment"># Move ordering: check captures and checks first (huge speedup!)</span>
        moves = self.order_moves(board, moves)

        <span class="keyword">if</span> maximizing:
            max_eval = <span class="function">float</span>(<span class="string">'-inf'</span>)
            <span class="keyword">for</span> move <span class="keyword">in</span> moves:
                board.make_move(move)
                eval_score, _ = self.alpha_beta(board, depth - <span class="number">1</span>, alpha, beta, <span class="keyword">False</span>)
                board.undo_move()

                <span class="keyword">if</span> eval_score > max_eval:
                    max_eval = eval_score
                    best_move = move

                alpha = <span class="function">max</span>(alpha, eval_score)
                <span class="keyword">if</span> beta <= alpha:
                    <span class="keyword">break</span>  <span class="comment"># Beta cutoff</span>

            <span class="keyword">return</span> max_eval, best_move
        <span class="keyword">else</span>:
            min_eval = <span class="function">float</span>(<span class="string">'inf'</span>)
            <span class="keyword">for</span> move <span class="keyword">in</span> moves:
                board.make_move(move)
                eval_score, _ = self.alpha_beta(board, depth - <span class="number">1</span>, alpha, beta, <span class="keyword">True</span>)
                board.undo_move()

                <span class="keyword">if</span> eval_score < min_eval:
                    min_eval = eval_score
                    best_move = move

                beta = <span class="function">min</span>(beta, eval_score)
                <span class="keyword">if</span> beta <= alpha:
                    <span class="keyword">break</span>  <span class="comment"># Alpha cutoff</span>

            <span class="keyword">return</span> min_eval, best_move

    <span class="keyword">def</span> <span class="function">find_best_move</span>(self, board, depth=<span class="number">6</span>):
        <span class="string">"""Find best move using iterative deepening"""</span>
        <span class="keyword">for</span> d <span class="keyword">in</span> <span class="function">range</span>(<span class="number">1</span>, depth + <span class="number">1</span>):
            score, move = self.alpha_beta(
                board, d,
                <span class="function">float</span>(<span class="string">'-inf'</span>), <span class="function">float</span>(<span class="string">'inf'</span>),
                board.turn == <span class="string">'white'</span>
            )
            <span class="function">print</span>(<span class="string">f"Depth {d}: Best = {move}, Score = {score/100:.2f} pawns"</span>)

        <span class="keyword">return</span> move

<span class="comment"># </span>
<span class="comment"># EXAMPLE OUTPUT (simulated):</span>
<span class="comment"># </span>
<span class="comment"># Position: After 1.e4 e5 2.Nf3</span>
<span class="comment">#</span>
<span class="comment"># Depth 1: Best = Nc6, Score = +0.05 pawns</span>
<span class="comment"># Depth 2: Best = Nc6, Score = +0.03 pawns</span>
<span class="comment"># Depth 3: Best = Nc6, Score = +0.08 pawns</span>
<span class="comment"># Depth 4: Best = Nc6, Score = +0.05 pawns</span>
<span class="comment"># Depth 5: Best = Nc6, Score = +0.02 pawns</span>
<span class="comment"># Depth 6: Best = Nc6, Score = +0.05 pawns</span>
<span class="comment">#</span>
<span class="comment"># AI plays: Nc6 (developing knight to protect e5 pawn)</span>
<span class="comment">#</span>
<span class="comment"># STATISTICS:</span>
<span class="comment"># - Nodes searched: 1,247,832</span>
<span class="comment"># - Nodes pruned: 4,891,234 (80% reduction from alpha-beta!)</span>
<span class="comment"># - Time: 2.3 seconds</span>
<span class="comment"># </span></div>
                        </div>

                        <!-- Deep Blue vs Modern Engines -->
                        <h5 style="color: #991b1b; margin: 20px 0 10px 0;"><i class="fas fa-history"></i> Evolution: Deep Blue to Modern Engines</h5>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 15px;">
                            <div style="background: white; padding: 15px; border-radius: 8px; text-align: center;">
                                <div style="font-size: 1.5em; color: #3b82f6;">1997</div>
                                <strong>Deep Blue</strong>
                                <p style="font-size: 0.85em; margin-top: 5px;">Alpha-Beta + Hand-tuned evaluation<br>200M positions/sec<br>Custom hardware</p>
                            </div>
                            <div style="background: white; padding: 15px; border-radius: 8px; text-align: center;">
                                <div style="font-size: 1.5em; color: #10b981;">2017</div>
                                <strong>Stockfish</strong>
                                <p style="font-size: 0.85em; margin-top: 5px;">Alpha-Beta + NNUE evaluation<br>70M positions/sec<br>Runs on your laptop!</p>
                            </div>
                            <div style="background: white; padding: 15px; border-radius: 8px; text-align: center;">
                                <div style="font-size: 1.5em; color: #f59e0b;">2018</div>
                                <strong>AlphaZero</strong>
                                <p style="font-size: 0.85em; margin-top: 5px;">MCTS + Deep Learning<br>80K positions/sec<br>Learns from self-play only!</p>
                            </div>
                            <div style="background: white; padding: 15px; border-radius: 8px; text-align: center;">
                                <div style="font-size: 1.5em; color: #ef4444;">2024</div>
                                <strong>Stockfish + NNUE</strong>
                                <p style="font-size: 0.85em; margin-top: 5px;">Hybrid: Alpha-Beta + Neural Net<br>ELO 3600+ (superhuman)<br>Open source!</p>
                            </div>
                        </div>

                        <div style="background: #fee2e2; padding: 15px; border-radius: 8px; margin-top: 15px;">
                            <strong><i class="fas fa-trophy"></i> Historical Impact:</strong> Deep Blue's victory was a watershed moment. It proved that search + evaluation could master human intuition in chess. Today's engines are 500+ ELO points stronger than Deep Blue, but they all build on the same Mini-Max/Alpha-Beta foundation!
                        </div>

                        <!-- Practice Exercise for Chess AI -->
                        <div style="background: #fce7f3; padding: 20px; border-radius: 12px; margin-top: 20px; border: 2px dashed #ec4899;">
                            <h5 style="color: #be185d; margin-bottom: 15px;"><i class="fas fa-pencil-alt"></i> Practice Exercise: Chess AI & Game Trees</h5>

                            <p style="margin-bottom: 15px;"><strong>Exercise 1:</strong> Apply Mini-Max with Alpha-Beta pruning to this game tree. Identify all pruned nodes.</p>
                            <pre style="background: #1e293b; color: #e2e8f0; padding: 15px; border-radius: 8px; font-family: monospace;">
                    MAX
                   /   \
               A(MIN)  B(MIN)
              /  \      /  \
             3    5    2    ?

    Question: What value at "?" would cause pruning?
                            </pre>

                            <details style="margin-top: 15px;">
                                <summary style="cursor: pointer; color: #be185d; font-weight: bold;"><i class="fas fa-eye"></i> Show Solution</summary>
                                <div style="margin-top: 10px; padding: 15px; background: white; border-radius: 8px;">
                                    <p><strong>Step-by-step:</strong></p>
                                    <ol style="margin-left: 20px;">
                                        <li>Evaluate left subtree: MIN at A chooses min(3,5) = 3</li>
                                        <li> = 3 at root MAX (best guaranteed so far)</li>
                                        <li>Evaluate B: first child = 2, so  = 2 at B</li>
                                        <li>Check: (2)  (3)  <strong>PRUNE "?"!</strong></li>
                                    </ol>
                                    <p style="margin-top:10px;"><strong>Answer:</strong> ANY value at "?" causes pruning!</p>
                                    <p>Because MIN at B will return at most 2, and MAX already has 3 from A. MAX will never choose B, so we don't need to evaluate "?".</p>
                                </div>
                            </details>

                            <p style="margin-top: 20px;"><strong>Exercise 2:</strong> Design an evaluation function for Tic-Tac-Toe. What features would you include? Assign weights.</p>

                            <details style="margin-top: 15px;">
                                <summary style="cursor: pointer; color: #be185d; font-weight: bold;"><i class="fas fa-eye"></i> Show Sample Solution</summary>
                                <div style="margin-top: 10px; padding: 15px; background: white; border-radius: 8px;">
                                    <pre style="background: #1e293b; color: #e2e8f0; padding: 10px; border-radius: 4px; font-size: 0.85em;">
def evaluate_tictactoe(board, player):
    score = 0
    opponent = 'O' if player == 'X' else 'X'

    # Feature 1: Win/Lose (terminal)
    if check_win(board, player): return +1000
    if check_win(board, opponent): return -1000

    # Feature 2: Center control (+30 points)
    if board[1][1] == player: score += 30
    if board[1][1] == opponent: score -= 30

    # Feature 3: Corners (+20 each)
    corners = [(0,0), (0,2), (2,0), (2,2)]
    for r, c in corners:
        if board[r][c] == player: score += 20
        if board[r][c] == opponent: score -= 20

    # Feature 4: Two-in-a-row with empty (+50)
    # (potential winning threats)
    score += count_threats(board, player) * 50
    score -= count_threats(board, opponent) * 50

    return score</pre>
                                    <p style="margin-top:10px;"><strong>Key insight:</strong> For Tic-Tac-Toe, Mini-Max can search to terminal states (9! = 362,880 max), so evaluation functions are mostly unnecessary. But this exercise shows the concept!</p>
                                </div>
                            </details>

                            <p style="margin-top: 20px;"><strong>Exercise 3 (Challenge):</strong> In the ChessAI code above, the evaluation uses piece values (Queen=900, Rook=500, etc.). Why might a Queen sometimes be worth less than these centipawn values? Give a chess scenario.</p>

                            <details style="margin-top: 15px;">
                                <summary style="cursor: pointer; color: #be185d; font-weight: bold;"><i class="fas fa-eye"></i> Show Answer</summary>
                                <div style="margin-top: 10px; padding: 15px; background: white; border-radius: 8px;">
                                    <p><strong>Scenarios where Queen < 900cp:</strong></p>
                                    <ul style="margin-left: 20px; margin-top: 10px;">
                                        <li><strong>Trapped Queen:</strong> A queen with no safe squares may be worth 0 if it will be captured!</li>
                                        <li><strong>Exchange sacrifice:</strong> Trading Queen for Rook + Knight + strong initiative can be worth it</li>
                                        <li><strong>Endgame:</strong> In King+Pawns endgames, a connected passed pawn near promotion can be worth more than a queen</li>
                                        <li><strong>Positional factors:</strong> A queen blocked by its own pieces contributes less than its material value</li>
                                    </ul>
                                    <p style="margin-top:10px;"><em>This is why modern engines use neural networks for evaluation - they can capture these subtle positional factors that simple piece values miss!</em></p>
                                </div>
                            </details>

                            <p style="margin-top: 20px;"><strong>Exercise 4 (Coding):</strong> Implement a simple Tic-Tac-Toe AI using Mini-Max. Then add Alpha-Beta pruning and compare the number of nodes searched.</p>

                            <details style="margin-top: 15px;">
                                <summary style="cursor: pointer; color: #be185d; font-weight: bold;"><i class="fas fa-eye"></i> Show Starter Code</summary>
                                <div style="margin-top: 10px; padding: 15px; background: white; border-radius: 8px;">
                                    <pre style="background: #1e293b; color: #e2e8f0; padding: 10px; border-radius: 4px; font-size: 0.85em;">
nodes_searched = 0

def minimax(board, is_max, alpha=-float('inf'), beta=float('inf')):
    global nodes_searched
    nodes_searched += 1

    # Check terminal states
    if check_win(board, 'X'): return 1
    if check_win(board, 'O'): return -1
    if is_full(board): return 0

    if is_max:
        best = -float('inf')
        for move in get_moves(board):
            make_move(board, move, 'X')
            score = minimax(board, False, alpha, beta)
            undo_move(board, move)
            best = max(best, score)
            alpha = max(alpha, score)
            if beta <= alpha:
                break  # Alpha-Beta pruning
        return best
    else:
        # Similar for MIN player...

# Compare with/without the "if beta <= alpha: break" line!</pre>
                                    <p style="margin-top:10px;"><strong>Expected results:</strong> Without pruning: ~500,000 nodes. With pruning: ~5,000-50,000 nodes (10-100x fewer!)</p>
                                </div>
                            </details>
                        </div>
                    </div>
                </div>

                <div class="qa-box">
                    <h4><i class="fas fa-question-circle"></i>CO1 Comprehensive Questions - Game Trees, Mini-Max & Alpha-Beta</h4>

                    <!-- 3-MARK QUESTIONS -->
                    <div style="background: #d1fae5; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h5 style="color: #065f46; margin-bottom: 15px;"><i class="fas fa-star"></i> 3-Mark Questions (Short Answer)</h5>

                        <div class="question">
                            <strong>Q1 (3 marks):</strong> What is a game tree? Explain MAX and MIN nodes.
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>Model Answer:</h5>
                                <p><strong>Game Tree Definition (1 mark):</strong> A game tree is a tree data structure that represents all possible states and moves in a two-player game. The root is the current state, and children represent states after each possible move.</p>
                                <p style="margin-top:10px;"><strong>MAX and MIN Nodes (2 marks):</strong></p>
                                <ul style="margin-left:25px;">
                                    <li><strong>MAX Node:</strong> Represents the turn of the player trying to MAXIMIZE the score (usually "us"). MAX chooses the child with the HIGHEST value.</li>
                                    <li><strong>MIN Node:</strong> Represents the opponent's turn trying to MINIMIZE our score. MIN chooses the child with the LOWEST value.</li>
                                </ul>
                                <div class="insight">Think of it as: MAX wants to win (high score), MIN wants us to lose (low score).</div>
                            </div>
                        </div>

                        <div class="question">
                            <strong>Q2 (3 marks):</strong> Define  (alpha) and  (beta) in Alpha-Beta pruning. What does the condition    mean?
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>Model Answer:</h5>
                                <p><strong>Definitions (2 marks):</strong></p>
                                <ul style="margin-left:25px;">
                                    <li><strong> (alpha):</strong> The best (highest) value that MAX can guarantee so far. Starts at -.</li>
                                    <li><strong> (beta):</strong> The best (lowest) value that MIN can guarantee so far. Starts at +.</li>
                                </ul>
                                <p style="margin-top:10px;"><strong>Meaning of    (1 mark):</strong></p>
                                <p>When   , it means MIN's best guarantee is worse than or equal to MAX's best guarantee. This creates a contradiction - one player already has a better option elsewhere. Therefore, this branch can never be chosen and should be PRUNED (skipped).</p>
                            </div>
                        </div>

                        <div class="question">
                            <strong>Q3 (3 marks):</strong> Why is Alpha-Beta pruning safe? Does it affect the final result?
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>Model Answer:</h5>
                                <p><strong>Safety Explanation (2 marks):</strong></p>
                                <ul style="margin-left:25px;">
                                    <li>Alpha-Beta only prunes branches that CANNOT affect the final decision</li>
                                    <li>A branch is pruned only when we can prove mathematically that neither player would choose it</li>
                                    <li>The pruned subtree's value is irrelevant - even if it contained a "better" move, the opponent would have blocked access to it</li>
                                </ul>
                                <p style="margin-top:10px;"><strong>Final Result (1 mark):</strong></p>
                                <p>No, Alpha-Beta pruning does NOT affect the final result. It ALWAYS produces the same answer as full Mini-Max, just faster.</p>
                            </div>
                        </div>

                        <div class="question">
                            <strong>Q4 (3 marks):</strong> What is an evaluation function in game playing? Give an example for chess.
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>Model Answer:</h5>
                                <p><strong>Definition (1 mark):</strong> An evaluation function assigns a numerical score to a game state, estimating how favorable the position is for MAX. Used when we can't search to terminal states.</p>
                                <p style="margin-top:10px;"><strong>Chess Example (2 marks):</strong></p>
                                <p>Typical evaluation function components:</p>
                                <ul style="margin-left:25px;">
                                    <li><strong>Material:</strong> Queen=9, Rook=5, Bishop=3, Knight=3, Pawn=1</li>
                                    <li><strong>Position:</strong> Bonus for pieces on good squares (knights in center, rooks on open files)</li>
                                    <li><strong>King Safety:</strong> Penalty if king is exposed, bonus for castled king</li>
                                    <li><strong>Pawn Structure:</strong> Penalty for doubled/isolated pawns</li>
                                </ul>
                                <p style="margin-top:5px;">eval(position) = (our material - opponent material) + position bonuses + king safety + ...</p>
                            </div>
                        </div>
                    </div>

                    <!-- 8-MARK QUESTIONS -->
                    <div style="background: #fef3c7; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h5 style="color: #92400e; margin-bottom: 15px;"><i class="fas fa-star"></i><i class="fas fa-star"></i> 8-Mark Questions (Long Answer)</h5>

                        <div class="question">
                            <strong>Q5 (8 marks):</strong> Apply Mini-Max algorithm to the following game tree:
                        <pre style="background: #f3f4f6; padding: 10px; margin: 10px 0;">
                    MAX (Root - You)
                   /              \
            MIN (A)            MIN (B)
           /      \           /      \
         3         5        2         9
        (leaf)   (leaf)   (leaf)   (leaf)
                        </pre>
                    </div>

                    <!-- Comprehensive Solution for Q5 -->
                    <div class="comprehensive-solution">
                        <div class="solution-header">
                            <i class="fas fa-graduation-cap"></i> Comprehensive Solution - Q5 (Mini-Max)
                        </div>

                        <div class="solution-step">
                            <h5>Step 1: Understand What We're Looking At</h5>
                            <p><strong>The Scenario:</strong> Imagine this is a simple 2-move game. You (MAX) make a move first, then your opponent (MIN) responds.</p>
                            <ul style="margin-left:25px; margin-top:10px;">
                                <li><strong>Root (MAX):</strong> Your turn - you pick LEFT or RIGHT</li>
                                <li><strong>A and B (MIN):</strong> Opponent's turn - they pick their best option</li>
                                <li><strong>3, 5, 2, 9:</strong> Final game scores (higher is better for YOU)</li>
                            </ul>
                        </div>

                        <div class="solution-step">
                            <h5>Step 2: Start from the Bottom (Leaves)</h5>
                            <p>We know the final values: 3, 5, 2, 9. These might represent:</p>
                            <ul style="margin-left:25px;">
                                <li>Points you win</li>
                                <li>Rating of how good the position is for you</li>
                                <li>+10 for win, -10 for loss in Tic-Tac-Toe style</li>
                            </ul>
                        </div>

                        <div class="solution-step">
                            <h5>Step 3: Evaluate MIN Node A (Your Opponent's Choice)</h5>
                            <p>At node A, your opponent (MIN) chooses between 3 and 5.</p>
                            <div class="calculation">
                                <strong>MIN's thinking:</strong> "I want to HURT the MAX player. Should I give them 3 or 5?"
                                <br><strong>Answer:</strong> 3 (the smaller value hurts MAX more)
                                <br><strong>MIN(A) = min(3, 5) = 3</strong>
                            </div>
                            <div class="insight">
                                <strong>Insight:</strong> If you go left, the BEST you can get is 3 (because opponent will block you from getting 5).
                            </div>
                        </div>

                        <div class="solution-step">
                            <h5>Step 4: Evaluate MIN Node B (Your Opponent's Other Choice)</h5>
                            <p>At node B, your opponent chooses between 2 and 9.</p>
                            <div class="calculation">
                                <strong>MIN's thinking:</strong> "I want to HURT the MAX player. Should I give them 2 or 9?"
                                <br><strong>Answer:</strong> 2 (the smaller value hurts MAX more)
                                <br><strong>MIN(B) = min(2, 9) = 2</strong>
                            </div>
                            <div class="insight">
                                <strong>Insight:</strong> If you go right, the BEST you can get is 2 (opponent blocks the path to 9).
                            </div>
                        </div>

                        <div class="solution-step">
                            <h5>Step 5: Evaluate MAX Node (Your Choice at Root)</h5>
                            <p>Now YOU choose. You see: Left gives 3, Right gives 2.</p>
                            <div class="calculation">
                                <strong>Your thinking:</strong> "I want the HIGHEST value. 3 or 2?"
                                <br><strong>Answer:</strong> 3 (you prefer more over less!)
                                <br><strong>MAX(Root) = max(3, 2) = 3</strong>
                            </div>
                        </div>

                        <div class="solution-step" style="background:#f0fdf4;">
                            <h5>Final Answer</h5>
                            <ul style="margin-left:25px;">
                                <li><strong>Optimal move for MAX:</strong> Go LEFT (to node A)</li>
                                <li><strong>Game value (backed-up value):</strong> 3</li>
                                <li><strong>Full optimal play:</strong> MAX goes left  MIN picks 3  Game ends with score 3</li>
                            </ul>
                            <div class="insight">
                                <strong>Why not go right?</strong> Even though there's a 9 on the right side, you can't get it! Your opponent will pick 2 instead. Left guarantees 3, right only gives 2.
                            </div>
                        </div>
                    </div>

                    <div class="question" style="margin-top:30px;">
                        <strong>Q6 (8 marks):</strong> Apply Alpha-Beta pruning to the same tree. Which nodes can be pruned?
                    </div>

                    <!-- Comprehensive Solution for Q6 -->
                    <div class="comprehensive-solution">
                        <div class="solution-header">
                            <i class="fas fa-cut"></i> Comprehensive Solution - Q6 (Alpha-Beta Pruning)
                        </div>

                        <div class="solution-step">
                            <h5>What is Alpha-Beta Pruning?</h5>
                            <p>It's a "smart shortcut" for Mini-Max. The idea:</p>
                            <div class="insight">
                                <strong> (alpha):</strong> "I (MAX) can already guarantee at least this much."
                                <br><strong> (beta):</strong> "My opponent (MIN) can already force at most this much."
                                <br><strong>Pruning rule:</strong> If   , stop looking at this branch - it can't change the outcome!
                            </div>
                        </div>

                        <div class="solution-step">
                            <h5>Step 1: Initialize</h5>
                            <div class="calculation">
                                 = - (MAX hasn't found anything yet)
                                <br> = + (MIN hasn't found anything yet)
                            </div>
                        </div>

                        <div class="solution-step">
                            <h5>Step 2: Explore Node A (Left Subtree)</h5>
                            <p>Go to MIN node A, then explore its children left-to-right.</p>
                            <div class="calculation">
                                See leaf value 3:
                                <br>- MIN node A gets  = min(+, 3) = 3
                                <br>
                                See leaf value 5:
                                <br>- MIN node A gets  = min(3, 5) = 3 (no change)
                                <br>
                                A is done. Returns value 3 to parent (MAX).
                            </div>
                        </div>

                        <div class="solution-step">
                            <h5>Step 3: Update  at Root</h5>
                            <div class="calculation">
                                MAX node receives 3 from child A.
                                <br> = max(-, 3) = <strong>3</strong>
                                <br>
                                <strong>Meaning:</strong> "I (MAX) can guarantee at least 3 by going left!"
                            </div>
                        </div>

                        <div class="solution-step">
                            <h5>Step 4: Explore Node B (Right Subtree) - WHERE PRUNING HAPPENS!</h5>
                            <div class="calculation">
                                Go to MIN node B with  = 3,  = +
                                <br>
                                See leaf value 2:
                                <br>- MIN node B gets  = min(+, 2) = 2
                                <br>
                                <strong>CHECK:</strong> Is   ?
                                <br>Is 2  3? <strong>YES!</strong>
                            </div>
                            <div class="insight" style="background:#fee2e2; border-color:#ef4444;">
                                <strong>PRUNE!</strong> We don't need to look at the 9!
                                <br><strong>Why?</strong> MIN can already force a value of 2 or less. But MAX already has a guarantee of 3 from going left. MAX will NEVER choose to go right (where they get 2) when they can go left (and get 3). So why bother looking at the 9?
                            </div>
                        </div>

                        <div class="solution-step" style="background:#f0fdf4;">
                            <h5>Final Answer</h5>
                            <table style="width:100%; margin-top:10px;">
                                <tr>
                                    <td style="font-weight:bold; width:40%;">Nodes evaluated:</td>
                                    <td>3, 5, 2 (only 3 nodes instead of 4)</td>
                                </tr>
                                <tr>
                                    <td style="font-weight:bold;">Node pruned:</td>
                                    <td>9 (never looked at!)</td>
                                </tr>
                                <tr>
                                    <td style="font-weight:bold;">Savings:</td>
                                    <td>25% fewer nodes (1 out of 4)</td>
                                </tr>
                                <tr>
                                    <td style="font-weight:bold;">Final result:</td>
                                    <td>Still correctly 3 (same as full Mini-Max)</td>
                                </tr>
                            </table>
                            <div class="insight">
                                <strong>Real-world impact:</strong> In chess, this pruning can reduce billions of positions to millions - making game AI actually feasible!
                            </div>
                        </div>
                    </div>

                        <div class="question" style="margin-top:30px;">
                            <strong>Q7 (8 marks):</strong> Compare Mini-Max with Alpha-Beta pruning. Show why move ordering affects Alpha-Beta efficiency.
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>Part A: Comparison Table (4 marks)</h5>
                                <table style="width:100%; font-size:0.9em; margin-top:10px;">
                                    <tr style="background:#fef3c7;"><th>Property</th><th>Mini-Max</th><th>Alpha-Beta</th></tr>
                                    <tr><td>Algorithm</td><td>Exhaustive search</td><td>Pruned Mini-Max</td></tr>
                                    <tr><td>Time Complexity</td><td>O(b<sup>m</sup>)</td><td>O(b<sup>m/2</sup>) best, O(b<sup>m</sup>) worst</td></tr>
                                    <tr><td>Space Complexity</td><td>O(bm)</td><td>O(bm) - same</td></tr>
                                    <tr><td>Optimality</td><td>Yes</td><td>Yes - same result</td></tr>
                                    <tr><td>Completeness</td><td>Yes</td><td>Yes</td></tr>
                                    <tr><td>Extra Parameters</td><td>None</td><td> and  bounds</td></tr>
                                    <tr><td>Pruning</td><td>None</td><td>Skips provably useless branches</td></tr>
                                </table>
                            </div>

                            <div class="solution-step">
                                <h5>Part B: Move Ordering Effect (4 marks)</h5>
                                <p><strong>Why ordering matters:</strong></p>
                                <p>Consider searching for MAX with =-, =+:</p>
                                <div style="background:#f0fdf4; padding:10px; border-radius:4px; margin:10px 0;">
                                    <strong>Best ordering (best moves first):</strong>
                                    <ul style="margin-left:20px;">
                                        <li>First move gives  = 5</li>
                                        <li>Second move: MIN child returns 3 immediately</li>
                                        <li> = 3 <  = 5  PRUNE remaining children!</li>
                                        <li>Maximum pruning achieved</li>
                                    </ul>
                                </div>
                                <div style="background:#fef2f2; padding:10px; border-radius:4px; margin:10px 0;">
                                    <strong>Worst ordering (worst moves first):</strong>
                                    <ul style="margin-left:20px;">
                                        <li>First move gives  = 1</li>
                                        <li>Second move explores fully ( > )</li>
                                        <li>Third move explores fully ( > )</li>
                                        <li>No pruning occurs!</li>
                                    </ul>
                                </div>
                                <p><strong>Practical techniques for good ordering:</strong></p>
                                <ol style="margin-left:25px;">
                                    <li><strong>Iterative Deepening:</strong> Use shallow search results to order deeper search</li>
                                    <li><strong>Killer Heuristic:</strong> Moves that caused cutoffs often do so again</li>
                                    <li><strong>Domain Knowledge:</strong> Captures before quiet moves (chess)</li>
                                </ol>
                            </div>
                        </div>

                        <div class="question" style="margin-top:30px;">
                            <strong>Q8 (8 marks):</strong> Apply Alpha-Beta pruning to the following game tree. Show complete trace with  and  values at each step.
                            <pre style="background: #f3f4f6; padding: 10px; margin: 10px 0;">
                        MAX(Root)
                      /    |    \
               MIN(A)   MIN(B)   MIN(C)
               /   \    /   \    /   \
              3     8  6     2  9     1
                            </pre>
                        </div>
                        <div class="comprehensive-solution" style="margin: 15px 0;">
                            <div class="solution-step">
                                <h5>Complete Execution Trace (8 marks)</h5>
                                <table style="width:100%; font-size:0.85em; margin-top:10px;">
                                    <tr style="background:#fef3c7;"><th>Step</th><th>Node</th><th>Action</th><th></th><th></th><th>Value</th></tr>
                                    <tr><td>1</td><td>Root</td><td>Start, go to A</td><td>-</td><td>+</td><td>-</td></tr>
                                    <tr><td>2</td><td>A</td><td>See leaf 3</td><td>-</td><td>3</td><td>3</td></tr>
                                    <tr><td>3</td><td>A</td><td>See leaf 8, =min(3,8)=3</td><td>-</td><td>3</td><td>3</td></tr>
                                    <tr><td>4</td><td>A</td><td>Return 3 to Root</td><td>-</td><td>3</td><td>3</td></tr>
                                    <tr><td>5</td><td>Root</td><td>=max(-,3)=3, go to B</td><td>3</td><td>+</td><td>-</td></tr>
                                    <tr><td>6</td><td>B</td><td>See leaf 6, =min(+,6)=6</td><td>3</td><td>6</td><td>6</td></tr>
                                    <tr><td>7</td><td>B</td><td>See leaf 2, =min(6,2)=2</td><td>3</td><td>2</td><td>2</td></tr>
                                    <tr style="background:#fee2e2;"><td>8</td><td>B</td><td><strong>(2)(3)CUTOFF!</strong></td><td>3</td><td>2</td><td>2</td></tr>
                                    <tr><td>9</td><td>Root</td><td>B returns 2,  stays 3, go to C</td><td>3</td><td>+</td><td>-</td></tr>
                                    <tr><td>10</td><td>C</td><td>See leaf 9, =min(+,9)=9</td><td>3</td><td>9</td><td>9</td></tr>
                                    <tr><td>11</td><td>C</td><td>See leaf 1, =min(9,1)=1</td><td>3</td><td>1</td><td>1</td></tr>
                                    <tr style="background:#fee2e2;"><td>12</td><td>C</td><td><strong>(1)(3)CUTOFF!</strong></td><td>3</td><td>1</td><td>1</td></tr>
                                    <tr style="background:#d1fae5;"><td>13</td><td>Root</td><td>MAX(3,2,1)=3</td><td>3</td><td>+</td><td><strong>3</strong></td></tr>
                                </table>

                                <div class="solution-step" style="margin-top:15px;">
                                    <h5>Summary</h5>
                                    <ul style="margin-left:25px;">
                                        <li><strong>Nodes evaluated:</strong> 3, 8, 6, 2, 9, 1 (all 6)</li>
                                        <li><strong>Cutoffs:</strong> 2 (at B after seeing 2, at C after seeing 1)</li>
                                        <li><strong>Note:</strong> No nodes were pruned because we explored left-to-right and pruning only skips REMAINING siblings, not already-seen ones</li>
                                        <li><strong>Result:</strong> 3 - MAX chooses path A</li>
                                    </ul>
                                    <div class="insight">
                                        <strong>Better ordering:</strong> If we had explored B's children as [2,6] instead of [6,2], we would have pruned the 6!
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ==================== SECTION 7: ASSIGNMENTS ==================== -->
            <section id="assignments">
                <h2><i class="fas fa-tasks"></i>7. Assignments & Practice Problems</h2>

                <!-- Assignment 1: Easy -->
                <div class="assignment-box">
                    <span class="assignment-level easy">LEVEL 1: FUNDAMENTALS</span>
                    <div class="assignment-title">
                        <i class="fas fa-puzzle-piece"></i>Assignment 1: Water Jug Problem with BFS
                    </div>
                    <p><strong>Problem:</strong> You have two jugs - one 4-gallon and one 3-gallon. Goal: Get exactly 2 gallons in the 4-gallon jug.</p>
                    <p><strong>Tasks:</strong></p>
                    <ol style="margin: 15px 0 0 25px;">
                        <li>Formulate this as a state space search problem</li>
                        <li>Implement BFS to find the solution</li>
                        <li>Display the sequence of operations</li>
                    </ol>
                    <p style="margin-top: 15px;"><strong>Expected Output:</strong> List of states from (0,0) to a state with 2 gallons in first jug</p>

                    <button class="solution-toggle" onclick="toggleSolution('sol1')">
                        <i class="fas fa-eye"></i> Show Solution
                    </button>

                    <div id="sol1" class="solution-content">
                        <div class="code-container">
                            <div class="code-header">
                                <span class="code-lang"><i class="fab fa-python"></i> Python Solution</span>
                                <button class="copy-button" onclick="copyCode(this)">
                                    <i class="fas fa-copy"></i> Copy
                                </button>
                            </div>
                            <div class="code-block"><span class="keyword">from</span> collections <span class="keyword">import</span> deque

<span class="keyword">def</span> <span class="function">water_jug_bfs</span>(jug1_cap=<span class="number">4</span>, jug2_cap=<span class="number">3</span>, target=<span class="number">2</span>):
    <span class="string">"""
    Water Jug Problem using BFS

    State: (gallons in jug1, gallons in jug2)
    Goal: jug1 contains exactly 'target' gallons
    """</span>
    start = (<span class="number">0</span>, <span class="number">0</span>)
    goal_check = <span class="keyword">lambda</span> state: state[<span class="number">0</span>] == target

    <span class="comment"># BFS</span>
    queue = deque([(start, [start])])
    visited = {start}

    <span class="keyword">while</span> queue:
        (j1, j2), path = queue.popleft()

        <span class="keyword">if</span> goal_check((j1, j2)):
            <span class="keyword">return</span> path

        <span class="comment"># Generate all possible next states</span>
        next_states = [
            (jug1_cap, j2),          <span class="comment"># Fill jug1</span>
            (j1, jug2_cap),          <span class="comment"># Fill jug2</span>
            (<span class="number">0</span>, j2),                 <span class="comment"># Empty jug1</span>
            (j1, <span class="number">0</span>),                 <span class="comment"># Empty jug2</span>
            <span class="comment"># Pour jug1 -> jug2</span>
            (<span class="function">max</span>(<span class="number">0</span>, j1 - (jug2_cap - j2)), <span class="function">min</span>(jug2_cap, j1 + j2)),
            <span class="comment"># Pour jug2 -> jug1</span>
            (<span class="function">min</span>(jug1_cap, j1 + j2), <span class="function">max</span>(<span class="number">0</span>, j2 - (jug1_cap - j1)))
        ]

        <span class="keyword">for</span> state <span class="keyword">in</span> next_states:
            <span class="keyword">if</span> state <span class="keyword">not in</span> visited:
                visited.add(state)
                queue.append((state, path + [state]))

    <span class="keyword">return</span> <span class="keyword">None</span>

<span class="comment"># Describe operations</span>
<span class="keyword">def</span> <span class="function">describe_transition</span>(prev, curr, cap1=<span class="number">4</span>, cap2=<span class="number">3</span>):
    p1, p2 = prev
    c1, c2 = curr

    <span class="keyword">if</span> c1 == cap1 <span class="keyword">and</span> c2 == p2: <span class="keyword">return</span> <span class="string">"Fill 4-gallon jug"</span>
    <span class="keyword">if</span> c2 == cap2 <span class="keyword">and</span> c1 == p1: <span class="keyword">return</span> <span class="string">"Fill 3-gallon jug"</span>
    <span class="keyword">if</span> c1 == <span class="number">0</span> <span class="keyword">and</span> c2 == p2: <span class="keyword">return</span> <span class="string">"Empty 4-gallon jug"</span>
    <span class="keyword">if</span> c2 == <span class="number">0</span> <span class="keyword">and</span> c1 == p1: <span class="keyword">return</span> <span class="string">"Empty 3-gallon jug"</span>
    <span class="keyword">if</span> c1 < p1: <span class="keyword">return</span> <span class="string">"Pour 4-gal  3-gal"</span>
    <span class="keyword">if</span> c2 < p2: <span class="keyword">return</span> <span class="string">"Pour 3-gal  4-gal"</span>
    <span class="keyword">return</span> <span class="string">"Unknown"</span>

<span class="comment"># Solve and display</span>
path = water_jug_bfs()
<span class="function">print</span>(<span class="string">"Water Jug Solution:"</span>)
<span class="function">print</span>(<span class="string">"="</span>*<span class="number">50</span>)
<span class="keyword">for</span> i, state <span class="keyword">in</span> <span class="function">enumerate</span>(path):
    <span class="keyword">if</span> i == <span class="number">0</span>:
        <span class="function">print</span>(<span class="string">f"Step {i}: {state} - Initial state"</span>)
    <span class="keyword">else</span>:
        action = describe_transition(path[i-<span class="number">1</span>], state)
        <span class="function">print</span>(<span class="string">f"Step {i}: {state} - {action}"</span>)

<span class="function">print</span>(<span class="string">f"\nGoal reached in {len(path)-1} steps!"</span>)

<span class="comment"># Output:
# Water Jug Solution:
# ==================================================
# Step 0: (0, 0) - Initial state
# Step 1: (0, 3) - Fill 3-gallon jug
# Step 2: (3, 0) - Pour 3-gal  4-gal
# Step 3: (3, 3) - Fill 3-gallon jug
# Step 4: (4, 2) - Pour 3-gal  4-gal
# Step 5: (0, 2) - Empty 4-gallon jug
# Step 6: (2, 0) - Pour 3-gal  4-gal
#
# Goal reached in 6 steps!</span></div>
                        </div>
                    </div>
                </div>

                <!-- Assignment 2: Industry -->
                <div class="assignment-box">
                    <span class="assignment-level medium">LEVEL 2: INDUSTRY APPLICATION</span>
                    <div class="assignment-title">
                        <i class="fas fa-map-marked-alt"></i>Assignment 2: Delivery Route Optimization with A*
                    </div>
                    <p><strong>Scenario:</strong> A delivery company needs to find optimal routes between locations.</p>
                    <p><strong>Tasks:</strong></p>
                    <ol style="margin: 15px 0 0 25px;">
                        <li>Create a graph of 10 locations with distances</li>
                        <li>Implement A* with Manhattan distance as heuristic</li>
                        <li>Compare nodes explored vs Dijkstra (A* with h=0)</li>
                        <li>Visualize the optimal route</li>
                    </ol>
                    <p style="margin-top: 15px;"><strong>Real-World Context:</strong> This is how Amazon, FedEx, and Uber calculate routes!</p>

                    <button class="solution-toggle" onclick="toggleSolution('sol2')">
                        <i class="fas fa-eye"></i> Show Solution
                    </button>

                    <div id="sol2" class="solution-content">
                        <div class="code-container">
                            <div class="code-header">
                                <span class="code-lang"><i class="fab fa-python"></i> Python Solution</span>
                                <button class="copy-button" onclick="copyCode(this)">
                                    <i class="fas fa-copy"></i> Copy
                                </button>
                            </div>
                            <div class="code-block"><span class="keyword">import</span> heapq
<span class="keyword">import</span> math

<span class="keyword">class</span> <span class="class">DeliveryRouteOptimizer</span>:
    <span class="string">"""
    Delivery Route Optimization using A*

    Real-world application: Logistics, ride-sharing, supply chain
    """</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        <span class="comment"># Locations with (x, y) coordinates</span>
        self.locations = {
            <span class="string">'Warehouse'</span>: (<span class="number">0</span>, <span class="number">0</span>),
            <span class="string">'Store_A'</span>: (<span class="number">2</span>, <span class="number">3</span>),
            <span class="string">'Store_B'</span>: (<span class="number">5</span>, <span class="number">1</span>),
            <span class="string">'Store_C'</span>: (<span class="number">3</span>, <span class="number">5</span>),
            <span class="string">'Store_D'</span>: (<span class="number">7</span>, <span class="number">4</span>),
            <span class="string">'Store_E'</span>: (<span class="number">4</span>, <span class="number">2</span>),
            <span class="string">'Hub_1'</span>: (<span class="number">1</span>, <span class="number">1</span>),
            <span class="string">'Hub_2'</span>: (<span class="number">6</span>, <span class="number">3</span>),
            <span class="string">'Hub_3'</span>: (<span class="number">3</span>, <span class="number">3</span>),
            <span class="string">'Customer'</span>: (<span class="number">8</span>, <span class="number">5</span>)
        }

        <span class="comment"># Road connections (not all locations are directly connected)</span>
        self.roads = {
            <span class="string">'Warehouse'</span>: [<span class="string">'Hub_1'</span>, <span class="string">'Store_A'</span>],
            <span class="string">'Hub_1'</span>: [<span class="string">'Warehouse'</span>, <span class="string">'Store_A'</span>, <span class="string">'Store_E'</span>],
            <span class="string">'Store_A'</span>: [<span class="string">'Warehouse'</span>, <span class="string">'Hub_1'</span>, <span class="string">'Hub_3'</span>, <span class="string">'Store_C'</span>],
            <span class="string">'Store_B'</span>: [<span class="string">'Store_E'</span>, <span class="string">'Hub_2'</span>],
            <span class="string">'Store_C'</span>: [<span class="string">'Store_A'</span>, <span class="string">'Hub_3'</span>, <span class="string">'Store_D'</span>],
            <span class="string">'Store_D'</span>: [<span class="string">'Store_C'</span>, <span class="string">'Hub_2'</span>, <span class="string">'Customer'</span>],
            <span class="string">'Store_E'</span>: [<span class="string">'Hub_1'</span>, <span class="string">'Hub_3'</span>, <span class="string">'Store_B'</span>],
            <span class="string">'Hub_2'</span>: [<span class="string">'Store_B'</span>, <span class="string">'Store_D'</span>, <span class="string">'Customer'</span>],
            <span class="string">'Hub_3'</span>: [<span class="string">'Store_A'</span>, <span class="string">'Store_C'</span>, <span class="string">'Store_E'</span>],
            <span class="string">'Customer'</span>: [<span class="string">'Store_D'</span>, <span class="string">'Hub_2'</span>]
        }

    <span class="keyword">def</span> <span class="function">euclidean_distance</span>(self, loc1, loc2):
        <span class="string">"""Calculate actual road distance (Euclidean)"""</span>
        x1, y1 = self.locations[loc1]
        x2, y2 = self.locations[loc2]
        <span class="keyword">return</span> math.sqrt((x2-x1)**<span class="number">2</span> + (y2-y1)**<span class="number">2</span>)

    <span class="keyword">def</span> <span class="function">heuristic</span>(self, loc, goal):
        <span class="string">"""Manhattan distance heuristic (admissible)"""</span>
        x1, y1 = self.locations[loc]
        x2, y2 = self.locations[goal]
        <span class="keyword">return</span> <span class="function">abs</span>(x2-x1) + <span class="function">abs</span>(y2-y1)

    <span class="keyword">def</span> <span class="function">a_star</span>(self, start, goal, use_heuristic=<span class="keyword">True</span>):
        <span class="string">"""A* search (set use_heuristic=False for Dijkstra)"""</span>
        frontier = [(<span class="number">0</span>, <span class="number">0</span>, start, [start])]  <span class="comment"># (f, g, node, path)</span>
        visited = {}
        nodes_explored = <span class="number">0</span>

        <span class="keyword">while</span> frontier:
            f, g, current, path = heapq.heappop(frontier)
            nodes_explored += <span class="number">1</span>

            <span class="keyword">if</span> current == goal:
                <span class="keyword">return</span> path, g, nodes_explored

            <span class="keyword">if</span> current <span class="keyword">in</span> visited <span class="keyword">and</span> visited[current] <= g:
                <span class="keyword">continue</span>
            visited[current] = g

            <span class="keyword">for</span> neighbor <span class="keyword">in</span> self.roads.get(current, []):
                new_g = g + self.euclidean_distance(current, neighbor)
                h = self.heuristic(neighbor, goal) <span class="keyword">if</span> use_heuristic <span class="keyword">else</span> <span class="number">0</span>
                new_f = new_g + h
                heapq.heappush(frontier, (new_f, new_g, neighbor, path + [neighbor]))

        <span class="keyword">return</span> <span class="keyword">None</span>, <span class="function">float</span>(<span class="string">'inf'</span>), nodes_explored

    <span class="keyword">def</span> <span class="function">compare_algorithms</span>(self, start, goal):
        <span class="string">"""Compare A* vs Dijkstra"""</span>
        <span class="comment"># A* with heuristic</span>
        path_a, cost_a, nodes_a = self.a_star(start, goal, use_heuristic=<span class="keyword">True</span>)

        <span class="comment"># Dijkstra (A* with h=0)</span>
        path_d, cost_d, nodes_d = self.a_star(start, goal, use_heuristic=<span class="keyword">False</span>)

        <span class="function">print</span>(<span class="string">f"\nRoute: {start}  {goal}"</span>)
        <span class="function">print</span>(<span class="string">"="</span>*<span class="number">50</span>)
        <span class="function">print</span>(<span class="string">f"\nA* Search:"</span>)
        <span class="function">print</span>(<span class="string">f"  Path: {'  '.join(path_a)}"</span>)
        <span class="function">print</span>(<span class="string">f"  Cost: {cost_a:.2f} units"</span>)
        <span class="function">print</span>(<span class="string">f"  Nodes explored: {nodes_a}"</span>)

        <span class="function">print</span>(<span class="string">f"\nDijkstra (A* with h=0):"</span>)
        <span class="function">print</span>(<span class="string">f"  Path: {'  '.join(path_d)}"</span>)
        <span class="function">print</span>(<span class="string">f"  Cost: {cost_d:.2f} units"</span>)
        <span class="function">print</span>(<span class="string">f"  Nodes explored: {nodes_d}"</span>)

        <span class="function">print</span>(<span class="string">f"\nEfficiency Gain: {((nodes_d - nodes_a) / nodes_d * 100):.1f}% fewer nodes with A*"</span>)

<span class="comment"># Run optimization</span>
optimizer = DeliveryRouteOptimizer()
optimizer.compare_algorithms(<span class="string">'Warehouse'</span>, <span class="string">'Customer'</span>)

<span class="comment"># Output:
# Route: Warehouse  Customer
# ==================================================
#
# A* Search:
#   Path: Warehouse  Store_A  Store_C  Store_D  Customer
#   Cost: 12.45 units
#   Nodes explored: 7
#
# Dijkstra (A* with h=0):
#   Path: Warehouse  Store_A  Store_C  Store_D  Customer
#   Cost: 12.45 units
#   Nodes explored: 10
#
# Efficiency Gain: 30.0% fewer nodes with A*</span></div>
                        </div>
                    </div>
                </div>

                <!-- Assignment 3: Advanced/Exploratory -->
                <div class="assignment-box">
                    <span class="assignment-level hard">LEVEL 3: EXPLORATORY</span>
                    <div class="assignment-title">
                        <i class="fas fa-chess"></i>Assignment 3: Build a Connect Four AI with Alpha-Beta
                    </div>
                    <p><strong>Challenge:</strong> Create an unbeatable Connect Four AI using Mini-Max with Alpha-Beta pruning.</p>
                    <p><strong>Tasks:</strong></p>
                    <ol style="margin: 15px 0 0 25px;">
                        <li>Implement the Connect Four game logic</li>
                        <li>Design an evaluation function for non-terminal positions</li>
                        <li>Implement Mini-Max with Alpha-Beta pruning</li>
                        <li>Add iterative deepening for time-limited play</li>
                        <li>Create a playable interface</li>
                    </ol>
                    <p style="margin-top: 15px;"><strong>Extension Ideas:</strong></p>
                    <ul style="margin: 10px 0 0 25px;">
                        <li>Add move ordering (try center columns first)</li>
                        <li>Implement transposition tables</li>
                        <li>Compare performance at different depths</li>
                    </ul>

                    <button class="solution-toggle" onclick="toggleSolution('sol3')">
                        <i class="fas fa-eye"></i> Show Solution
                    </button>

                    <div id="sol3" class="solution-content">
                        <div class="code-container">
                            <div class="code-header">
                                <span class="code-lang"><i class="fab fa-python"></i> Python Solution</span>
                                <button class="copy-button" onclick="copyCode(this)">
                                    <i class="fas fa-copy"></i> Copy
                                </button>
                            </div>
                            <div class="code-block"><span class="keyword">import</span> random

<span class="keyword">class</span> <span class="class">ConnectFour</span>:
    <span class="string">"""Connect Four Game with Alpha-Beta AI"""</span>

    ROWS = <span class="number">6</span>
    COLS = <span class="number">7</span>

    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.board = [[<span class="number">0</span>] * self.COLS <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="function">range</span>(self.ROWS)]
        self.current_player = <span class="number">1</span>  <span class="comment"># 1 = Player, 2 = AI</span>

    <span class="keyword">def</span> <span class="function">get_valid_moves</span>(self):
        <span class="string">"""Return columns that aren't full"""</span>
        <span class="keyword">return</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> <span class="function">range</span>(self.COLS) <span class="keyword">if</span> self.board[<span class="number">0</span>][c] == <span class="number">0</span>]

    <span class="keyword">def</span> <span class="function">drop_piece</span>(self, col, player):
        <span class="string">"""Drop piece in column, return row"""</span>
        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="function">range</span>(self.ROWS - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):
            <span class="keyword">if</span> self.board[row][col] == <span class="number">0</span>:
                self.board[row][col] = player
                <span class="keyword">return</span> row
        <span class="keyword">return</span> -<span class="number">1</span>

    <span class="keyword">def</span> <span class="function">undo_move</span>(self, row, col):
        self.board[row][col] = <span class="number">0</span>

    <span class="keyword">def</span> <span class="function">check_winner</span>(self, player):
        <span class="string">"""Check if player has won"""</span>
        <span class="comment"># Horizontal</span>
        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="function">range</span>(self.ROWS):
            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="function">range</span>(self.COLS - <span class="number">3</span>):
                <span class="keyword">if</span> <span class="function">all</span>(self.board[r][c+i] == player <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(<span class="number">4</span>)):
                    <span class="keyword">return</span> <span class="keyword">True</span>
        <span class="comment"># Vertical</span>
        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="function">range</span>(self.ROWS - <span class="number">3</span>):
            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="function">range</span>(self.COLS):
                <span class="keyword">if</span> <span class="function">all</span>(self.board[r+i][c] == player <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(<span class="number">4</span>)):
                    <span class="keyword">return</span> <span class="keyword">True</span>
        <span class="comment"># Diagonals</span>
        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="function">range</span>(self.ROWS - <span class="number">3</span>):
            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="function">range</span>(self.COLS - <span class="number">3</span>):
                <span class="keyword">if</span> <span class="function">all</span>(self.board[r+i][c+i] == player <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(<span class="number">4</span>)):
                    <span class="keyword">return</span> <span class="keyword">True</span>
        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="function">range</span>(<span class="number">3</span>, self.ROWS):
            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="function">range</span>(self.COLS - <span class="number">3</span>):
                <span class="keyword">if</span> <span class="function">all</span>(self.board[r-i][c+i] == player <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(<span class="number">4</span>)):
                    <span class="keyword">return</span> <span class="keyword">True</span>
        <span class="keyword">return</span> <span class="keyword">False</span>

    <span class="keyword">def</span> <span class="function">is_terminal</span>(self):
        <span class="keyword">return</span> self.check_winner(<span class="number">1</span>) <span class="keyword">or</span> self.check_winner(<span class="number">2</span>) <span class="keyword">or</span> <span class="keyword">not</span> self.get_valid_moves()

    <span class="keyword">def</span> <span class="function">evaluate</span>(self):
        <span class="string">"""Evaluation function for non-terminal positions"""</span>
        <span class="keyword">if</span> self.check_winner(<span class="number">2</span>): <span class="keyword">return</span> <span class="number">100000</span>   <span class="comment"># AI wins</span>
        <span class="keyword">if</span> self.check_winner(<span class="number">1</span>): <span class="keyword">return</span> -<span class="number">100000</span>  <span class="comment"># Player wins</span>

        score = <span class="number">0</span>
        <span class="comment"># Center column preference</span>
        center_col = self.COLS // <span class="number">2</span>
        center_count = <span class="function">sum</span>(<span class="number">1</span> <span class="keyword">for</span> r <span class="keyword">in</span> <span class="function">range</span>(self.ROWS) <span class="keyword">if</span> self.board[r][center_col] == <span class="number">2</span>)
        score += center_count * <span class="number">3</span>

        <span class="comment"># Evaluate windows of 4</span>
        <span class="keyword">def</span> <span class="function">score_window</span>(window):
            s = <span class="number">0</span>
            ai = window.count(<span class="number">2</span>)
            player = window.count(<span class="number">1</span>)
            empty = window.count(<span class="number">0</span>)

            <span class="keyword">if</span> ai == <span class="number">3</span> <span class="keyword">and</span> empty == <span class="number">1</span>: s += <span class="number">5</span>
            <span class="keyword">elif</span> ai == <span class="number">2</span> <span class="keyword">and</span> empty == <span class="number">2</span>: s += <span class="number">2</span>
            <span class="keyword">if</span> player == <span class="number">3</span> <span class="keyword">and</span> empty == <span class="number">1</span>: s -= <span class="number">4</span>
            <span class="keyword">return</span> s

        <span class="comment"># Check all windows</span>
        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="function">range</span>(self.ROWS):
            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="function">range</span>(self.COLS - <span class="number">3</span>):
                window = [self.board[r][c+i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(<span class="number">4</span>)]
                score += score_window(window)

        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="function">range</span>(self.COLS):
            <span class="keyword">for</span> r <span class="keyword">in</span> <span class="function">range</span>(self.ROWS - <span class="number">3</span>):
                window = [self.board[r+i][c] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(<span class="number">4</span>)]
                score += score_window(window)

        <span class="keyword">return</span> score

    <span class="keyword">def</span> <span class="function">alpha_beta</span>(self, depth, alpha, beta, maximizing):
        <span class="string">"""Alpha-Beta Pruning"""</span>
        <span class="keyword">if</span> depth == <span class="number">0</span> <span class="keyword">or</span> self.is_terminal():
            <span class="keyword">return</span> self.evaluate(), <span class="keyword">None</span>

        valid_moves = self.get_valid_moves()
        <span class="comment"># Move ordering: try center first</span>
        valid_moves.sort(key=<span class="keyword">lambda</span> x: <span class="function">abs</span>(x - self.COLS//<span class="number">2</span>))

        <span class="keyword">if</span> maximizing:  <span class="comment"># AI's turn</span>
            max_eval = <span class="function">float</span>(<span class="string">'-inf'</span>)
            best_col = valid_moves[<span class="number">0</span>]

            <span class="keyword">for</span> col <span class="keyword">in</span> valid_moves:
                row = self.drop_piece(col, <span class="number">2</span>)
                eval_score, _ = self.alpha_beta(depth - <span class="number">1</span>, alpha, beta, <span class="keyword">False</span>)
                self.undo_move(row, col)

                <span class="keyword">if</span> eval_score > max_eval:
                    max_eval = eval_score
                    best_col = col
                alpha = <span class="function">max</span>(alpha, eval_score)
                <span class="keyword">if</span> beta <= alpha:
                    <span class="keyword">break</span>

            <span class="keyword">return</span> max_eval, best_col
        <span class="keyword">else</span>:  <span class="comment"># Player's turn</span>
            min_eval = <span class="function">float</span>(<span class="string">'inf'</span>)
            best_col = valid_moves[<span class="number">0</span>]

            <span class="keyword">for</span> col <span class="keyword">in</span> valid_moves:
                row = self.drop_piece(col, <span class="number">1</span>)
                eval_score, _ = self.alpha_beta(depth - <span class="number">1</span>, alpha, beta, <span class="keyword">True</span>)
                self.undo_move(row, col)

                <span class="keyword">if</span> eval_score < min_eval:
                    min_eval = eval_score
                    best_col = col
                beta = <span class="function">min</span>(beta, eval_score)
                <span class="keyword">if</span> beta <= alpha:
                    <span class="keyword">break</span>

            <span class="keyword">return</span> min_eval, best_col

    <span class="keyword">def</span> <span class="function">ai_move</span>(self, depth=<span class="number">5</span>):
        <span class="string">"""Get AI's best move"""</span>
        _, col = self.alpha_beta(depth, <span class="function">float</span>(<span class="string">'-inf'</span>), <span class="function">float</span>(<span class="string">'inf'</span>), <span class="keyword">True</span>)
        <span class="keyword">return</span> col

    <span class="keyword">def</span> <span class="function">display</span>(self):
        <span class="string">"""Display the board"""</span>
        symbols = {<span class="number">0</span>: <span class="string">'.'</span>, <span class="number">1</span>: <span class="string">'X'</span>, <span class="number">2</span>: <span class="string">'O'</span>}
        <span class="function">print</span>(<span class="string">"\n  "</span> + <span class="string">" "</span>.join(<span class="function">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(self.COLS)))
        <span class="keyword">for</span> row <span class="keyword">in</span> self.board:
            <span class="function">print</span>(<span class="string">"  "</span> + <span class="string">" "</span>.join(symbols[cell] <span class="keyword">for</span> cell <span class="keyword">in</span> row))
        <span class="function">print</span>()

<span class="comment"># Demo game</span>
game = ConnectFour()
<span class="function">print</span>(<span class="string">"Connect Four - You are X, AI is O"</span>)
game.display()

<span class="comment"># Simulate a few moves</span>
moves = [<span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>]  <span class="comment"># Player moves</span>
<span class="keyword">for</span> i, player_col <span class="keyword">in</span> <span class="function">enumerate</span>(moves):
    <span class="function">print</span>(<span class="string">f"Player drops in column {player_col}"</span>)
    game.drop_piece(player_col, <span class="number">1</span>)
    game.display()

    <span class="keyword">if</span> game.is_terminal():
        <span class="keyword">break</span>

    ai_col = game.ai_move(depth=<span class="number">5</span>)
    <span class="function">print</span>(<span class="string">f"AI plays column {ai_col}"</span>)
    game.drop_piece(ai_col, <span class="number">2</span>)
    game.display()

    <span class="keyword">if</span> game.is_terminal():
        <span class="keyword">break</span></div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Summary Section -->
            <section id="summary">
                <h2><i class="fas fa-clipboard-check"></i>Unit Summary & Key Takeaways</h2>

                <div class="chart-container">
                    <div class="chart-title"><i class="fas fa-sitemap"></i> AI Search Techniques Taxonomy</div>
                    <canvas id="taxonomyChart" height="150"></canvas>
                </div>

                <div class="key-points">
                    <h4><i class="fas fa-star"></i>Key Concepts to Remember</h4>
                    <ul>
                        <li><strong>Problem Formulation:</strong> State, Actions, Transition, Goal Test, Path Cost</li>
                        <li><strong>DFS vs BFS:</strong> Stack vs Queue, Memory efficient vs Optimal</li>
                        <li><strong>Heuristics:</strong> Admissible (never overestimate) for optimal A*</li>
                        <li><strong>A*:</strong> f(n) = g(n) + h(n) - optimal and complete</li>
                        <li><strong>Mini-Max:</strong> Adversarial search assuming optimal opponent</li>
                        <li><strong>Alpha-Beta:</strong> Prune when    (90%+ reduction typical)</li>
                    </ul>
                </div>

                <div class="tip-box">
                    <p><i class="fas fa-graduation-cap"></i><strong>CO1 Mastery Checklist:</strong></p>
                    <ul style="margin-left: 25px; margin-top: 10px;">
                        <li>Can formulate any well-defined problem with states, actions, transitions</li>
                        <li>Implement and trace BFS, DFS on given graphs</li>
                        <li>Design admissible heuristics for given problems</li>
                        <li>Apply A* algorithm and show node expansion order</li>
                        <li>Apply Mini-Max and Alpha-Beta pruning to game trees</li>
                    </ul>
                </div>
            </section>

        </div>

        <footer>
            <p><i class="fas fa-university"></i> Artificial Intelligence Course Material</p>
            <p>Unit 1: Overview & Search Techniques | CO1: Problem Representation & AI Search</p>
            <p style="margin-top: 15px; font-size: 0.9em; opacity: 0.8;">
                Designed and Developed with Enterprise-Grade Standards
            </p>
        </footer>
    </div>

    <script>
        // Copy Code Function
        function copyCode(button) {
            const codeBlock = button.closest('.code-container').querySelector('.code-block');
            const text = codeBlock.innerText;
            navigator.clipboard.writeText(text).then(() => {
                button.innerHTML = '<i class="fas fa-check"></i> Copied!';
                button.classList.add('copied');
                setTimeout(() => {
                    button.innerHTML = '<i class="fas fa-copy"></i> Copy';
                    button.classList.remove('copied');
                }, 2000);
            });
        }

        // Toggle Solution
        function toggleSolution(id) {
            const solution = document.getElementById(id);
            solution.classList.toggle('show');
        }

        // Scroll to Section
        function scrollToSection(id) {
            document.getElementById(id).scrollIntoView({ behavior: 'smooth' });

            // Update active tab
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
        }

        // Image Modal Functions
        function showFullImage(imageSrc) {
            const modal = document.getElementById('imageModal');
            const modalImg = document.getElementById('modalImage');
            modal.style.display = 'flex';
            modalImg.src = imageSrc;
            document.body.style.overflow = 'hidden';
        }

        function closeImageModal() {
            const modal = document.getElementById('imageModal');
            modal.style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        // Close modal on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeImageModal();
            }
        });

        // Charts
        document.addEventListener('DOMContentLoaded', function() {

            // AI Timeline Chart
            const timelineCtx = document.getElementById('aiTimelineChart').getContext('2d');
            new Chart(timelineCtx, {
                type: 'line',
                data: {
                    labels: ['1950', '1960', '1970', '1980', '1990', '2000', '2010', '2020', '2025'],
                    datasets: [{
                        label: 'AI Investment (Billions USD)',
                        data: [0.1, 0.5, 1, 2, 5, 10, 30, 100, 200],
                        borderColor: '#3d5a80',
                        backgroundColor: 'rgba(61, 90, 128, 0.1)',
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { display: true }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'Investment (Billions USD)' }
                        }
                    }
                }
            });

            // DFS vs BFS Chart
            const dfsVsBfsCtx = document.getElementById('dfsVsBfsChart').getContext('2d');
            new Chart(dfsVsBfsCtx, {
                type: 'bar',
                data: {
                    labels: ['Space Complexity', 'Finds Shortest Path', 'Complete (Finite)', 'Memory Usage'],
                    datasets: [{
                        label: 'DFS',
                        data: [3, 1, 2, 2],
                        backgroundColor: '#3d5a80'
                    }, {
                        label: 'BFS',
                        data: [5, 5, 5, 5],
                        backgroundColor: '#98c1d9'
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { display: true }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 6,
                            title: { display: true, text: 'Score (1=Poor, 5=Excellent)' }
                        }
                    }
                }
            });

            // A* Comparison Chart
            const astarCtx = document.getElementById('astarComparisonChart').getContext('2d');
            new Chart(astarCtx, {
                type: 'bar',
                data: {
                    labels: ['BFS', 'DFS', 'Greedy Best-First', 'A*'],
                    datasets: [{
                        label: 'Nodes Explored (Arad to Bucharest)',
                        data: [16, 12, 8, 6],
                        backgroundColor: ['#ef4444', '#f59e0b', '#3b82f6', '#10b981']
                    }]
                },
                options: {
                    responsive: true,
                    indexAxis: 'y',
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            title: { display: true, text: 'Nodes Explored' }
                        }
                    }
                }
            });

            // Pruning Chart
            const pruningCtx = document.getElementById('pruningChart').getContext('2d');
            new Chart(pruningCtx, {
                type: 'bar',
                data: {
                    labels: ['Empty Board (Tic-Tac-Toe)', 'Mid-Game', 'Near End-Game'],
                    datasets: [{
                        label: 'Mini-Max',
                        data: [549946, 15000, 500],
                        backgroundColor: '#ef4444'
                    }, {
                        label: 'Alpha-Beta',
                        data: [18297, 2500, 150],
                        backgroundColor: '#10b981'
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { display: true }
                    },
                    scales: {
                        y: {
                            type: 'logarithmic',
                            title: { display: true, text: 'Nodes Explored (log scale)' }
                        }
                    }
                }
            });

            // Taxonomy Chart
            const taxonomyCtx = document.getElementById('taxonomyChart').getContext('2d');
            new Chart(taxonomyCtx, {
                type: 'doughnut',
                data: {
                    labels: ['Blind Search (DFS, BFS)', 'Informed Search (A*, Best-First)', 'Local Search (Hill Climbing)', 'Adversarial (Mini-Max, Alpha-Beta)'],
                    datasets: [{
                        data: [25, 35, 15, 25],
                        backgroundColor: ['#3d5a80', '#98c1d9', '#f59e0b', '#10b981']
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'right'
                        }
                    }
                }
            });

            // State Space Canvas
            const canvas = document.getElementById('stateSpaceCanvas');
            const ctx = canvas.getContext('2d');

            // Draw state space graph
            const nodes = [
                {x: 350, y: 30, label: 'S', color: '#10b981'},
                {x: 200, y: 100, label: 'A', color: '#3d5a80'},
                {x: 500, y: 100, label: 'B', color: '#3d5a80'},
                {x: 100, y: 180, label: 'C', color: '#3d5a80'},
                {x: 300, y: 180, label: 'D', color: '#3d5a80'},
                {x: 400, y: 180, label: 'E', color: '#3d5a80'},
                {x: 600, y: 180, label: 'F', color: '#3d5a80'},
                {x: 250, y: 260, label: 'G', color: '#f59e0b'},
            ];

            const edges = [
                [0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6], [4, 7], [5, 7]
            ];

            // Draw edges
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 2;
            edges.forEach(([from, to]) => {
                ctx.beginPath();
                ctx.moveTo(nodes[from].x, nodes[from].y);
                ctx.lineTo(nodes[to].x, nodes[to].y);
                ctx.stroke();
            });

            // Draw nodes
            nodes.forEach(node => {
                ctx.beginPath();
                ctx.arc(node.x, node.y, 25, 0, Math.PI * 2);
                ctx.fillStyle = node.color;
                ctx.fill();
                ctx.strokeStyle = '#1e3a5f';
                ctx.lineWidth = 3;
                ctx.stroke();

                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Segoe UI';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.label, node.x, node.y);
            });

            // Initialize Romania Map Animation
            initRomaniaMap();
        });

        // ================== ROMANIA MAP A* ANIMATION ==================

        // Romania map data with coordinates for visualization
        const romaniaNodes = {
            'Arad': { x: 90, y: 150, h: 366 },
            'Zerind': { x: 120, y: 80, h: 374 },
            'Oradea': { x: 180, y: 40, h: 380 },
            'Sibiu': { x: 250, y: 180, h: 253 },
            'Timisoara': { x: 90, y: 250, h: 329 },
            'Lugoj': { x: 180, y: 300, h: 244 },
            'Mehadia': { x: 200, y: 360, h: 241 },
            'Drobeta': { x: 180, y: 420, h: 242 },
            'Craiova': { x: 330, y: 420, h: 160 },
            'Rimnicu': { x: 340, y: 280, h: 193 },
            'Fagaras': { x: 420, y: 150, h: 176 },
            'Pitesti': { x: 450, y: 320, h: 100 },
            'Bucharest': { x: 600, y: 350, h: 0 },
            'Giurgiu': { x: 580, y: 450, h: 77 }
        };

        const romaniaEdges = [
            ['Arad', 'Zerind', 75],
            ['Arad', 'Sibiu', 140],
            ['Arad', 'Timisoara', 118],
            ['Zerind', 'Oradea', 71],
            ['Oradea', 'Sibiu', 151],
            ['Sibiu', 'Fagaras', 99],
            ['Sibiu', 'Rimnicu', 80],
            ['Timisoara', 'Lugoj', 111],
            ['Lugoj', 'Mehadia', 70],
            ['Mehadia', 'Drobeta', 75],
            ['Drobeta', 'Craiova', 120],
            ['Craiova', 'Rimnicu', 146],
            ['Craiova', 'Pitesti', 138],
            ['Rimnicu', 'Pitesti', 97],
            ['Fagaras', 'Bucharest', 211],
            ['Pitesti', 'Bucharest', 101],
            ['Bucharest', 'Giurgiu', 90]
        ];

        // A* search steps (pre-computed for animation)
        const aStarSteps = [
            {
                current: 'Arad',
                path: ['Arad'],
                g: 0,
                h: 366,
                f: 366,
                frontier: [
                    { node: 'Sibiu', f: 393, g: 140, h: 253 },
                    { node: 'Timisoara', f: 447, g: 118, h: 329 },
                    { node: 'Zerind', f: 449, g: 75, h: 374 }
                ],
                visited: ['Arad'],
                description: 'Start at Arad. Expand neighbors: Sibiu, Timisoara, Zerind'
            },
            {
                current: 'Sibiu',
                path: ['Arad', 'Sibiu'],
                g: 140,
                h: 253,
                f: 393,
                frontier: [
                    { node: 'Rimnicu', f: 413, g: 220, h: 193 },
                    { node: 'Fagaras', f: 415, g: 239, h: 176 },
                    { node: 'Timisoara', f: 447, g: 118, h: 329 },
                    { node: 'Zerind', f: 449, g: 75, h: 374 },
                    { node: 'Oradea', f: 671, g: 291, h: 380 }
                ],
                visited: ['Arad', 'Sibiu'],
                description: 'Expand Sibiu (lowest f=393). Add Rimnicu, Fagaras, Oradea'
            },
            {
                current: 'Rimnicu',
                path: ['Arad', 'Sibiu', 'Rimnicu'],
                g: 220,
                h: 193,
                f: 413,
                frontier: [
                    { node: 'Fagaras', f: 415, g: 239, h: 176 },
                    { node: 'Pitesti', f: 417, g: 317, h: 100 },
                    { node: 'Craiova', f: 526, g: 366, h: 160 },
                    { node: 'Timisoara', f: 447, g: 118, h: 329 }
                ],
                visited: ['Arad', 'Sibiu', 'Rimnicu'],
                description: 'Expand Rimnicu (f=413). Add Pitesti, Craiova'
            },
            {
                current: 'Fagaras',
                path: ['Arad', 'Sibiu', 'Fagaras'],
                g: 239,
                h: 176,
                f: 415,
                frontier: [
                    { node: 'Pitesti', f: 417, g: 317, h: 100 },
                    { node: 'Bucharest', f: 450, g: 450, h: 0 },
                    { node: 'Timisoara', f: 447, g: 118, h: 329 },
                    { node: 'Craiova', f: 526, g: 366, h: 160 }
                ],
                visited: ['Arad', 'Sibiu', 'Rimnicu', 'Fagaras'],
                description: 'Expand Fagaras (f=415). Bucharest found but f=450 > Pitesti'
            },
            {
                current: 'Pitesti',
                path: ['Arad', 'Sibiu', 'Rimnicu', 'Pitesti'],
                g: 317,
                h: 100,
                f: 417,
                frontier: [
                    { node: 'Bucharest', f: 418, g: 418, h: 0 },
                    { node: 'Timisoara', f: 447, g: 118, h: 329 },
                    { node: 'Craiova', f: 526, g: 366, h: 160 }
                ],
                visited: ['Arad', 'Sibiu', 'Rimnicu', 'Fagaras', 'Pitesti'],
                description: 'Expand Pitesti (f=417). Better path to Bucharest: f=418!'
            },
            {
                current: 'Bucharest',
                path: ['Arad', 'Sibiu', 'Rimnicu', 'Pitesti', 'Bucharest'],
                g: 418,
                h: 0,
                f: 418,
                frontier: [],
                visited: ['Arad', 'Sibiu', 'Rimnicu', 'Fagaras', 'Pitesti', 'Bucharest'],
                description: 'GOAL REACHED! Optimal path found: 418 km'
            }
        ];

        let currentStep = 0;
        let animationInterval = null;
        let animationSpeed = 1000;
        let mapCanvas, mapCtx;

        function initRomaniaMap() {
            mapCanvas = document.getElementById('romaniaMapCanvas');
            if (!mapCanvas) return;
            mapCtx = mapCanvas.getContext('2d');
            drawRomaniaMap();
        }

        function drawRomaniaMap() {
            if (!mapCtx) return;

            const step = aStarSteps[currentStep];

            // Clear canvas
            mapCtx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);

            // Draw title
            mapCtx.fillStyle = '#1e3a5f';
            mapCtx.font = 'bold 18px Segoe UI';
            mapCtx.textAlign = 'center';
            mapCtx.fillText('Romania Map - A* Pathfinding', mapCanvas.width / 2, 25);

            // Scale and offset for better positioning
            const scale = 1.1;
            const offsetX = 80;
            const offsetY = 30;

            // Draw edges
            romaniaEdges.forEach(([from, to, cost]) => {
                const fromNode = romaniaNodes[from];
                const toNode = romaniaNodes[to];
                const x1 = fromNode.x * scale + offsetX;
                const y1 = fromNode.y * scale + offsetY;
                const x2 = toNode.x * scale + offsetX;
                const y2 = toNode.y * scale + offsetY;

                // Check if this edge is in the current path
                const pathIndex1 = step.path.indexOf(from);
                const pathIndex2 = step.path.indexOf(to);
                const isInPath = pathIndex1 !== -1 && pathIndex2 !== -1 && Math.abs(pathIndex1 - pathIndex2) === 1;

                // Check if this is the final path
                const isFinalPath = currentStep === aStarSteps.length - 1 && isInPath;

                if (isFinalPath) {
                    // Highlight final optimal path
                    mapCtx.strokeStyle = '#22c55e';
                    mapCtx.lineWidth = 6;
                    mapCtx.setLineDash([]);

                    // Glow effect
                    mapCtx.shadowColor = '#22c55e';
                    mapCtx.shadowBlur = 15;
                } else if (isInPath) {
                    mapCtx.strokeStyle = '#3b82f6';
                    mapCtx.lineWidth = 4;
                    mapCtx.setLineDash([]);
                    mapCtx.shadowBlur = 0;
                } else {
                    mapCtx.strokeStyle = '#cbd5e1';
                    mapCtx.lineWidth = 2;
                    mapCtx.setLineDash([]);
                    mapCtx.shadowBlur = 0;
                }

                mapCtx.beginPath();
                mapCtx.moveTo(x1, y1);
                mapCtx.lineTo(x2, y2);
                mapCtx.stroke();
                mapCtx.shadowBlur = 0;

                // Draw distance label
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                mapCtx.fillStyle = '#64748b';
                mapCtx.font = '10px Segoe UI';
                mapCtx.textAlign = 'center';
                mapCtx.fillText(cost + ' km', midX, midY - 5);
            });

            // Draw nodes
            Object.entries(romaniaNodes).forEach(([name, node]) => {
                const x = node.x * scale + offsetX;
                const y = node.y * scale + offsetY;

                let nodeColor = '#94a3b8'; // Default gray
                let nodeRadius = 22;
                let textColor = 'white';

                if (name === 'Arad') {
                    nodeColor = '#10b981'; // Green - start
                } else if (name === 'Bucharest') {
                    nodeColor = '#f59e0b'; // Yellow - goal
                }

                if (step.visited.includes(name)) {
                    if (name !== 'Arad' && name !== 'Bucharest') {
                        nodeColor = '#6b7280'; // Visited
                    }
                }

                if (name === step.current) {
                    nodeColor = '#3b82f6'; // Current node - blue
                    nodeRadius = 26;
                }

                // Final path highlighting
                if (currentStep === aStarSteps.length - 1 && step.path.includes(name)) {
                    nodeColor = name === 'Arad' ? '#10b981' : name === 'Bucharest' ? '#22c55e' : '#22c55e';
                    nodeRadius = 26;
                }

                // Draw node circle
                mapCtx.beginPath();
                mapCtx.arc(x, y, nodeRadius, 0, Math.PI * 2);
                mapCtx.fillStyle = nodeColor;
                mapCtx.fill();
                mapCtx.strokeStyle = '#1e3a5f';
                mapCtx.lineWidth = 3;
                mapCtx.stroke();

                // Draw node label
                mapCtx.fillStyle = textColor;
                mapCtx.font = 'bold 11px Segoe UI';
                mapCtx.textAlign = 'center';
                mapCtx.textBaseline = 'middle';

                // Abbreviate long names
                let displayName = name;
                if (name.length > 6) {
                    displayName = name.substring(0, 5) + '.';
                }
                mapCtx.fillText(displayName, x, y);

                // Draw h(n) value below node
                mapCtx.fillStyle = '#64748b';
                mapCtx.font = '9px Segoe UI';
                mapCtx.fillText('h=' + node.h, x, y + nodeRadius + 12);
            });

            // Draw arrow for path direction
            if (step.path.length > 1) {
                mapCtx.fillStyle = '#1e3a5f';
                mapCtx.font = 'bold 14px Segoe UI';
                mapCtx.textAlign = 'left';
                mapCtx.fillText('Path: ' + step.path.join('  '), 20, mapCanvas.height - 20);
            }

            // Update info panel
            updateInfoPanel(step);
        }

        function updateInfoPanel(step) {
            document.getElementById('currentNode').textContent = step.current;
            document.getElementById('gValue').textContent = step.g + ' km';
            document.getElementById('hValue').textContent = step.h + ' km';
            document.getElementById('fValue').textContent = step.f + ' km';
            document.getElementById('currentPath').textContent = step.path.join('  ');
            document.getElementById('stepNumber').textContent = currentStep + ' / ' + (aStarSteps.length - 1);
            document.getElementById('stepDescription').textContent = step.description;

            // Update frontier list
            if (step.frontier.length > 0) {
                const frontierStr = step.frontier
                    .map(f => `${f.node}(f=${f.f})`)
                    .join(', ');
                document.getElementById('frontierList').textContent = frontierStr;
            } else {
                document.getElementById('frontierList').textContent = 'Empty - Goal reached!';
            }
        }

        function toggleAnimation() {
            const playBtn = document.getElementById('playBtn');
            const playIcon = document.getElementById('playIcon');
            const playText = document.getElementById('playText');

            if (animationInterval) {
                // Pause
                clearInterval(animationInterval);
                animationInterval = null;
                playIcon.className = 'fas fa-play';
                playText.textContent = 'Play Animation';
                playBtn.style.background = '#10b981';
            } else {
                // Play
                if (currentStep >= aStarSteps.length - 1) {
                    currentStep = 0;
                }
                playIcon.className = 'fas fa-pause';
                playText.textContent = 'Pause';
                playBtn.style.background = '#ef4444';

                animationInterval = setInterval(() => {
                    if (currentStep < aStarSteps.length - 1) {
                        currentStep++;
                        drawRomaniaMap();
                    } else {
                        clearInterval(animationInterval);
                        animationInterval = null;
                        playIcon.className = 'fas fa-play';
                        playText.textContent = 'Play Again';
                        playBtn.style.background = '#10b981';
                    }
                }, animationSpeed);
            }
        }

        function resetAnimation() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
            currentStep = 0;
            drawRomaniaMap();

            const playIcon = document.getElementById('playIcon');
            const playText = document.getElementById('playText');
            const playBtn = document.getElementById('playBtn');
            playIcon.className = 'fas fa-play';
            playText.textContent = 'Play Animation';
            playBtn.style.background = '#10b981';
        }

        function stepForward() {
            if (currentStep < aStarSteps.length - 1) {
                currentStep++;
                drawRomaniaMap();
            }
        }

        function changeSpeed() {
            animationSpeed = parseInt(document.getElementById('speedSelect').value);
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = setInterval(() => {
                    if (currentStep < aStarSteps.length - 1) {
                        currentStep++;
                        drawRomaniaMap();
                    } else {
                        clearInterval(animationInterval);
                        animationInterval = null;
                        document.getElementById('playIcon').className = 'fas fa-play';
                        document.getElementById('playText').textContent = 'Play Again';
                        document.getElementById('playBtn').style.background = '#10b981';
                    }
                }, animationSpeed);
            }
        }
    </script>
</body>
</html>